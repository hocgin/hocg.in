{"meta":{"title":"hocgin (๑`灬´๑)","subtitle":"Great minds have purpose, others have wishes.","description":"Ubuntu | Java | Android | HTML5 | CSS3","author":"hocgin","url":"https://hocg.in"},"pages":[{"title":"404","date":"2016-12-24T09:10:27.000Z","updated":"2016-04-14T09:17:59.000Z","comments":true,"path":"baidu_verify_JCkKHZdfNm.html","permalink":"https://hocg.in/baidu_verify_JCkKHZdfNm.html","excerpt":"","text":"JCkKHZdfNm"},{"title":"404","date":"2016-12-24T09:10:26.000Z","updated":"2016-05-28T07:27:40.000Z","comments":true,"path":"404.html","permalink":"https://hocg.in/404.html","excerpt":"","text":"(｡•́︿•̀｡) 找不到了 body { background-color: #ECECEC; font-family: Arial, Helvetica, sans-serif; font-size: 14px; color: #3c3c3c; padding-top: 150px; } .page404 .f404 { text-align: center; font-size: 150px; font-weight: bold; line-height: 100px; letter-spacing: 5px; color: #fff; margin-bottom: 60px; } .page404 .f404 span { cursor: pointer; text-shadow: 0px 0px 2px #686868, 0px 1px 1px #ddd, 0px 2px 1px #d6d6d6, 0px 3px 1px #ccc, 0px 4px 1px #c5c5c5, 0px 5px 1px #c1c1c1, 0px 6px 1px #bbb, 0px 7px 1px #777, 0px 8px 3px rgba(100, 100, 100, 0.4), 0px 9px 5px rgba(100, 100, 100, 0.1), 0px 10px 7px rgba(100, 100, 100, 0.15), 0px 11px 9px rgba(100, 100, 100, 0.2), 0px 12px 11px rgba(100, 100, 100, 0.25), 0px 13px 15px rgba(100, 100, 100, 0.3); -webkit-transition: all .1s linear; transition: all .1s linear; } .page404 .f404 span:hover { text-shadow: 0px 0px 2px #686868, 0px 1px 1px #fff, 0px 2px 1px #fff, 0px 3px 1px #fff, 0px 4px 1px #fff, 0px 5px 1px #fff, 0px 6px 1px #fff, 0px 7px 1px #777, 0px 8px 3px #fff, 0px 9px 5px #fff, 0px 10px 7px #fff, 0px 11px 9px #fff, 0px 12px 11px #fff, 0px 13px 15px #fff; -webkit-transition: all .1s linear; transition: all .1s linear; } .page404 .f404-des { text-align: center; color: #666; font-family: cursive; font-size: 20px; text-shadow: 0 1px 0 #fff; letter-spacing: 1px; line-height: 2em; font-weight: bold; } .go-home { text-decoration: none; color: #666; } .go-home:hover { color: white; } 404 页面跑没了!?"},{"title":"分类","date":"2018-05-05T16:10:31.313Z","updated":"2018-05-05T12:32:30.213Z","comments":true,"path":"categories/index.html","permalink":"https://hocg.in/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-05T16:10:31.323Z","updated":"2018-05-05T12:34:45.009Z","comments":true,"path":"tags/index.html","permalink":"https://hocg.in/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2018 图片墙","slug":"2018 图片墙","date":"2018-12-31T15:59:59.000Z","updated":"2018-05-11T16:10:24.604Z","comments":true,"path":"2018/12/31/2018 图片墙/","link":"","permalink":"https://hocg.in/2018/12/31/2018 图片墙/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"https://hocg.in/categories/生活/"}],"tags":[{"name":"图片墙","slug":"图片墙","permalink":"https://hocg.in/tags/图片墙/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://hocg.in/categories/生活/"}]},{"title":"关于Java IO、NIO、AIO","slug":"关于Java IO、NIO、AIO","date":"2018-07-02T00:10:39.000Z","updated":"2018-07-03T05:31:16.752Z","comments":true,"path":"2018/07/02/关于Java IO、NIO、AIO/","link":"","permalink":"https://hocg.in/2018/07/02/关于Java IO、NIO、AIO/","excerpt":"关于Java常用数据结构，后期继续整理","text":"关于Java常用数据结构，后期继续整理 关于 IO BIO 同步并阻塞 NIO 同步非阻塞 AIO(NIO.2) JDK7, 异步非阻塞 NIO Channel 通道 传输 Buffer 缓冲区 存储 Selectors 多路复用器 监听 Channel IO 状况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349/** * Created by hocgin on 2018/7/2. * email: hocgin@gmail.com * NIO * Non-blocking IO（非阻塞IO） * - Selectors 多路复用器，用于监控 SelectableChannel IO状况 * -- SelectableChannel * ----SocketChannel * ----ServerSocketChannel * ----DatagramChannel * &lt;p&gt; * ----Pipe.SinkChannel 单向管道-写 * ----Pipe.SourceChannel 单向管道-读 * &lt;p&gt; * - Channels * &lt;p&gt; * - Buffers * -- capacity 总容量 * -- limit 界限，可操作最大范围 * -- position 当前操作位置 * -- mark 标记，记录position * &lt;p&gt; * 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity */public class NIOTest &#123; /** * 阻塞模式的 Socket NIO */ @Test public void nio_client() &#123; String path = \"/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java\"; try ( SocketChannel channel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898)); FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); ) &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (inChannel.read(buffer) != -1) &#123; buffer.flip(); channel.write(buffer); buffer.clear(); &#125; channel.shutdownOutput(); /** * 接收反馈 */ while (channel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); buffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 阻塞模式的 Socket NIO */ @Test public void nio_server() &#123; try ( ServerSocketChannel channel = ServerSocketChannel.open(); ) &#123; channel.bind(new InetSocketAddress(9898)); SocketChannel socketChannel = channel.accept(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (socketChannel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); buffer.clear(); &#125; buffer.put(\"接收完毕\".getBytes()); buffer.flip(); socketChannel.write(buffer); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 非阻塞模式的 Socket NIO */ @Test public void nio_client2() &#123; try ( SocketChannel channel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898)); ) &#123; // 非阻塞 channel.configureBlocking(false); ByteBuffer buffer = ByteBuffer.allocate(1024); /** * 发送信息 */ buffer.put(LocalDateTime.now().toString().getBytes()); buffer.flip(); channel.write(buffer); /** * 接收反馈 */ &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 非阻塞模式的 Socket NIO */ @Test public void nio_server2() &#123; try ( ServerSocketChannel channel = ServerSocketChannel.open(); ) &#123; // 非阻塞 channel.configureBlocking(false); channel.bind(new InetSocketAddress(9898)); Selector selector = Selector.open(); /** * 注册通道 指定事件类型 */ channel.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey action = iterator.next(); if (action.isAcceptable()) &#123; SocketChannel socketChannel = channel.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (action.isReadable()) &#123; SocketChannel socketChannel = (SocketChannel) action.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); try &#123; while (socketChannel.read(buffer) != -1) &#123; buffer.flip(); String s = new String(buffer.array(), 0, buffer.limit()); if (!Strings.isNullOrEmpty(s)) &#123; System.out.println(s); &#125; buffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; iterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void aio_server() throws IOException, InterruptedException &#123;// AsynchronousChannelGroup group = AsynchronousChannelGroup.withCachedThreadPool(Executors.newCachedThreadPool(), 10); AsynchronousServerSocketChannel channel = AsynchronousServerSocketChannel.open(); channel.bind(new InetSocketAddress(9898)); channel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123; final ByteBuffer buffer = ByteBuffer.allocate(1024); @Override public void completed(AsynchronousSocketChannel result, Void attachment) &#123; try &#123; result.read(buffer).get(); buffer.flip(); System.out.println(String.format(\"服务端 成功 :%s\", new String(buffer.array()).trim())); result.close(); channel.accept(null, this); &#125; catch (IOException | InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, Void attachment) &#123; System.out.println(\"failed\"); &#125; &#125;); LockSupport.park(); &#125; @Test public void aio_client() throws IOException &#123; AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(); channel.connect(new InetSocketAddress(\"127.0.0.1\", 9898), null, new CompletionHandler&lt;Void, Void&gt;() &#123; @Override public void completed(Void result, Void attachment) &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.put(\"你好\".getBytes()); buffer.flip(); channel.write(buffer); &#125; @Override public void failed(Throwable exc, Void attachment) &#123; System.out.println(exc); &#125; &#125;); &#125; /** * Buffer * * @throws IOException */ @Test public void buffer() throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); System.out.println(buffer.position()); // 0 System.out.println(buffer.limit()); // 1024 System.out.println(buffer.capacity()); // 1024 buffer.put(\"asd\".getBytes()); buffer.flip(); // 设置读取的范围限制至 position byte[] dst = new byte[buffer.limit()]; buffer.get(dst); System.out.println(new String(dst, 0, dst.length)); buffer.rewind(); // 重读 position = 0 mark = -1 buffer.clear(); // 清空 position = 0 limit = capacity mark = -1 buffer.mark(); // 标记 mark = position buffer.reset(); // position恢复为标记位置 position = mark buffer.hasRemaining(); // 是否有剩余数据 position &lt; limit buffer.remaining(); // 剩余数量 limit - position &#125; /** * getChannel * - 本地 * - FileInputStream/FileOutputStream * - RandomAccessFile * - 网络 * - Socket * - ServerSocket * - DatagramSocket * - JDK 7 * - xxChannel.open() * - Files.newByteChannel() * - Channels.newXXX */ @Test public void channel() throws IOException &#123; String path = \"/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java\"; FileInputStream in = new FileInputStream(path); ReadableByteChannel channel = Channels.newChannel(in); ByteBuffer buffer = ByteBuffer.allocate(1024); while (channel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(String.format(\"%s\", new String(buffer.array(), 0, buffer.limit()))); buffer.clear(); &#125; channel.close(); in.close(); &#125; /** * 直接缓冲区 */ @Test public void channel2() &#123; String path = \"/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java\"; try ( FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE) ) &#123; MappedByteBuffer inMap = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMap = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); byte[] bytes = new byte[inMap.limit()]; inMap.get(bytes); outMap.put(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 通道间的数据传输(直接缓冲区) */ @Test public void transfer() &#123; String path = \"/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java\"; try ( FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE) ) &#123; inChannel.transferTo(0, inChannel.size(), outChannel);// inChannel.transferFrom(outChannel,0, inChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 分散读取(Scatter) * 聚集写入(Gather) */ @Test public void scatter() &#123; String path = \"/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java\"; try ( RandomAccessFile f = new RandomAccessFile(path, \"rw\"); ) &#123; FileChannel channel = f.getChannel(); ByteBuffer allocate1 = ByteBuffer.allocate(1024); ByteBuffer allocate2 = ByteBuffer.allocate(1024); ByteBuffer[] all = &#123;allocate1, allocate2&#125;; // 分散读取 channel.read(all); // 聚集写入 channel.write(all); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets(); System.out.println(map); System.out.println(Charset.defaultCharset()); Charset charset = Charset.forName(\"UTF-8\"); CharsetEncoder charsetEncoder = charset.newEncoder(); CharsetDecoder charsetDecoder = charset.newDecoder(); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://hocg.in/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"使用 GitLab 来对 Spring Boot 项目进行 CI/CD","slug":"使用 GitLab 来对 Spring Boot 项目进行 CI:CD","date":"2018-06-20T14:34:20.000Z","updated":"2018-06-20T14:44:41.968Z","comments":true,"path":"2018/06/20/使用 GitLab 来对 Spring Boot 项目进行 CI:CD/","link":"","permalink":"https://hocg.in/2018/06/20/使用 GitLab 来对 Spring Boot 项目进行 CI:CD/","excerpt":"利用 GitLab Pipelines 来进行项目的持续集成和部署。","text":"利用 GitLab Pipelines 来进行项目的持续集成和部署。 使用 GitLab CI 构建 Spring Boot 项目搭建 GitLab CE 使用 Docker 方式搭建 GitLab CE 12345678910sudo docker run --detach \\ --publish 443:443 \\ --publish 80:80 \\ --publish 2222:22 \\ --name gitlab \\ --restart always \\ --volume /data/gitlab/config:/etc/gitlab \\ --volume /data/gitlab/logs:/var/log/gitlab \\ --volume /data/gitlab/data:/var/opt/gitlab \\ gitlab/gitlab-ce:latest 搭建 GitLab Runner123456sudo docker run --rm -t -d -i -p 8084:8080 \\ -v /data/gitlab-runner:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ --add-host ad4aac43c567:172.17.0.2 \\ --name gitlab-runner \\ gitlab/gitlab-runner 此处需注意--add-host请自行替换为GitLab CE Docker 容器 ID，此处是为了让 GitLab CE Docker 容器可以被 GitLab Runner 访问到, 如果使用公网 IP 可以忽略。 如果通过/etc/hosts仍然无法解决HOST问题, 请自行更改/data/gitlab-runner/config.toml文件，在[runners.docker]节点下面添加extra_hosts = [&quot;ad4aac43c567:172.17.0.2&quot;]。 注册 Runner12345678910sudo docker exec -it gitlab-runner gitlab-runner register -n \\ --url http://192.168.1.13/ \\ --registration-token pfHxurfRMBctWwkqrt1c \\ --tag-list=docker-privileged \\ --description \"dockersock\" \\ --docker-privileged=false \\ --docker-image \"docker:latest\" \\ --docker-volumes /var/run/docker.sock:/var/run/docker.sock \\ --docker-volumes /root/m2:/root/.m2 \\ --executor docker url: GitLab CE 里面 CI 栏目查看 registration-token: GitLab CE 里面 CI 栏目查看 tag-list: 标签, 后续用于执行步骤时指定 Runner description: 描述 docker-image: 外层使用的 Docker 镜像 executor: 执行器 编写 .gitlab-ci.yml点击.gitlab-ci.yml查看 一键部署点击获取, 记得修改HOST。 源码GitLab-CI","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://hocg.in/categories/DevOps/"}],"tags":[{"name":"DevOps","slug":"DevOps","permalink":"https://hocg.in/tags/DevOps/"},{"name":"GitLab","slug":"GitLab","permalink":"https://hocg.in/tags/GitLab/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://hocg.in/tags/CI-CD/"}],"keywords":[{"name":"DevOps","slug":"DevOps","permalink":"https://hocg.in/categories/DevOps/"}]},{"title":"关于Java-数据结构","slug":"关于Java-数据结构","date":"2018-03-20T09:10:39.000Z","updated":"2018-07-03T05:26:19.515Z","comments":true,"path":"2018/03/20/关于Java-数据结构/","link":"","permalink":"https://hocg.in/2018/03/20/关于Java-数据结构/","excerpt":"关于Java常用数据结构，后期继续整理","text":"关于Java常用数据结构，后期继续整理 List List必须保持元素特定的顺序 LinkedList List、Queue 双链表Node 非线程安全的 转换为线程安全Collections.synchronizedList(new LinkedList(...)); 特点: 实现了List、Deque接口，双向链表，适合频繁插入/删除，不适合使用set、set。 ArrayList List 数组实现 非线程安全的 特点: 动态长度(默认长度为10，增长默认为当前长度的1/2，不可大于Integer.MAX_VALUE - 8，否则 OutOfMemoryError), get、set直接访问。 Vector List 线程安全 用synchronized修饰函数 CopyOnWriteArrayList List 数组实现 线程安全 特点: 数组长度默认为0，每次修改都会重新增长长度和拷贝数组。 Stack 线程不安全 数组实现 特点: 模拟栈。 工具类 转换为线程安全Collections.synchronizedList(new ArrayList(...)); 内部是用List实现存储的 与Vector差别是可以传入定制的锁。 转为不可变List Collections.unmodifiableList(new ArrayList&lt;&gt;()) 门面模式(List) 线程安全 特点: 不可变。 常用技巧123456789101112131415161718192021222324252627282930313233@Testpublic void lists() &#123; /** * 打乱数组 */ List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); Collections.shuffle(list); System.out.println(String.format(\"打乱 %s\", list)); /** * 移除所有 NULL */ list.removeIf(Objects::isNull); /** * 去重 */ list = list.stream().distinct().collect(Collectors.toList()); /** * 分组 */ Map&lt;String, List&lt;Integer&gt;&gt; collect = list.stream() .collect(Collectors.groupingBy(Object::toString)); /** * 查找一个元素 */ Integer integer = list.stream().filter(item -&gt; &#123; return item == 1; &#125;).findAny().orElse(null); &#125; Set Set不能有重复元素 HashSet Set 线程不安全 利用 HashMap 的 Key 值进行存储。 无序 利用Hash存储，存取和查找高效。 LinkedHashSet Set 线程不安全 利用 LinkedHashMap 的 Key 值进行存储。 按插入排序 TreeSet Set 线程不安全 利用 TreeMap 的 Key 值进行存储。 插入有序, 默认自然排序。 Queue Queue保持一个队列(先进先出)的顺序. PriorityQueue Queue 线程不安全 数组实现 Deque Queue 双端队列ArrayDeque Queue 数组实现 线程不安全 动态长度 BlockingQueueDelayQueueMap 用于保存具有”映射关系”的数据 HashMap 不能保证key-value对的顺序 线程不安全 LinkedHashMap 插入顺序 线程不安全 TreeMap 线程不安全 插入有序, 默认自然排序。 ConcurrentHashMap 线程安全 特点: 分多个块 推荐","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://hocg.in/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"关于Java多线程-几个辅助类","slug":"关于Java多线程-几个辅助类","date":"2018-03-06T09:13:39.000Z","updated":"2018-07-03T05:24:51.368Z","comments":true,"path":"2018/03/06/关于Java多线程-几个辅助类/","link":"","permalink":"https://hocg.in/2018/03/06/关于Java多线程-几个辅助类/","excerpt":"关于Java多线程-几个辅助类，后期继续整理","text":"关于Java多线程-几个辅助类，后期继续整理 几个辅助类 CountDownLatch 计数器 CyclicBarrier 同步器 Phaser 1.7 阶段性、同步、计数 Example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188 ExecutorService executorService = Executors.newFixedThreadPool(4); /** * 计数器 latch.await() 会等待计数为 0 * @throws InterruptedException */ @Test public void countDownLatch() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(4); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(latch::countDown); System.out.println(String.format(\"index: %d\", latch.getCount())); &#125;); latch.await(); System.out.println(String.format(\"index: %d\", latch.getCount()));// index: 4// index: 3// index: 2// index: 1// index: 0 &#125; /** * 等待指定数目的线程完成后, 才继续执行 * @throws InterruptedException */ @Test public void cyclicBarrier() throws InterruptedException &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, ()-&gt;&#123; System.out.println(\"所有任务执行完成，继续\"); &#125;); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format(\"已经完成数目: %d/%d\", cyclicBarrier.getNumberWaiting(), cyclicBarrier.getParties())); Thread.sleep(100); cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format(\"进行其他任务 %s\", Thread.currentThread().getName())); &#125;); &#125;); Thread.sleep(1000); // 已经完成数目: 0/4// 已经完成数目: 0/4// 已经完成数目: 0/4// 已经完成数目: 0/4// 所有任务执行完成，继续// 进行其他任务 pool-1-thread-4// 进行其他任务 pool-1-thread-2// 进行其他任务 pool-1-thread-1// 进行其他任务 pool-1-thread-3 &#125; /** * 配置同时允许申请许可的数目，如果数目已满则进行阻塞等待释放许可。 * Semaphore 可配置是否使用公平机制，类似Lock * @throws InterruptedException */ @Test public void semaphore() throws InterruptedException &#123; Semaphore semaphore = new Semaphore(2); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format(\"正在申请许可 ID:%s\", Thread.currentThread().getName())); semaphore.acquire(); System.out.println(String.format(\"申请许可成功 %s\", Thread.currentThread().getName())); Thread.sleep(100); System.out.println(String.format(\"进行任务 %s\", Thread.currentThread().getName())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(String.format(\"释放许可 %s\", Thread.currentThread().getName())); semaphore.release(); &#125; &#125;); &#125;); Thread.sleep(1000); // 正在申请许可 ID:pool-1-thread-2// 正在申请许可 ID:pool-1-thread-1// 申请许可成功 pool-1-thread-2// 正在申请许可 ID:pool-1-thread-4// 正在申请许可 ID:pool-1-thread-3// 申请许可成功 pool-1-thread-1// 进行任务 pool-1-thread-1// 进行任务 pool-1-thread-2// 释放许可 pool-1-thread-1// 释放许可 pool-1-thread-2// 申请许可成功 pool-1-thread-4// 申请许可成功 pool-1-thread-3// 进行任务 pool-1-thread-4// 进行任务 pool-1-thread-3// 释放许可 pool-1-thread-4// 释放许可 pool-1-thread-3 &#125; /** * 阶段性, 会等待所有人完成该步骤再进入下一个步骤 * - 每个阶段均可进行加入或移除 * * 函数 * - arriveAndAwaitAdvance 等待阶段 * - arriveAndDeregister 移除 * - bulkRegister 加入 */ @Test public void phaser() throws InterruptedException &#123; Phaser phaser = new Phaser(4); /** * 阶段性任务 */ System.out.println(\"【阶段性任务】\"); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format(\"第一步 %s\", Thread.currentThread().getName())); Thread.sleep(100); phaser.arriveAndAwaitAdvance(); Thread.sleep(100); System.out.println(String.format(\"第2步 %s\", Thread.currentThread().getName())); phaser.arriveAndAwaitAdvance(); Thread.sleep(100); System.out.println(String.format(\"第三步 %s\", Thread.currentThread().getName())); phaser.arriveAndAwaitAdvance(); System.out.println(\"Done\"); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;); Thread.sleep(1000); /** * 计数任务 */ System.out.println(\"【计数任务】\"); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format(\"已经完成 %s\", Thread.currentThread().getName())); Thread.sleep(100); phaser.awaitAdvance(phaser.getPhase()); //cyclicBarrier.await(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;); phaser.arrive(); System.out.println(\"计数完成\"); // 【阶段性任务】// 第一步 pool-1-thread-2// 第一步 pool-1-thread-3// 第一步 pool-1-thread-1// 第一步 pool-1-thread-4// 第2步 pool-1-thread-2// 第2步 pool-1-thread-1// 第2步 pool-1-thread-4// 第2步 pool-1-thread-3// 第三步 pool-1-thread-1// 第三步 pool-1-thread-4// 第三步 pool-1-thread-2// 第三步 pool-1-thread-3// Done// Done// Done// Done// 【计数任务】// 计数完成// 已经完成 pool-1-thread-2// 已经完成 pool-1-thread-4// 已经完成 pool-1-thread-3// 已经完成 pool-1-thread-1 &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://hocg.in/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"关于Java多线程-可见性、CAS、AQS、锁","slug":"关于Java多线程-可见性、CAS、AQS、锁","date":"2018-03-03T01:13:39.000Z","updated":"2018-07-03T05:25:02.728Z","comments":true,"path":"2018/03/03/关于Java多线程-可见性、CAS、AQS、锁/","link":"","permalink":"https://hocg.in/2018/03/03/关于Java多线程-可见性、CAS、AQS、锁/","excerpt":"关于Java多线程-可见性、CAS、AQS、锁","text":"关于Java多线程-可见性、CAS、AQS、锁 前提 解决多线程操作出现的脏读和数据、操作不一致问题。 volatile可见性 Java 内存分为主内存和工作内存。正常情况每个线程都拥有自己的工作内存，然后每隔一段时间会同步到主内存上，因此会存在不一致的情况。而volatile则是为了让标记字段的读取和写入都是在主内存中，保证其一致性。注意:但其仍不能保证写入操作的原子性。 CAS Compare And Swap, 比较并交换。用于解决多线程使用锁造成的性能损耗。Java 是利用Unsafe来实现CAS，进行硬件级别的原子性操作。 AQS AbstractQueuedSynchronizer, 这个为 Java 类, 公平锁FairSync和非公平锁NonfairSync均是通过此实现的。其利用队列来实现阻塞锁和同步。 ABA 问题 情景: 初始值为A[线程1获取的值为A][线程2获取的值为A,并更改值A为值B,再更改值B为值A][线程1更改值A为值B]。出现问题: 线程1感觉不到值有一段变化的过程，这是乐观锁出现的问题。解决方案: AtomicStampedReference/AtomicMarkableReference你值得拥有。 AtomicStampedReference 每次修改会存储版本号,版本号实现用int。 AtomicMarkableReference 每次修改会存储版本号,版本号实现用boolean。 锁的名词可重入锁 已获取的锁可以不必去重新申请。 synchronized/ReentrantLock 是可重入锁. 可中断锁 可以取消申请锁的操作。 synchronized 不是可中断锁。 公平锁 公平锁是根据请求顺序分发锁, 唤醒需要时间，能保- 证操作的顺序。 非公平锁会出现插队情况，性能高，但是不能保证操作的顺序。 synchronized 不是公平锁。 ReentrantLock/ReentrantReadWriteLock默认情况是非公平锁NonfairSync,但可以设置为公平锁FairSync 乐观锁 每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。 Atomic* 乐观锁 由于在多线程操作中无法保证操作的原子性，因此引入了锁和CAS。AtomicStampedReference/AtomicMarkableReference 用于解决 CAS 的 ABA 问题 单 AtomicInteger Integer类型 AtomicLong Long类型 AtomicBoolean Boolean类型,内部使用int实现。 AtomicReference 对象类型 数组 AtomicIntegerArray Integer数组 AtomicLongArray Long数组 AtomicReferenceArray 对象数组 对象内字段 AtomicIntegerFieldUpdater 对象内Integer类型字段 AtomicLongFieldUpdater 对象内Long类型字段 AtomicReferenceFieldUpdater 对象内对象类型字段 根据版本号进行操作 AtomicStampedReference 每次修改会存储版本号,版本号实现用int。 AtomicMarkableReference 每次修改会存储版本号,版本号实现用boolean。 锁和同步 锁和同步的作用保证代码区域在同一时间只运行一个线程去执行,其余线程处于阻塞状态(BLOCKED)。 锁和同步的差异。 作用范围, Lock 可以跨方法，synchronized 只能在同一个方法中。 公平锁, Lock 使用公平锁，synchronized 使用非公平锁。 可中断，Lock 可以使用lockInterruptibly()中断锁，synchronized 无法中断。 当 synchronized 无法访问时会被阻塞，Lock 提供tryLock()减少阻塞时间。 不释放锁操作 同步代码中使用Thread.sleep/Thread.yield, 线程处于WAITING/TIMED_WAITING状态 同步代码中线程被suspend() 会释放锁操作 同步代码被break、return 同步代码被异常或错误终止 同步代码块执行结束 同步代码块被 wait(), 线程处于WAITING/TIMED_WAITING状态 锁Lock的相关实现 NonfairSync、FairSync ReentrantLock1234567891011121314151617181920212223242526272829303132 /** * 可重入锁 * 已获取的锁可以不必去重新申请。 * 例如： * synchronized(lock)&#123; * synchronized(lock)&#123; * //.. * &#125; * &#125; */@Testpublic void reentrantLock() &#123; ReentrantLock lock = new ReentrantLock(); System.out.println(String.format(\"是否公平锁 %b\", lock.isFair())); // 是否公平锁 false /** * 可重入锁, 在同一个线程内不用反复申请锁(只是计数+1)。 * 如果不同线程会尝试关掉当前线程(interrupt) */ lock.lock(); System.out.println(String.format(\"该锁是否已被获取 %b\", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format(\"是否有线程在等待获取该锁 %b\", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.lock(); System.out.println(String.format(\"该锁是否已被获取 %b\", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format(\"是否有线程在等待获取该锁 %b\", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.unlock(); System.out.println(String.format(\"该锁是否已被获取 %b\", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format(\"是否有线程在等待获取该锁 %b\", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.unlock(); System.out.println(String.format(\"该锁是否已被获取 %b\", lock.isHeldByCurrentThread())); // 该锁是否已被获取 false System.out.println(String.format(\"是否有线程在等待获取该锁 %b\", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false&#125; ReentrantReadWriteLock 读写锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /** * 读写锁 * 读锁 &amp; 读锁 之间不会堵塞 * 写锁 &amp; 读锁/写锁 都会发生堵塞 */ @Test public void reentrantReadWriteLock() throws InterruptedException &#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); Runnable rRunable = () -&gt; &#123; lock.readLock().lock(); System.out.println(String.format(\"获取 %s锁 %s\", lock.isWriteLocked()?\"写\":\"读\", Thread.currentThread().getName())); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format(\"关掉 %s锁 %s\", lock.isWriteLocked()?\"写\":\"读\", Thread.currentThread().getName())); lock.readLock().unlock(); &#125;; Runnable wRunable = () -&gt; &#123; lock.writeLock().lock(); System.out.println(String.format(\"获取 %s锁 %s\", lock.isWriteLocked()?\"写\":\"读\", Thread.currentThread().getName())); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format(\"关掉 %s锁 %s\", lock.isWriteLocked()?\"写\":\"读\", Thread.currentThread().getName())); lock.writeLock().unlock(); &#125;; Thread rthread = new Thread(rRunable); Thread rthread2 = new Thread(rRunable); Thread wthread = new Thread(wRunable); Thread wthread2 = new Thread(wRunable); /** * 读-&gt;写-&gt;读 * * 获取 读锁 Thread-1 * 关掉 读锁 Thread-1 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 * 获取 读锁 Thread-2 * 关掉 读锁 Thread-2 */// System.out.println(\"读-&gt;写-&gt;读\");// rthread.start();// Thread.sleep(100);// wthread.start();// Thread.sleep(100);// rthread2.start(); /** * 读-&gt;读-&gt;写 * 获取 读锁 Thread-1 * 获取 读锁 Thread-2 * 关掉 读锁 Thread-1 * 关掉 读锁 Thread-2 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 */// System.out.println(\"读-&gt;读-&gt;写\");// rthread.start();// Thread.sleep(100);// rthread2.start();// Thread.sleep(100);// wthread.start(); /** * 写-&gt;写-&gt;读 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 * 获取 写锁 Thread-4 * 关掉 写锁 Thread-4 * 获取 读锁 Thread-1 * 关掉 读锁 Thread-1 */ System.out.println(\"写-&gt;写-&gt;读\"); wthread.start(); Thread.sleep(100); wthread2.start(); Thread.sleep(100); rthread.start(); Thread.sleep(5000); &#125; StampedLock 邮票锁, ReentrantReadWriteLock 的升级版写锁、读锁、新增(乐观读锁、锁的转换) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 邮票锁 * @throws InterruptedException */@Testpublic void stampedLock() throws InterruptedException &#123; StampedLock lock = new StampedLock(); int demo = 0; /** * 写锁 */ long stamp = lock.writeLock(); try &#123; demo = 1; &#125;finally &#123; lock.unlockWrite(stamp); &#125; /** * 读锁 */ stamp = lock.readLock(); try &#123; System.out.println(demo); &#125;finally &#123; lock.unlockRead(stamp); &#125; /** * 乐观读锁 * 一般情况读写并不冲突，但也可以通过检测申请乐观读锁后是否有写锁被申请，如果有可以再进行重新申请为读锁。 */ stamp = lock.tryOptimisticRead(); if (!lock.validate(stamp)) &#123; stamp = lock.readLock(); try &#123; System.out.println(demo); &#125; finally &#123; lock.unlockRead(stamp); &#125; &#125; else &#123; System.out.println(demo); &#125;&#125; Synchronized使用级别 实例对象函数this锁 静态函数class锁 代码块指定的锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class SynchronizedTest &#123; /** * 当线程1同步块正在执行，线程2处于阻塞状态(BLOCKED) * * @throws InterruptedException */ @Test public void state() throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; synchronized (SynchronizedTest.class) &#123; try &#123; // 不会让出锁 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread thread = new Thread(runnable); Thread thread2 = new Thread(runnable); thread.start(); thread2.start(); Thread.sleep(100); System.out.println(String.format(\"阻塞的线程2(%s) 状态: %s\", thread2.getName(), thread2.getState())); // 阻塞的线程2(Thread-2) 状态: BLOCKED &#125; /** * 多个同步块共用一把锁, 当线程1同步块1正在执行，线程2在同步块2处于阻塞状态(BLOCKED) */ @Test public void multiSync() throws InterruptedException &#123; class Demo &#123; private final Object LOCK = new Object(); public void sync1() throws InterruptedException &#123; synchronized (LOCK) &#123; Thread.sleep(1000); &#125; &#125; public void sync2() &#123; synchronized (LOCK) &#123; System.out.println(\"执行中..\"); &#125; &#125; &#125; Demo demo = new Demo(); Thread thread = new Thread(() -&gt; &#123; try &#123; demo.sync1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); Thread thread2 = new Thread(demo::sync2); thread.start(); thread2.start(); Thread.sleep(100); System.out.println(String.format(\"阻塞的线程2(%s) 状态: %s\", thread2.getName(), thread2.getState())); // 阻塞的线程2(Thread-2) 状态: BLOCKED &#125; /** * 死锁 * * @throws InterruptedException */ @Test public void deadlock() throws InterruptedException &#123; Object LOCK = new Object(); Object LOCK2 = new Object(); Thread thread = new Thread(() -&gt; &#123; synchronized (LOCK) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (LOCK2) &#123; ; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; synchronized (LOCK2) &#123; synchronized (LOCK) &#123; ; &#125; &#125; &#125;); thread.start(); thread2.start(); Thread.sleep(100); boolean b = thread.getState().equals(Thread.State.BLOCKED) &amp;&amp; thread2.getState().equals(Thread.State.BLOCKED); if (b) &#123; System.out.println(String.format(\"%s 和 %s 死锁\", thread.getName(), thread2.getName())); &#125; else &#123; System.out.println(\"未发生死锁\"); &#125; // Thread-1 和 Thread-2 死锁 &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://hocg.in/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"关于Java-Unsafe/LockSupport","slug":"关于Java-Unsafe:LockSupport","date":"2018-03-02T02:02:39.000Z","updated":"2018-07-03T05:29:39.417Z","comments":true,"path":"2018/03/02/关于Java-Unsafe:LockSupport/","link":"","permalink":"https://hocg.in/2018/03/02/关于Java-Unsafe:LockSupport/","excerpt":"关于Java Unsafe/LockSupport","text":"关于Java Unsafe/LockSupport Unsafe 一个高效底层函数，可以实现内存管理、对象实例化(不通过构造函数)、操作函数+类+变量(通过使用地址)、多线程同步(挂起锁、CAS)、挂起和恢复、数组、内存屏障。 具体实践代码 Unsafe 中在高并发和高性能的场景下具有显著的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package in.hocg.lock;import org.junit.jupiter.api.Test;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * Created by hocgin on 2018/3/2. * email: hocgin@gmail.com */public class UnsafeTest &#123; static class Demo &#123; private Integer integer; static &#123; System.out.println(\"static&#123;&#125;\"); &#125; &#123; System.out.println(\"&#123;&#125;\"); &#125; public Demo() &#123; integer = 0; System.out.println(\"Demo()\"); &#125; public Integer getInteger() &#123; System.out.println(\"getInteger()\"); return integer; &#125; public void setInteger(Integer integer) &#123; System.out.println(\"setInteger()\"); this.integer = integer; &#125; &#125; /** * 使用 Unsafe 创建对象，不会调用构造函数。 * * @throws NoSuchFieldException * @throws IllegalAccessException * @throws InstantiationException */ @Test public void instantiation() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Demo o = ((Demo) getUnsafe().allocateInstance(Demo.class)); System.out.println(String.format(\"hashCode:: %d\", o.hashCode())); // 此处会打印 \"static&#123;&#125;\" 因此仍然会执行静态代码块内容 &#125; /** * 使用 Unsafe 修改私有字段 */ @Test public void altering() throws NoSuchFieldException, IllegalAccessException &#123; Demo demo = new Demo(); Field field = demo.getClass().getDeclaredField(\"integer\"); Unsafe unsafe = getUnsafe(); unsafe.putObject(demo, unsafe.objectFieldOffset(field), 1); System.out.println(String.format(\"getInteger() = %d\", demo.getInteger())); &#125; /** * 使用 Unsafe 抛出异常 * * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void throwing() throws NoSuchFieldException, IllegalAccessException &#123; getUnsafe().throwException(new NullPointerException()); &#125; /** * 分配一块GC无法管理的内存区域 */ @Test public void memory() throws NoSuchFieldException, IllegalAccessException &#123; Unsafe unsafe = getUnsafe(); int size = 1024; // 分配内存地址 long address = unsafe.allocateMemory(size * 1); // 写入 unsafe.putInt(address + 4 * 1, 100); // 读取 int i = unsafe.getInt(address + 4 * 1); System.out.println(i); // 释放内存 unsafe.freeMemory(address); &#125; /** * 进行CAS操作，单纯使用 Java 并不能有效的解决CAS操作, 其主要通过 Unsafe 使用硬件级别来解决CAS操作 * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void cas() throws NoSuchFieldException, IllegalAccessException &#123; Unsafe unsafe = getUnsafe(); Demo demo = new Demo(); Field field = demo.getClass().getDeclaredField(\"integer\"); /** * compareAndSwapXXX * 参数 * 1. 指定对象 * 2. 字段的偏移地址 * 3. 当前值 * 4. 期望值 * 返回值 * \"认为的旧值\"==\"实际旧值\",修改成\"期望值\"再返回 True: 修改成功 * \"认为的旧值\"!=\"实际旧值\",直接返回 False: 修改失败 */ boolean state; // CAS 状态 Integer integer1 = 0; // 认为的旧值 Integer integer2 = demo.getInteger(); // 实际旧值 int o1 = 1; // 期望值 while (!(state = unsafe.compareAndSwapObject(demo, unsafe.objectFieldOffset(field), integer1, o1))) &#123; System.out.println(\"再次尝试修改\"); &#125; System.out.println(String.format(\"1 .CAS State: %b, 认为的旧值 %d, 实际旧值 %d, 期望值 %d\", state, integer1, integer2, o1)); integer2 = demo.getInteger(); // 实际旧值 state = unsafe.compareAndSwapObject(demo, unsafe.objectFieldOffset(field), integer1, o1); System.out.println(String.format(\"2 .CAS State: %b, 认为的旧值 %d, 实际旧值 %d, 期望值 %d\", state, integer1, integer2, o1)); &#125; /** * 利用OS底层的方式来实现挂起，相较于Object.wait()拥有更好的性能 * @throws NoSuchFieldException * @throws IllegalAccessException * @throws InterruptedException */ @Test public void park() throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123; Unsafe unsafe = getUnsafe(); Thread thread = new Thread(() -&gt; &#123; /** * 参数 * 1. isAbsolute, 是否为绝对时间。 * 2. time, 第一个参数(isAbsolute)为 True 时该参数应为纳秒, False 时该参数应为毫秒。0为无线等待，直到unpark。 */ unsafe.park(false, 0); // 挂起 -&gt; WAITING &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format(\"线程 %s 状态 %s\", thread.getName(), thread.getState())); Thread.sleep(100); unsafe.unpark(thread); Thread.sleep(100); System.out.println(String.format(\"线程 %s 状态 %s\", thread.getName(), thread.getState())); &#125; /** * Basic * Unsafe unsafe = Unsafe.getUnsafe(); * * @return * @throws IllegalAccessException * @throws NoSuchFieldException */ public static Unsafe getUnsafe() throws IllegalAccessException, NoSuchFieldException &#123; Field f = Unsafe.class.getDeclaredField(\"theUnsafe\"); f.setAccessible(true); return (Unsafe) f.get(null); &#125;&#125; LockSupport 其本质是Unsafe的薄封装。 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void park() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; /** * 进行挂起 * 本质使用 UNSAFE.park(false, 0L); */ LockSupport.park(); &#125;); thread.start(); Thread.sleep(1000); System.out.println(String.format(\"挂起线程状态 %s\", thread.getState())); // WAITING /** * 进行解除 * 本质使用 UNSAFE.unpark(thread) */ LockSupport.unpark(thread); Thread.sleep(100); System.out.println(String.format(\"解除挂起线程状态 %s\", thread.getState())); // TERMINATED&#125;@Testpublic void blocker() throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; /** * 线程内部有个 parkBlocker 字段, LockSupport 本质上使用 Unsafe 进行内存修改。 */ LockSupport.park(\"sdas\"); &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format(\"挂起 %s\", LockSupport.getBlocker(thread))); // 挂起 sdas LockSupport.unpark(thread); Thread.sleep(100); System.out.println(String.format(\"解除挂起 %s\", LockSupport.getBlocker(thread))); // 解除挂起 null &#125; 阻塞和解除阻塞 总结: 使用LockSupport更具有灵活性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static final Object LOCK = new Object();/** * notifyAll 实现 * @throws InterruptedException */@Testpublic void notifyAll2() throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; System.out.println(String.format(\"开始运行 %s\", Thread.currentThread().getName())); synchronized (LOCK) &#123; try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(String.format(\"解除锁 %s\", Thread.currentThread().getName())); &#125;; CompletableFuture.allOf(CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable)); Thread.sleep(1000); synchronized (LOCK) &#123; LOCK.notify(); System.out.println(\"通知完毕\"); &#125;&#125;/** * unpark 通知所有需自己实现 * @throws InterruptedException */@Testpublic void unparkAll() throws InterruptedException &#123; List&lt;Thread&gt; threads = Collections.synchronizedList(new ArrayList&lt;&gt;()); Runnable runnable = () -&gt; &#123; Thread thread = Thread.currentThread(); threads.add(thread); System.out.println(String.format(\"开始运行 %s\", thread.getName())); LockSupport.park(); System.out.println(String.format(\"解除锁 %s\", thread.getName())); &#125;; CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable)); Thread.sleep(1000); for (Thread thread : threads) &#123; LockSupport.unpark(thread); &#125; System.out.println(\"通知完毕\");&#125; park/unpark 与 wait/notify 总结相比于使用 Object.wait/Object.notify,LockSupport.unpark/LockSupport.park 更具有灵活性。 不局限于同步块内 灵活的 API(例如时间) 可指定唤醒(当多个进入wait时Object.notify是随机唤醒其中一个)。","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://hocg.in/tags/多线程/"},{"name":"锁","slug":"锁","permalink":"https://hocg.in/tags/锁/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"关于Java并发-线程","slug":"关于Java多线程-线程","date":"2018-02-26T17:13:39.000Z","updated":"2018-07-03T05:25:05.849Z","comments":true,"path":"2018/02/27/关于Java多线程-线程/","link":"","permalink":"https://hocg.in/2018/02/27/关于Java多线程-线程/","excerpt":"关于Java并发-线程","text":"关于Java并发-线程 并发和并行并行: 多核同时执行并发: 单核切换执行 线程线程状态Thread.State @since 1.5关于 Java Thread 状态不得不说的故事(网络上各种版本).. 线程的状态原文URL 多线程操作 关于wait和notify此处涉及到线程中的几个状态，请勿混淆。 使用wait/notify对线程进行操作使用wait/notify对线程进行操作 可能的误区 子线程被关闭，子线程所开启的子线程(子子线程)会不会被关闭？答案: 不会的, 子线程的子线程本质上和子线程是同一等级的并不会被其影响。 守护线程什么情况会被关闭？答案: 1. 守护线程执行完(自然关闭)。 2.所有用户线程的关闭(强行关闭) 什么是守护线程？答案: 当线程t.setDaemon(true)该线程即为守护线程。铛铛铛，最出名的守护线程GC。 用户线程 和 守护线程 的区别？答案: 守护线程[setDaemon(true)]和用户线程大体并没啥区别, 但是守护线程的生命周期是随着所有用户线程的关闭而退出的。 如何杀死一个Java线程？答案: Java已经不推荐使用stop进行线程的关闭了。如果线程是那种持久型操作类型的，建议开辟一个守护类型的线程进行回收(想法参照Go)。 1234567891011121314151617181920@Testpublic void interrupt() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; System.out.println(\"Do something\"); &#125; &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format(\"线程 %s 状态 %s\", thread.getName(), thread.getState())); /** * 线程 RUNNABLE 状态会标记为关闭，并不进行关闭。 * 线程 其他 状态会标记并进行关闭。 * - 已经不推荐使用 thread.stop(); 可能会引起资源问题。 */ thread.interrupt(); Thread.sleep(100); System.out.println(String.format(\"线程 %s 状态 %s\", thread.getName(), thread.getState()));&#125; 线程池前置 Runable 无返回值 Callable 有返回值 Future 返回结果 newCachedThreadPool() 创建一个可缓存的线程池，其指定线程池中线程的存活时间，默认为 60s。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 这边源码有注释:当你想实现一些缓存相关的细节(如超时时间)，应该自己使用ThreadPoolExecutor的构造函数来创建。 newSingleThreadExecutor 创建一个新的单线程Executor，其指定线程池中线程最大数量为1。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 此处为何使用门面模式呢？注释写明只暴露ExecutorService接口的方法, 应该是为了防止强制使用ThreadPoolExecutor相关函数。 相比于newFixedThreadPool(1), 该函数保证不会被重新分配到其他的线程。 newFixedThreadPool 创建一个固定大小的线程池12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 注释中说明: 提交的任务线程将一直存在，直到使用 ExecutorService#shutdown 进行退出 newScheduledThreadPool 创建一个固定大小且可定时的线程池 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; newSingleThreadScheduledExecutor 创建一个大小为1且可定时的线程池 1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125; 同样使用了门面模式 newWorkStealingPool 并行 创建一个并行线程池(并行数目默认为:系统可用线程数目)@since 1.8 123456public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; Fork/Join 并行 使用并行进行操作@since 1.7 相关类/接口说明 ForkJoinTask 顶层接口, 其实现了Future。 RecursiveTask 有返回值 RecursiveAction 无返回值 ForkJoinPool 类似Executor 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Main.java* 响应结果:* TASK:ForkJoinPool.commonPool-worker-1* TASK:ForkJoinPool.commonPool-worker-1* TASK:ForkJoinPool.commonPool-worker-2* TASK:ForkJoinPool.commonPool-worker-1* 有效值 4* TASK:ForkJoinPool.commonPool-worker-2* 有效值 5* TASK:ForkJoinPool.commonPool-worker-1* 有效值 6* TASK:ForkJoinPool.commonPool-worker-1* 有效值 7* 22**/ @Test public void forkJoinPool() throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = ForkJoinPool.commonPool(); IRecursiveTask iRecursiveTask = new IRecursiveTask(); ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(iRecursiveTask); System.out.println(task.get()); &#125;/*** IRecursiveTask.java* .fork() 进行任务分裂，并使用线程进行执行* .join() 等待执行完成并获取结果**/public class IRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; public static AtomicInteger FLAG = new AtomicInteger(0); @Override protected Integer compute() &#123; System.out.println(\"TASK:\" + Thread.currentThread().getName()); FLAG.addAndGet(1); if (FLAG.get() &gt; 3) &#123; System.out.println(String.format(\"有效值 %d\", FLAG.get())); return FLAG.get(); &#125; // 为什么不用 this.fork()？ // this.fork() 返回的是 this Integer join1 = new IRecursiveTask().fork().join(); Integer join2 = new IRecursiveTask().fork().join(); return join1 + join2; &#125;&#125; CompletableFuture/CompletionStage 异步+并行 相比于1.7进行了更简便、友好的封装，并增加了异步通知的功能，摆脱了阻塞问题。@since 1.8 CompletableFuture CompletableFuture实现了CompletionStage用于进行异步并行,并提供函数让多个CompletionStage可以进行组合操作和或操作。 静态函数, 返回CompletionStage CompletableFuture.anyOf 任意一个执行完成 CompletableFuture.allOf 所有执行完成 CompletableFuture.supplyAsync 执行单个异步,有返回值(默认使用:ForkJoinPool#commonPool())。 CompletableFuture.runAsync 执行单个异步,无返回值 CompletableFuture.completedFuture 设定结果 CompletionStage 函数 thenXXX 流的流向(等待上一步执行完成) thenApplyXXX 进行输入的转换(Apply：有输入有输出) thenRunXXX 对上一个结果不关心，也没有返回值(Run：无输入无输出) thenAcceptXXX 进行输入对处理(Accept：有输入无输出) thenAcceptBothXXX(CompletionStage,BiConsumer) 加入CompletionStage, 进行指定处理(组合操作，有输入无输出)。 thenCombineXXX(CompletionStage,BiFunction) 加入CompletionStage, 进行指定处理(组合操作，有输入有输出)。 runAfterXXX 运行之后 runAfterBothXXX(CompletionStage, Runnable) 加入CompletionStage, 并在其运行后指定执行(组合操作，无输入无输出)。 runAfterEither(CompletionStage, Runnable) (或操作) 完成 whenCompleteXXX 完成之后处理。(有输入无输出) handleXXX 完成之后处理。(有输入有输出) 异常处理 exceptionally 异常处理。 其他 .complete() // 立即结束并返回指定的结果 .completeExceptionally() //立即异常结束 说明: xxxEither 加入CompletionStage进行OR操作(与之前的进行对比),取最先返回的结果取其结果值。 xxxAsync 都是异步执行 稍微提一下,线程组 为管理 Thread 而存在的，可以进行批量标记、检查。","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://hocg.in/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"日志系统ELK在Spring Boot上的初步集成","slug":"日志系统 ELK 在 Spring Boot 上的初步集成","date":"2018-01-22T08:53:00.000Z","updated":"2018-05-05T16:16:43.478Z","comments":true,"path":"2018/01/22/日志系统 ELK 在 Spring Boot 上的初步集成/","link":"","permalink":"https://hocg.in/2018/01/22/日志系统 ELK 在 Spring Boot 上的初步集成/","excerpt":"日志系统 ELK 在 Spring Boot 上的初步集成 😋","text":"日志系统 ELK 在 Spring Boot 上的初步集成 😋 ELK Elasticsearch + Logstash + Kibana，一个比较流行的日志系统。当然，你也可以尝试使用阿里云。如果钱多的话:) Logstash 日志搬运, 可以指定从 Redis/Log4j..处获取日志信息，然后进行过滤，再提交给 Elasticsearch 进行分析。 1234# 安装 &amp; 启动brew install logstash# brew services restart logstash# ./bin/logstash -f config/logstash.conf Elasticsearch 日志存储 / 查询 / 分析 123# 安装 &amp; 启动brew install elasticsearchbrew services restart elasticsearch 如果你想直接查看、操作或者研究 elasticsearch 存储的内容，可以考虑使用 elasticsearch-head 进行操作。 UI 操作界面12345git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run startopen http://localhost:9100 如果 Elasticsearch 安装了 X-Path 那么需要在配置文件中(elasticsearch.yml), 加入:123http.cors.enabled: true http.cors.allow-origin: '*' http.cors.allow-headers: \"Authorization\" 对了, 这里有一款elasticsearch-head Chrome Plug-in 推荐。 Kibana UI 界面 1234wget https://www.elastic.co/downloads/kibanatar -xvf kibana.tar.gz./kibana/bin/kibanaopen http://localhost:5601/ Spring Boot 集成 pom.xml 引入 logback 支持。 12345&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt;&lt;/dependency&gt; 在 resources/ 文件夹内创建 logback-spring.xml 文件。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;appender name=\"LOGSTASH\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\"&gt; &lt;destination&gt;dev.local:4560&lt;/destination&gt; &lt;encoder charset=\"UTF-8\" class=\"net.logstash.logback.encoder.LogstashEncoder\"/&gt; &lt;/appender&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\"/&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"LOGSTASH\"/&gt; &lt;appender-ref ref=\"CONSOLE\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 配置 logstash, 创建 logstash.conf。 123456789101112131415input &#123; tcp &#123; port =&gt; 4560 codec =&gt; json_lines &#125;&#125;output &#123; elasticsearch &#123; action =&gt; &quot;index&quot; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;applog&quot; ; user =&gt; &quot;elastic&quot; ; password =&gt; &quot;changeme&quot; &#125;&#125; 启动logstash ./bin/logstash -f logstash.conf 使用。12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class TestControllerTest &#123; Random random = new Random(); @Test public void testList() throws Exception &#123; while (true) &#123; Thread.sleep(1000); log.info(\"Hello world form hocgin\"); if (random.nextBoolean()) &#123; log.info(\"sksdjkf \" + random.nextInt(1000)); &#125; &#125; &#125;&#125; 关于 Kibana 安全配置 Configuring Security in Kibana 安装 x-pack. 123456logstash-plugin install x-packelasticsearch-plugin install x-packkibana-plugin install x-pack 修改 config/kibana.yml 12elasticsearch.username: &quot;elastic&quot; elasticsearch.password: &quot;changeme&quot; 修改 logstash.conf。 123456789101112131415input &#123; tcp &#123; port =&gt; 4560 codec =&gt; json_lines &#125;&#125;output &#123; elasticsearch &#123; action =&gt; &quot;index&quot; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;applog&quot; user =&gt; &quot;elastic&quot; password =&gt; &quot;changeme&quot; &#125;&#125; 如果忘记 ElasticSearch 密码 停止 ElasticSearch 服务 创建一个管理员用户 1x-pack/users useradd my_admin -p my_password -r superuser 启动 ElasticSearch 服务 使用 API 修改密码1234567891011121314curl -u my_admin -XPUT 'http://localhost:9200/_xpack/security/user/elastic/_password?pretty' -H 'Content-Type: application/json' -d'&#123; \"password\" : \"new_password\"&#125;'``## ELK Docker- [ELK Docker](https://github.com/spujadas/elk-docker)简而言之:```shell# :5601 - Kibana# :9200 - Elasticsearch# :5044 - Logstashsudo docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk","categories":[{"name":"服务端","slug":"服务端","permalink":"https://hocg.in/categories/服务端/"}],"tags":[{"name":"ELK","slug":"ELK","permalink":"https://hocg.in/tags/ELK/"}],"keywords":[{"name":"服务端","slug":"服务端","permalink":"https://hocg.in/categories/服务端/"}]},{"title":"Spring Boot启动过程和Bean的创建过程","slug":"Spring Boot 启动过程和 Bean 的创建过程","date":"2018-01-15T09:10:20.000Z","updated":"2018-05-05T17:58:24.257Z","comments":true,"path":"2018/01/15/Spring Boot 启动过程和 Bean 的创建过程/","link":"","permalink":"https://hocg.in/2018/01/15/Spring Boot 启动过程和 Bean 的创建过程/","excerpt":"这几天分析了一下 Spring Boot 启动过程和 Bean 的创建过程，在此记录下来。如果有什么不对的地方，欢迎提出🙏。","text":"这几天分析了一下 Spring Boot 启动过程和 Bean 的创建过程，在此记录下来。如果有什么不对的地方，欢迎提出🙏。 启动过程123456789101112131415161718192021222324252627282930// 将 new SpringApplicationBuilder(sources...) 加入 sources 列表。// ---------------推断是否是Web环境------------// SpringApplication.deduceMainApplicationClass#248// 主要是否包含 javax.servlet.Servlet ..// ---------------Initializer------------// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// - spring-boot-actuator-1.5.8.RELEASE.jar// - spring-data-redis-1.8.8.RELEASE.jar// - ..// 获得 Key 为`org.springframework.context.ApplicationContextInitializer`的所有节点(Class), 实例化并通过 @Order 进行排序。// ---------------Listener------------// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// - spring-boot-actuator-1.5.8.RELEASE.jar// - spring-data-redis-1.8.8.RELEASE.jar// - ..// 获得 Key 为`org.springframework.context.ApplicationListener`的所有节点(Class), 实例化并通过 @Order 进行排序。// ---------------推断Main类------------// SpringApplication.deduceMainApplicationClass#252// 推断当前应用的入口函数(方法名为main)。 new SpringApplicationBuilder() .sources(Application.class) // -------判断是否热部署状态--------- // ---如果设置了 parent() 进行配置----- // configureAsChildIfNecessary(args);如果配置了会加入一个 ParentContextApplicationContextInitializer // ---------初始化当前应用---------- // SpringApplication.run(args) .run(args); 分析 SpringApplication.run(args)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 计时器, 用于记录启动时间StopWatch stopWatch = new StopWatch();stopWatch.start();ConfigurableApplicationContext context = null;FailureAnalyzers analyzers = null;// 设置为无输入/输出设备模式configureHeadlessProperty();// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// 获得 Key 为`org.springframework.boot.SpringApplicationRunListener`的所有节点(Class), 实例化并通过 @Order 进行排序。// 并封装进入 SpringApplicationRunListeners 类。SpringApplicationRunListeners listeners = getRunListeners(args);// 由 SpringApplicationRunListeners 控制类的启动。listeners.starting();try &#123; // 封装我们提供的 args 参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 根据是否 Web 环境(webEnvironment) 获得环境(StandardServletEnvironment/StandardEnvironment) // - 加载默认的参数源(StandardServletEnvironment.customizePropertySources) // - 加载我们提供的启动参数(args)作为参数源。当然，前提是 addCommandLineProperties 为 true。 // 通过 SpringApplicationRunListeners.environmentPrepared(..) 处理上面提供的应用环境参数。 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 打印 banner。本身是由 Banner 类实现的 Banner printedBanner = printBanner(environment); // 实例化一个应用的当前环境, Spring Boot 提供了2种环境根据是否是web环境进行动态实例化(webEnvironment), 分别是(AnnotationConfigEmbeddedWebApplicationContext/ConfigurableWebApplicationContext) // 这是会创建两个用于扫描注解的重要对象 // - AnnotatedBeanDefinitionReader 读取器, 设置环境参数，创建时注册了一系列的用于 Bean 的解析器(AnnotatedBeanDefinitionReader#65) // - ClassPathBeanDefinitionScanner 扫描器, 设置路径 &amp; 环境 &amp; 拦截器(Component.class) context = createApplicationContext(); // ----------创建失败解析器------------ // 当初始化出现错误时进行错误分析器 // 使用 ClassLoader // 分析引入所有包的: META-INF/spring.factories 文件 // - spring-boot-actuator-1.5.8.RELEASE.jar // - spring-data-redis-1.8.8.RELEASE.jar // - .. // 获得 Key 为`org.springframework.boot.diagnostics.FailureAnalyzer`的所有节点(Class), 实例化并通过 @Order 进行排序。 // 并加入 FailureAnalyzers 管理。 analyzers = new FailureAnalyzers(context); // 详情见下方【SpringApplication.prepareContext(..)】 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 详情见下方【分析 AbstractApplicationContext.refreshContext(context);】 refreshContext(context); // ApplicationRunner &amp; CommandLineRunner.run 按类型从 Bean 容器中取出，并调用 run(..) afterRefresh(context, applicationArguments); // 广播通知 SpringApplicationRunListener.finished listeners.finished(context, null); // 关闭计时器，记录启动时间 stopWatch.stop(); // 是否启动日志 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context;&#125; catch (Throwable ex) &#123; // 处理退出异常, 存储 ExitCodeEvent // 广播通知 listener(listener.finished(context, exception);) // 使用 analyzers 进行失败分析 handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex);&#125; 分析 SpringApplication.prepareContext(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 设置环境参数 context.setEnvironment(environment); // // - 注册自定义 beanNameGenerator，如果有的话。 // - 注册自定义 resourceLoader，如果有的话。 // 其中, resourceLoader 分为两种类型 // - GenericApplicationContext(ResourceLoader) // - DefaultResourceLoader(ClassLoader) postProcessApplicationContext(context); // 初始化所有之前加载的 ApplicationContextInitializer 节点 applyInitializers(context); // 所有监听器通知进入 contextPrepared 阶段 listeners.contextPrepared(context); // 是否启动日志 if (this.logStartupInfo) &#123; // 交由顶级打印日志信息 logStartupInfo(context.getParent() == null); // 打印配置文件信息 logStartupProfileInfo(context); &#125; // Add boot specific singleton beans context.getBeanFactory().registerSingleton(\"springApplicationArguments\", applicationArguments); if (printedBanner != null) &#123; context.getBeanFactory().registerSingleton(\"springBootBanner\", printedBanner); &#125; // Load the sources Set&lt;Object&gt; sources = getSources(); Assert.notEmpty(sources, \"Sources must not be empty\"); // 创建 Bean 的加载器, BeanDefinitionLoader // ---------------解析器--------------- // - 注解 AnnotatedBeanDefinitionReader // - xml XmlBeanDefinitionReader // - goovy GroovyBeanDefinitionReader // - 类路径 ClassPathBeanDefinitionScanner // ---------------自定义----------------- // - 加载自定义 beanNameGenerator，如果有的话。 // - 加载自定义 resourceLoader，如果有的话。 // - 加载自定义 environment，如果有的话。 load(context, sources.toArray(new Object[sources.size()])); // 通知环境加载结束 listeners.contextLoaded(context);&#125; 分析 AbstractApplicationContext.refreshContext(context);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 设置为启动状态 // 校验必须字段, 使用 ConfigurablePropertyResolver#setRequiredProperties 进行设置。 // Prepare this context for refreshing. prepareRefresh(); // 刷新当前 beanFactory 的ID, 值得一提的是默认的 BeanFactory 是 org.springframework.beans.factory.support.DefaultListableBeanFactory。 // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // ----------BeanFactory重点初始化(AbstractApplicationContext.prepareBeanFactory#627)--------------- // - 设置 BeanClassLoader // - 设置 字符解析器(SpelExpressionParser) // - 设置 资源位置 // - 添加 处理器 // - 忽略 某些接口 // - 注册某些解析器解决依赖关系 // - 添加一个监听器 // - 注册 默认的 environment Bean(3个), 如果不存在的话。 // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // AnnotationConfigEmbeddedWebApplicationContext.postProcessBeanFactory#182 // - 加入 WebApplicationContextServletContextAwareProcessor 作为 BeanPostProcessor // - beanFactory.ignoreDependencyInterface(ServletContextAware.class); // 也会读取注册的注解类 和 配置要扫描的包位置。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry) // 通过 ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry#308 扫描所有应用文件。 // - 扫描预制的配置文件 // - 扫描应用的所有注解配置成 Bean 字典 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // 使用 BeanPostProcessor.class 获取 Bean(所有 Bean 均在beanDefinitionMap 内含有), 排序后, 注册为 Bean 处理器。 // 加入 BeanPostProcessorChecker.class 用于监听Bean的创建周期。 // - priorityOrderedPostProcessors // - orderedPostProcessors // - nonOrderedPostProcessors // - internalPostProcessors // 加入 ApplicationListenerDetector 作为兜底 BeanPostProcessor // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 初始化消息资源(MessageSource) // 一般是作为 i18 的资源文件。 // Initialize message source for this context. initMessageSource(); // 初始化应用广播器(ApplicationEventMulticaster) // 一般用于管理 ApplicationListener // Initialize event multicaster for this context. initApplicationEventMulticaster(); // EmbeddedWebApplicationContext.onRefresh#131 // 创建嵌入式 Servlet 容器 // Initialize other special beans in specific context subclasses. onRefresh(); // 注册 listener beans 到 ApplicationEventMulticaster。 // 广播 (Set&lt;ApplicationEvent&gt; earlyEventsToProcess).multicastEvent // Check for listener beans and register them. registerListeners(); // - 转化 BeanFactory 类型 // - 提供默认的嵌入值解析器，如果需要的话。 // - 装载 LoadTimeWeaverAware.class 类型的 Bean // - 停止临时的 ClassLoad // - 冻结配置 // - 预先装载所有单例 Bean。 // - 初始化@Controller @RequestMapping 之类的过程, 基本上我们使用的注解都是该阶段进行设置的。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // ----------发布事件通知---------------- // 注册 LifecycleProcessor，并发布 onRefresh() 事件。 // earlyApplicationEvents.add(new ContextRefreshedEvent(this)) 加入 Context 刷新事件 // 注册 LiveBean，如果有的话。..DevTool Debug 那个 // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 关于 Bean BeanDefinitionRegistry, Bean 定义注册表，类似 Bean 的仓库。 BeanDefinition 存储 Bean 的信息。 Bean 的 scope 种类, prototype, 每次获取时创建。 request, session, global session, singleton(默认), 单例。 BeanFactory, Bean 工厂。 用于 注册 Bean, 获得 Bean, 清除 Bean, 配置 Bean 的相关策略。 DefaultListableBeanFactory 是 Spring 默认的 BeanFactory。 registeredSingletons 已注册的 Bean 列表, 存储 BeanName。 singletonObjects 存储 Bean 对象, 使用 Map 结构。 earlySingletonObjects 存储由 ObjectFactory 创建的 Bean 对象。 singletonFactories 存储之前创建的 ObjectFactory 其本质是 Bean 对象。 beanDefinitionMap 扫描存储的记录，可以理解为 Bean 的总名单。 mergedBeanDefinitions 获取 Bean getBean(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// AbstractBeanFactory.class @Override public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false); &#125; @SuppressWarnings(\"unchecked\") protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 解析 BeanName final String beanName = transformedBeanName(name); Object bean; // 检查缓存中是否存在该 Bean, 如果存在则实例化。 // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Bean 不在缓存 // 当正在创建的 Bean 的 Scope 为 Prototype 时，抛出异常。 // 因为 Prototype 模式无法解决依赖问题。 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // 如果当前 BeanFactory 不包括该 BeanName 并且该 BeanFactory 有父 BeanFactory 时，尝试从父 BeanFactory 获取该 Bean。 // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; // 如果不只依靠类型进行获取, 进行标记。 if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; // 将解析转化为 Bean 的信息，注册并获取其依赖的 Bean。 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // 当 Bean 的 Scope 为 Singleton 时 // Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 当 Bean 的 Scope 为 Prototype 时 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 当 Bean 的 Scope 为 其他 时 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 检查获得的 Bean 类型是否符合预期结果。 // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean; &#125; 创建 Bean createBean(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// AbstractAutowireCapableBeanFactory.class @Override protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // 根据信息(mbd, beanName)获取 Bean 的类型 // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // 校验重载函数 // Prepare method overrides. try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // Spring 提供的，由 BeanPostProcessor 进行处理接入点。 // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; // 默认的创建 Bean 方式 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance; &#125;// AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // 根据 Bean 信息实例化 Bean // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 使用 MergedBeanDefinitionPostProcessor 进行处理 // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 单例 &amp; 允许循环引用 &amp; 正在创建 if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; // 使用 ObjectFactory 来管理 Bean 防止循环依赖。 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 对 Bean 的属性进行填充 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; // 初始化 Bean 实例 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); // 存在已创建的单例, 一般情况为解决依赖的时候。 if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; // 允许循环依赖不一致 &amp; Bean 含有依赖。 // 此时如果存在依赖，将会发生异常。 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // 注册一次性 Bean // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject; &#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://hocg.in/tags/Spring-Boot/"},{"name":"Web","slug":"Web","permalink":"https://hocg.in/tags/Web/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}]},{"title":"使用 Docker 交叉编译 OpenWrt 上运行的 Golang 程序","slug":"使用 Docker 交叉编译 OpenWrt 上运行的 Golang 程序","date":"2017-11-23T02:17:02.000Z","updated":"2018-01-09T00:33:32.850Z","comments":true,"path":"2017/11/23/使用 Docker 交叉编译 OpenWrt 上运行的 Golang 程序/","link":"","permalink":"https://hocg.in/2017/11/23/使用 Docker 交叉编译 OpenWrt 上运行的 Golang 程序/","excerpt":">.&lt;","text":">.&lt; 前言 使用 https://github.com/gomini/go-mips32 对 Go 程序进行交叉编译. 使用 Docker 交叉编译 Go 程序 拉取镜像 1docker pull conoro/go-mips32:v1 启动镜像并挂载本地目录 123456docker run -it -v 程序目录:/go/src conoro/go-mips32:v1 /bin/shcd src# 编译# export GOOS=linux# export GOARCH=mips32lego build main.go","categories":[{"name":"Docker","slug":"Docker","permalink":"https://hocg.in/categories/Docker/"}],"tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/tags/OpenWrt/"},{"name":"Docker","slug":"Docker","permalink":"https://hocg.in/tags/Docker/"},{"name":"Go","slug":"Go","permalink":"https://hocg.in/tags/Go/"}],"keywords":[{"name":"Docker","slug":"Docker","permalink":"https://hocg.in/categories/Docker/"}]},{"title":"自编译 OpenWrt 系统","slug":"自编译 OpenWrt 系统","date":"2017-11-22T02:18:02.000Z","updated":"2018-01-04T10:30:58.409Z","comments":true,"path":"2017/11/22/自编译 OpenWrt 系统/","link":"","permalink":"https://hocg.in/2017/11/22/自编译 OpenWrt 系统/","excerpt":"😌 整理、记录一下步骤..","text":"😌 整理、记录一下步骤.. 前置更改源123sed -i.bak 's/\\/us.archive.ubuntu.com\\//\\/cn.archive.ubuntu.com\\//g' /etc/apt/sources.listsudo apt update 关闭IPv6echo 1 &gt; /proc/sys/net/ipv6/conf//disable_ipv6 前置安装 git subversion make automake autoconf gcc g++ binutils make, 缺省安装 libncurses5-dev libssl-dev gawk 前置 GitHub(git clone https://github.com/openwrt/openwrt) 获取 OpenWrt, 更改 openWrt 目录为当前用户所有权12# 例如:chown -R hocgin:hocgin openwrt 编译(openwrt/)编译过程 make ./script/feeds update -a ./script/feeds install -a 14. make deconfig # 使用默认的配置 15. make menuconfig # 基于终端的一种配置方式，提供了文本模式的图形用户界面，用户可以通过光标移动来浏览所支持的各种特性。 固件配置, 可以选择编译的软件包 ## 部分选项 - 架构(AR7xxx) - FLASH(Generic) - 路由器型号(WNDR3800) - 文件系统(squashfs) - 通用设置 - [-] Crytographically signed package lists - [-] Compile with support for patented functionallty - [-] Enable shadow password support - [-] Crash logging - [-] Compile the kernel with debug information - [-] Compile the kernel SysRq support - [-] Enable process core dump support - [-] Enable printk timestamps - [-] Enable Ipv6 support in packages - [-] Compile certain packages parallelized - [-] Enable gcc format-security - [-] Build the OpenWrt Image Builder - [-] In - [-] Build the OpenWrt SDK - [-] Package the OpenWrt-based Toolchain 其余默认。 make kernel_config 内核配置[开启浮点数模拟(FPU)] make V=s -j&lt;处理器数量&gt; 编译完成后，移出bin/ar71xx/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64.tar.bz2 文件, 并解压(tar xvf). 进入(OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64/) 编译成镜像 12345# 检查基础镜像parallels@ubuntu:~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64$ make image PROFILE=WNDR3700# 包含必备包`预装软件`的镜像parallels@ubuntu:~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64$ make image PROFILE=WNDR3700 PACKAGES=\"-dnsmasq dnsmasq-full ipset openssh-keygen openssh-server openssh-sftp-server kmod-fs-ext4 kmod-fs-ntfs kmod-fs-vfat kmod-usb2 kmod-usb-core kmod-usb-storage kmod-usb-storage-extras luci-app-firewall luci-app-samba luci-app-upnp luci luci-theme-material curl kmod-ipt-nat-extra libpcre\" 生成镜像(~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64/bin/) openwrt-ar71xx-generic-wndr3800-squashfs-sysupgrade.bin openwrt-ar71xx-generic-wndr3800-squashfs-factory.img","categories":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}],"tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/tags/OpenWrt/"}],"keywords":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}]},{"title":"制作.ipk安装文件","slug":"制作.ipk","date":"2017-11-19T04:30:21.000Z","updated":"2018-01-09T00:35:43.000Z","comments":true,"path":"2017/11/19/制作.ipk/","link":"","permalink":"https://hocg.in/2017/11/19/制作.ipk/","excerpt":".ipk 本质是tar.gz格式的压缩包, 按照某种规范格式(类似.deb包)进行 …","text":".ipk 本质是tar.gz格式的压缩包, 按照某种规范格式(类似.deb包)进行 … 前言 .ipk 本质是tar.gz格式的压缩包, 按照某种规范格式(类似.deb包)进行压缩而成的。 当我们对它的内容进行操作时候所使用的用户即是它安装后所拥有的用户和权限(sudo chown root:root -R .)。 已经存在的文件并不能进行替换, 切记。 文件介绍1234.├── control.tar.gz # 安装/卸载 脚本├── data.tar.gz # 二进制/配置文件..└── debian-binary # 固有文件 control.tar.gz 内容1234.├── control # 文件介绍[包括: 依赖/版本/架构/作者..]├── postinst # 安装脚本└── postrm # 卸载脚本 control 此处举个栗子1234567Package: IPKName # .ipk NAMEVersion: 1Section: netPriority: optionalArchitecture: ar71xx # 系统架构Maintainer: hocgin &lt;hocgin@gmail.com&gt;Description: my first ipk postinst 安装脚本 因为前言的3原因, 当我们需要对已存在文件进行修改时, 只能使用写入的方式进行修改。 例如:12#!/bin/shecho \"installed done\" &gt; /tmp/ipk.log postinst 卸载脚本 自己约的X🤣。。 例如:12#!/bin/shrm -rf /tmp/ipk.log 打包~1sudo tar -czf control.tar.gz * data.tar.gz 此处完全是根据你要增加的脚本按根目录进行存放的。 例如:1234567891011121314151617181920.├── bin│ ├── ss-redir│ └── ss-tunnel├── data.tar.gz├── etc│ ├── dnsmasq.d│ │ ├── address.conf│ │ ├── dns.conf│ │ ├── ipset.conf│ │ ├── option.conf│ │ └── server.conf│ ├── pdnsd.conf│ └── shadowsock.json├── root│ ├── addDnsmasq.sh│ └── changeService.sh└── usr └── sbin └── pdnsd 打包~1sudo tar -czf data.tar.gz * 最后 将三个文件放在一起进行打包 1sudo tar -czf mIPK.ipk *","categories":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/tags/OpenWrt/"},{"name":"Shell","slug":"Shell","permalink":"https://hocg.in/tags/Shell/"}],"keywords":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}]},{"title":"IDEA 中的 Spring Boot 开发模式","slug":"IDEA-中的-Spring-Boot-开发模式","date":"2017-10-20T15:28:09.000Z","updated":"2018-05-05T18:00:01.324Z","comments":true,"path":"2017/10/20/IDEA-中的-Spring-Boot-开发模式/","link":"","permalink":"https://hocg.in/2017/10/20/IDEA-中的-Spring-Boot-开发模式/","excerpt":"🤑 完全热部署, 配置完成瞬间舒爽无比。","text":"🤑 完全热部署, 配置完成瞬间舒爽无比。 .java 文件和配置文件更改后进行自动重启 更改IDEA中的如下设置Build project automatically。 打开IDEA的Action window, 快捷键如下: Linux : CTRL+SHIFT+A Mac OSX : SHIFT+COMMAND+A Windows : CTRL+ALT+SHIFT+/输入(选择) Registry..., 选择如下: 此时进行.java 文件和配置文件修改时, 会进行 Spring Boot 重启。 当更改静态HTML进行实时刷新 加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 安装浏览器插件 Chrome 插件 Firefox 插件 Safari 插件 更改文件和静态页面(HTML)都可以进行热部署类。 实时刷新thymeleaf模版文件配置文件设置取消缓存: 123spring: thymeleaf: cache: false Chrome 设置取消缓存: 此时几乎所有的东西(.java/`/SpringBoot 配置文件`)都可以进行热部署了。包括: 修改 .java 文件。 修改页面(thymeleaf html ..) 文件。 修改 SpringBoot 配置文件。 增删静态文件(css js 图片)。 关于定制化热部署 可查询spring-boot-devtools的使用, 使用以下子项进行配置。 12spring: devtools: IDEA 扩展 pom.xml 添加以下依赖可查看更多的信息。该依赖是可查看监控信息的, 更多使用移步 Google.com。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; IDEA 显示如下:","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://hocg.in/tags/SpringBoot/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"JQuery.pjax 无法再次初始化当前页面的JS","slug":"JQuery.pjax无法再次初始化当前页面的JS","date":"2017-10-19T14:07:20.000Z","updated":"2017-10-22T04:16:22.962Z","comments":true,"path":"2017/10/19/JQuery.pjax无法再次初始化当前页面的JS/","link":"","permalink":"https://hocg.in/2017/10/19/JQuery.pjax无法再次初始化当前页面的JS/","excerpt":"Pjax 很久之前用过一次, 这一次在整合后台模版，发现网上对这个坑竟然是改源码…在这详细记录一下。","text":"Pjax 很久之前用过一次, 这一次在整合后台模版，发现网上对这个坑竟然是改源码…在这详细记录一下。 问题当 JQuery.pjax 加载页面后, 再次加载该页面时，其内部的初始化 JS 或 script inline 并不能被再次执行。例如:123456789101112131415161718192021222324252627&lt;div id=\"pjax-container\"&gt; &lt;!-- .. --&gt;&lt;/div&gt;&lt;!-- jQuery 3 --&gt;&lt;script th:src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jQuery Pjax --&gt;&lt;script th:src=\"jquery.pjax.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; if ($.support.pjax) &#123; $(document).pjax('a[data-pjax]', '#pjax-container', &#123; maxCacheLength: 0, push: false, replace: true, fragment: '#pjax-container', timeout: 8000 &#125;); &#125; &#125;);&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; console.log(\"不能被再次执行\"); &#125;);&lt;/script&gt;&lt;!-- 不能被再次执行 --&gt;&lt;script type=\"text/javascript\" src=\"init.js\"&gt;&lt;/script&gt; 解决办法 其原因是JQuery.pjax对js进行了缓存, 可以使用JQuery进行加载, 当然其代价是牺牲了这部分都缓存, 不过因为是特定页面的脚本, 牺牲的缓存几乎可以忽略。例子如下:123456789101112131415161718192021222324252627282930&lt;div id=\"pjax-container\"&gt; &lt;!-- .. --&gt; &lt;!-- 能被再次执行 --&gt; &lt;script th:inline=\"javascript\"&gt; $.getScript('/admin-lte/dist/js/pages/dashboard2.js'); &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"init.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(function()&#123; console.log(\"能被再次执行\"); &#125;); &lt;/script&gt;&lt;/div&gt;&lt;!-- jQuery 3 --&gt;&lt;script th:src=\"jquery.min.js\"&gt;&lt;/script&gt;&lt;!-- jQuery Pjax --&gt;&lt;script th:src=\"jquery.pjax.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function () &#123; if ($.support.pjax) &#123; $(document).pjax('a[data-pjax]', '#pjax-container', &#123; maxCacheLength: 0, push: false, replace: true, fragment: '#pjax-container', timeout: 8000 &#125;); &#125; &#125;);&lt;/script&gt;","categories":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hocg.in/tags/JavaScript/"},{"name":"Pjax","slug":"Pjax","permalink":"https://hocg.in/tags/Pjax/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}]},{"title":"Thymeleaf 3.0 手册","slug":"Thymeleaf-3.0-手册","date":"2017-10-18T08:40:51.000Z","updated":"2018-01-04T08:26:38.907Z","comments":true,"path":"2017/10/18/Thymeleaf-3.0-手册/","link":"","permalink":"https://hocg.in/2017/10/18/Thymeleaf-3.0-手册/","excerpt":"Spring 官方推崇的模版引擎，遵循 HTML5规范。","text":"Spring 官方推崇的模版引擎，遵循 HTML5规范。 HTML5若要完全遵循HTML5规范，可使用 data-th-* 代替 th:*。 标签th:each foreach 循环语法: th:each=”obj, index:list”12345678&lt;th:block th:each=\"permission, i:$&#123;role.permissions&#125;\"&gt; &lt;tr th:attr=\"data-tt-id=$&#123;permission.id&#125;, data-tt-parent-id=$&#123;permission.parent&#125;, data-tt-branch=$&#123;permission.hasChildren&#125;\"&gt; &lt;td th:text=\"$&#123;permission.name&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;permission.url&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;permission.type&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;permission.permission&#125;\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/th:block&gt; th:inline 解析内嵌语法, 一般是混合javascript语法: th:inline=”javascript|text|none”123456&lt;script th:inline=\"javascript\"&gt;/*&lt;![CDATA[*/var welcome = [[$&#123;welcome&#125;]] '这是一个 Thymeleaf 变量';var default_value = [[$&#123;maxCount?:0&#125;]]/*]]&gt;*/&lt;/script&gt; th:fragment 定义模版，语法: th:fragment=”模块名(变量)”变量部分为可选, 配合 th:with 使用。123456&lt;!-- 不保留本身的标签, 保留 th:fragment 的标签 --&gt;&lt;div th:replace=\"/admin/fragments/header::header\"&gt;&lt;/div&gt;&lt;!-- 保留本身的标签, 保留 th:fragment 的标签 --&gt;&lt;div th:insert=\"/admin/fragments/header::header\"&gt;&lt;/div&gt;&lt;!-- @过期, 保留本身的标签, 不保留 th:fragment 的标签 --&gt;&lt;div th:include=\"/admin/fragments/header::header\"&gt;&lt;/div&gt; th:with 定义变量。语法: th:with=”字段1=值, 字段2=值2”1&lt;div th:with=\"id='UploadImage',var='image',height=1,maxCount=1\"&gt;&lt;/div&gt; th:if 就是 if ..1234567&lt;div th:if=\"$&#123;true&#125;\"&gt;&lt;/div&gt;&lt;!-- 布尔值. 0 = false \"false\"/\"off\"/\"no\" = false null = false --&gt; th:switch/th:case1234&lt;ul th:switch=\"$&#123;val&#125;\"&gt; &lt;li th:case=\"1\"&gt;1&lt;/li&gt; &lt;li th:case=\"2\"&gt;2&lt;/li&gt;&lt;/ul&gt; th:selected 可用于 标签1234&lt;select class=\"form-control\" id=\"type\" name=\"type\"&gt; &lt;option value=\"0\" th:selected=\"$&#123;permission?.type==0&#125;\"&gt;菜单&lt;/option&gt; &lt;option value=\"1\" th:selected=\"$&#123;permission?.type==1&#125;\"&gt;数据&lt;/option&gt;&lt;/select&gt; 注释语法123456789&lt;!--/* 这里是 编译器显示为注释, 浏览器不可见 */--&gt;&lt;!--/*--&gt;&lt;div&gt;这里是 编译器显示不注释，浏览器不可见 &lt;/div&gt;&lt;!--*/--&gt;&lt;!--/*/&lt;div th:text=\"$&#123;'这里是 编辑器显示为注释, 浏览器可见'&#125;\"&gt;...&lt;/div&gt;/*/--&gt; 表达式URL 表达式123456&lt;img th:src=\"@&#123;/img/tup.png&#125;\" alt=\"绝对路径\"&gt;&lt;!-- &lt;img alt=\"绝对路径\" src=\"/img/tup.png\"&gt; --&gt;&lt;img th:src=\"@&#123;../img/tup.png&#125;\" alt=\"相对路径\"&gt;&lt;!-- &lt;img alt=\"相对路径\" src=\"../img/tup.png\"&gt; --&gt;&lt;img th:src=\"@&#123;../img/tup.png(size=$&#123;100&#125;)&#125;\" alt=\"带参数的路径\"&gt;&lt;!-- &lt;img alt=\"带参数的路径\" src=\"../img/tup.png?size=100\"&gt; --&gt; 国际化表达式 创建 resources/messages_zh_CN.properties, 其内容: 1message.error=错误 配置 application.yml (使用 xml 的执行转换) 123spring: messages: basename: messages_zh_CN 使用 1&lt;div th:text=\"#&#123;message.error&#125;\"&gt;Error&lt;/div&gt; 变量表达式 最基本的表达式, 类似于 EL 表达式。 合 org.springframework.ui.Model 使用。 可以使用众多内置对象。 @访问 Spring 容器内对象 1&lt;span th:text=\"$&#123;author.name&#125;\"&gt; 变量表达式 - 扩展 11234567891011121314&lt;ul th:object=\"$&#123;author&#125;\"&gt; &lt;li th:text=\"*&#123;name&#125;\"&gt;&lt;/li&gt; &lt;li th:text=\"*&#123;mail&#125;\"&gt;&lt;/li&gt; &lt;li th:text=\"*&#123;address&#125;\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 等价于 &lt;ul&gt; &lt;li th:text=\"$&#123;author.name&#125;\"&gt;&lt;/li&gt; &lt;li th:text=\"$&#123;author.mail&#125;\"&gt;&lt;/li&gt; &lt;li th:text=\"$&#123;author.address&#125;\"&gt;&lt;/li&gt; &lt;/ul&gt;--&gt; 变量表达式 - 扩展 21&lt;div th:text=\"$&#123;@demoService.getStr('hocgin')&#125;\"&gt;&lt;/div&gt; 预处理表达式 前置设置, Controller 12345678@GetMapping(&#123;\"/test.html\"&#125;)public String index(Model model, @PathVariable String page) &#123; model.addAttribute(\"key\", \"error\"); HashMap&lt;String, String&gt; vm = new HashMap&lt;&gt;(); vm.put(\"error\", \"来自 $&#123;&#125; 表达式\"); model.addAttribute(\"obj\", vm); return String.format(\"test.html\", page);&#125; 前置设置, messages_zh_CN.properties 参考国际化表达式 1message.error=错误 test.html 编写 123456&lt;a th:href=\"@&#123;/img/__$&#123;1+1&#125;__&#125;\"&gt;连接&lt;/a&gt;&lt;!-- &lt;a href=\"/img/2\"&gt;连接&lt;/a&gt; --&gt;&lt;div th:text=\"#&#123;message.__$&#123;key&#125;__&#125;\"&gt;&lt;/div&gt;&lt;!-- &lt;div&gt;错误&lt;/div&gt; --&gt;&lt;div th:text=\"$&#123;obj.__$&#123;key&#125;__&#125;\"&gt;&lt;/div&gt;&lt;!-- &lt;div&gt;来自 $&#123;&#125; 表达式&lt;/div&gt; --&gt; Fragment 表达式 ~{…} 表达式语法字符串拼接使用 + 或者 |..| 1234&lt;span th:text=\"'1+1=' + $&#123;1+1&#125;\"&gt;&lt;/span&gt;&lt;!-- 1+1=2 --&gt;&lt;span th:text=\"|1+1=$&#123;1+1&#125;|\"&gt;&lt;/span&gt;&lt;!-- 1+1=2 --&gt; 运算符号使用 +, -, *, /, %。 12&lt;span th:text=\"-((1+1-1)*2/2)%9\"&gt;&lt;/span&gt;&lt;!-- -1 --&gt; 与 或 非使用 and , or 和 ! , not。 123456789101112&lt;span th:text=\"1==1 and true\"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text=\"true and false\"&gt;&lt;/span&gt;&lt;!-- false --&gt;&lt;span th:text=\"true or false\"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text=\"not true\"&gt;&lt;/span&gt;&lt;!-- false --&gt;&lt;span th:text=\"! false\"&gt;&lt;/span&gt;&lt;!-- true --&gt; 关系表达式使用 &gt;, &lt;, &gt;=, &lt;=, ==, !=。或者 gt, lt, ge, le, eq, ne。 1234&lt;span th:text=\"((1 &gt; 2 and 2 &lt; 3) or (2 &gt;= 2 and 2 &lt;= 5)) and (1 == 1 and 1 != 2)\"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text=\"((1 gt 2 and 2 lt 3) or (2 ge 2 and 2 le 5)) and (1 eq 1 and 1 ne 2)\"&gt;&lt;/span&gt;&lt;!-- true --&gt; 简单条件表达式使用:if-then (if) ? (then)if-then-else (if) ? (then) : (else)default (value) ?: (defaultValue) 123456&lt;span th:text=\"true ? 'hocgin'\"&gt;&lt;/span&gt;&lt;!-- hocgin --&gt;&lt;span th:text=\"false ? 'hocgin' : 'hocg.in'\"&gt;&lt;/span&gt;&lt;!-- hocg.in --&gt;&lt;span th:text=\"$&#123;iname&#125; ?: 'hocgin'\"&gt;&lt;/span&gt;&lt;!-- hocgin --&gt; 解析优先级 级别 描述 th属性 1 (Fragment inclusion)代码片段导入 th:insert,th:replace 2 (Fragment iteration)迭代 th:each 3 (Conditional evaluation)条件 th:if,th:unless,th:switch,th:case 4 (Local variable definition)局部变量 th:object,th:with 5 (General attribute modification)通用属性修改 th:attr,th:attrprepend,th:attrappend 6 (Specific attribute modification)具体属性修改 th:value,th:href,th:src … 7 (Text tag body modification) 文本节点修改 th:text,th:utext 8 (Fragment specification) 代码段定义 th:fragment 9 (Fragment removal) 代码段删除 th:remove 基础对象#ctx (org.thymeleaf.spring4.context.SpringWebContext)123456789101112131415161718192021/** * org.thymeleaf.context.IContext **/// 当前语言环境(eg. en_US)。 等价于 &#123;#locale&#125;$&#123;#ctx.locale&#125;// org.thymeleaf.context.VariablesMap 对象, 内部存储的是可用于当前上下文(Context)的对象。等价于 &#123;#vars&#125;$&#123;#ctx.variables&#125;/** * org.thymeleaf.context.IWebContext **/$&#123;#ctx.applicationAttributes&#125;// 等价于 &#123;#httpServletRequest&#125;$&#123;#ctx.httpServletRequest&#125;$&#123;#ctx.httpServletResponse&#125;// 等价于 &#123;#httpSession&#125;$&#123;#ctx.httpSession&#125;$&#123;#ctx.requestAttributes&#125;$&#123;#ctx.requestParameters&#125;$&#123;#ctx.servletContext&#125;$&#123;#ctx.sessionAttributes&#125; param (org.apache.catalina.util.ParameterMap)包含当前页面的请求的参数(eg. http://localhost:8080/admin/test.html?name=hocgin)。 1234567// 返回对象$&#123;param.name&#125; // 获得值: hocgin$&#123;param.name[0]&#125; $&#123;param.size()&#125;$&#123;param.isEmpty()&#125;$&#123;param.containsKey('name')&#125; session (org.thymeleaf.context.WebSessionVariablesMap)从 Session 获取内容。 12345// 获得值: hocgin$&#123;session.name&#125;$&#123;session.size()&#125;$&#123;session.isEmpty()&#125;$&#123;session.containsKey('name')&#125; #httpServletRequest (org.apache.catalina.connector.RequestFacade)#themes (org.thymeleaf.spring4.expression.Themes)application#dates (org.thymeleaf.expression.Dates)#calendars (org.thymeleaf.expression.Calendars)#numbers (org.thymeleaf.expression.Numbers)#strings (org.thymeleaf.expression.Strings)#objects (org.thymeleaf.expression.Objects)#bools (org.thymeleaf.expression.Bools)#arrays (org.thymeleaf.expression.Arrays)#lists (org.thymeleaf.expression.Lists)#sets (org.thymeleaf.expression.Sets)#maps (org.thymeleaf.expression.Maps)#aggregates (org.thymeleaf.expression.Aggregates)#messages (org.thymeleaf.expression.Messages)#ids (org.thymeleaf.expression.Ids)代码示例 123456789101112131415161718192021222324### `#locale` (&lt;span th:text=\"$&#123;#locale&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#ctx` (&lt;span th:text=\"$&#123;#ctx&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#vars` (&lt;span th:text=\"$&#123;#vars&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `param` (&lt;span th:text=\"$&#123;param&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `application` (&lt;span th:text=\"$&#123;application&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `session` (&lt;span th:text=\"$&#123;session&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#httpSession` (&lt;span th:text=\"$&#123;#httpSession&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#httpServletRequest` (&lt;span th:text=\"$&#123;#httpServletRequest&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#themes` (&lt;span th:text=\"$&#123;#themes&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#dates` (&lt;span th:text=\"$&#123;#dates&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#calendars` (&lt;span th:text=\"$&#123;#calendars&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#numbers` (&lt;span th:text=\"$&#123;#numbers&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#strings` (&lt;span th:text=\"$&#123;#strings&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#objects` (&lt;span th:text=\"$&#123;#objects&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#bools` (&lt;span th:text=\"$&#123;#bools&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#arrays` (&lt;span th:text=\"$&#123;#arrays&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#lists` (&lt;span th:text=\"$&#123;#lists&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#sets` (&lt;span th:text=\"$&#123;#sets&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#maps` (&lt;span th:text=\"$&#123;#maps&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#aggregates` (&lt;span th:text=\"$&#123;#aggregates&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#messages` (&lt;span th:text=\"$&#123;#messages&#125;\"&gt;&lt;/span&gt;)&lt;br&gt;### `#ids` (&lt;span th:text=\"$&#123;#ids&#125;\"&gt;&lt;/span&gt;)&lt;br&gt; 重点 在 thymeleaf 中使用 Spring 容器内的单例. 1&lt;div th:text=\"$&#123;@demoService.getStr('hocgin')&#125;\"&gt;&lt;/div&gt; 引入模版片段 XPath 表达式 1&lt;div th:include=\"mytemplate :: [//div[@class='content']]\"&gt;&lt;/div&gt; CSS 表达式 1&lt;div th:include=\"mytemplate :: [div.content]\"&gt;&lt;/div&gt; 引入公有片段(JS 或 CSS) 123&lt;css th:replace=\"mytemplate :: common-css\"&gt;&lt;/css&gt;&lt;js th:replace=\"@&#123;mytemplate&#125; :: common-css\"&gt;&lt;/js&gt;&lt;!-- 可结合 路径表达式 --&gt; 扩展thymeleaf-layout-dialect 一般情况网站都有一个外部框架, 如 header 或者 footer, 这个扩展便是用于抽离那些重复的部分的。 layout:decorator指定需使用的父级模版123456&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\" layout:decorator=\"/admin/_layouts/default\"&gt; ...&lt;/html&gt; layout:fragment 在父模版中使用定义一个标记，在子模版中使用覆盖到父模版位置。123456789101112&lt;!-- 父 --&gt;&lt;div layout:fragment=\"content\"&gt; &lt;p&gt;父模版内容&lt;/p&gt;&lt;/div&gt;&lt;!-- 子 --&gt;&lt;div layout:fragment=\"content\"&gt; &lt;p&gt;子模版内容&lt;/p&gt;&lt;/div&gt;&lt;!-- 生成 --&gt;&lt;div&gt; &lt;p&gt;子模版内容&lt;/p&gt;&lt;/div&gt; layout:title-pattern 用与 标签, 指定 title 的值。12&lt;!-- 后台 - 子标题 --&gt;&lt;title layout:title-pattern=\"$DECORATOR_TITLE - $CONTENT_TITLE\"&gt;后台&lt;/title&gt; 黑科技 当我们想取一个对象里面的一个属性, 但这个对象可能为空时(😋)。1&lt;td th:text=\"$&#123;user?.address?.city&#125;\"&gt;&lt;/td&gt;","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://hocg.in/tags/HTML5/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://hocg.in/tags/Thymeleaf/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Java线程池和锁-小记","slug":"Java 线程池 和 锁 小记","date":"2017-10-06T17:03:29.000Z","updated":"2018-05-05T13:02:21.829Z","comments":true,"path":"2017/10/07/Java 线程池 和 锁 小记/","link":"","permalink":"https://hocg.in/2017/10/07/Java 线程池 和 锁 小记/","excerpt":"提取想要的apk， 例如CM ROM包中的含天气的时钟不错！","text":"提取想要的apk， 例如CM ROM包中的含天气的时钟不错！ 并发线程池 ExecutorService 123456789101112131415161718192021public class ConcurrencyMain &#123; public static void main(String[] args) throws InterruptedException &#123;ExecutorService executor = Executors.newWorkStealingPool(); List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList( () -&gt; \"task1\", () -&gt; \"task2\", () -&gt; \"task3\"); executor.invokeAll(callables) .stream() .map(future -&gt; &#123; try &#123; return future.get(); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; &#125;) .forEach(System.out::println); &#125;&#125; ScheduledExecutorService 12345678910111213public class ConcurrencyMain &#123; public static void main(String[] args) throws InterruptedException &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(3); ScheduledFuture&lt;?&gt; future = executor.schedule(() -&gt; System.out.println(\"执行延迟任务\"), 2, TimeUnit.SECONDS); TimeUnit.MILLISECONDS.sleep(1000); long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS); System.out.println(String.format(\"剩余延迟时间: %sms\", remainingDelay)); &#125;&#125; 区别 两者的区别是ScheduledExecutorService是可延迟执行。 同步(Synchronized) 对象锁语法: 1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedMain &#123; public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec()); Thread runnable2 = new Thread(() -&gt; t1.exec()); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 9 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec()); Thread runnable4 = new Thread(() -&gt; t2.exec()); runnable3.start(); runnable4.start(); &#125;&#125;// 以下两种方式等价，仅作用范围不一样。class Test &#123; public synchronized void exec() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + \" \"); &#125; &#125; public void exec() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + \" \"); &#125; &#125; &#125;&#125; 结论: 同一对象调用该方法是锁定的，不同对象不会进行锁定。 类锁12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedMain &#123; public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec()); Thread runnable2 = new Thread(() -&gt; t1.exec()); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec()); Thread runnable4 = new Thread(() -&gt; t2.exec()); runnable3.start(); runnable4.start(); &#125;&#125;// 以下两种方式等价class Test &#123; private static Object lock = new Object(); public void exec() &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + \" \"); &#125; &#125; &#125; public void exec() &#123; synchronized (Test.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + \" \"); &#125; &#125; &#125;&#125; 结论: 该方式锁的作用范围是整个类。 指定锁语法: 1234567891011121314151617181920212223242526272829303132public class SynchronizedMain &#123; private static Object lock = new Object(); public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec(lock)); Thread runnable2 = new Thread(() -&gt; t1.exec(lock)); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec(lock)); Thread runnable4 = new Thread(() -&gt; t2.exec(lock)); runnable3.start(); runnable4.start(); &#125;&#125;class Test &#123; public void exec(Object lock) &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + \" \"); &#125; &#125; &#125;&#125; 结论: 该方式取决于传入的锁。当对象属性发生改变时，锁就失去了作用。 对于 Java8 中，ReentrantLock 可实现锁的作用。","categories":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/categories/Java/"}]},{"title":"解决 WebView 点击时网页不断闪耀","slug":"解决WebView点击时网页不断闪耀","date":"2017-09-28T13:47:21.000Z","updated":"2017-09-28T14:14:54.743Z","comments":true,"path":"2017/09/28/解决WebView点击时网页不断闪耀/","link":"","permalink":"https://hocg.in/2017/09/28/解决WebView点击时网页不断闪耀/","excerpt":"解决高版本 WebView 点击时网页不断闪耀的问题 🤗","text":"解决高版本 WebView 点击时网页不断闪耀的问题 🤗 原因网页渲染开启了硬件加速，如果你也出现了该问题，可以尝试关闭硬件加速。 方案方案一: 在xml中使用android:layerType=&quot;software&quot;进行关闭。推荐方案二: 通过 java 代码webView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);进行关闭。 参考BroswerKit进行标记的这段代码解决了我的闪耀问题","categories":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/tags/Android/"},{"name":"问题","slug":"问题","permalink":"https://hocg.in/tags/问题/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}]},{"title":"解决 ProgressBar 上下出现空白现象","slug":"解决ProgressBar顶部出现空白现象","date":"2017-09-27T02:27:22.000Z","updated":"2017-09-28T14:15:57.000Z","comments":true,"path":"2017/09/27/解决ProgressBar顶部出现空白现象/","link":"","permalink":"https://hocg.in/2017/09/27/解决ProgressBar顶部出现空白现象/","excerpt":"解决 ProgressBar 上下出现空白现象 🤠","text":"解决 ProgressBar 上下出现空白现象 🤠 出现问题一般情况我们使用如下代码来创建ProgressBar12345678&lt;ProgressBar android:id=\"@+id/progressBar\" style=\"?android:attr/progressBarStyleHorizontal\" android:background=\"#fff\" android:max=\"100\" android:indeterminate=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; 那么将会出现如下情况: 解决方案通过变更android:layout_marginBottom和android:layout_marginTop在结合android:background设置为透明来处理这个问题:12345678910&lt;ProgressBar android:id=\"@+id/progressBar\" style=\"?android:attr/progressBarStyleHorizontal\" android:layout_marginBottom=\"-7dp\" android:layout_marginTop=\"-7dp\" android:background=\"#00ffffff\" android:max=\"100\" android:indeterminate=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; 以下是处理后的结果","categories":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/tags/Android/"},{"name":"问题","slug":"问题","permalink":"https://hocg.in/tags/问题/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}]},{"title":"OpenWrt 入门篇","slug":"OpenWrt-入门篇","date":"2017-09-18T06:32:26.000Z","updated":"2017-11-11T15:11:01.049Z","comments":true,"path":"2017/09/18/OpenWrt-入门篇/","link":"","permalink":"https://hocg.in/2017/09/18/OpenWrt-入门篇/","excerpt":"今天刚好重刷 OpenWrt 固件，整理整理","text":"今天刚好重刷 OpenWrt 固件，整理整理 介绍什么是 OpenWrt? 关于支持 OpenWrt 的路由器可以去 支持 OpenWrt 的路由器列表 查看支持的路由器, 了解其 CPU型号(既芯片型号) RAM容量 Flash容量 关于 OpenWrt 固件的下载OpenWrt 官方下载固件地址关于下载地址格式: 关于固件类型 后缀为factory是用于从原厂固件刷为 OpenWrt。 后缀为sysupgrade是用于从 OpenWrt 更新 OpenWrt。 原厂刷 OpenWrt 固件 待补充 网页界面 OpenWrt 备份 &amp; 升级固件 OpenWrt 安全模式 当我们无法进入网页界面，可以使用安全模式管理恢复固件必须使用有线电缆进行连接。环境: Linux or macOS 进入OpenWrt安全模式的方法： 使用网线连接电脑和路由器 设置电脑网卡IP 地址:192.168.1.x(x为2至255)子网掩码:255.255.255.0 打开终端运行命令 12# 注, 此处 eth0 为网卡. 可使用 ifconfig 进行查看sudo tcpdump -Ani eth0 port 4919 and udp 断电重启 打开终端运行命令 1telnet 192.168.1.1 执行指令, 例如 1234# 重置系统firstboot# 重置密码passwd 重启路由器 不死 U-Boot 待补充 网页界面 OpenWrt 宽带拨号设置 进入接口设置界面 进行 WAN 口编辑 填写宽带账号 &amp; 密码 此时电脑连接 LAN 口的话，即可进行上网。 WiFi 设置 进入 WiFi 设置界面，此处为双网卡 开启WiFi 设置WiFi 基础知识什么是WAN口？什么是LAN口？ 路由器通常有多个LAN口，一个WAN口 WAN 广域网（WAN、公网、外网） 设置拨号上网连接互联网 LAN 局域网（LAN、私网、内网) 连接本地计算机 PPPoE 以太网上的点对点协议中的一种, 宽带接入方式ADSL 就使用了PPPoE协议 关于 WiFi 2.4G 和 5G802.11n/b/g 主要工作频段为2.4GHz802.11a/ac 主要工作频段为5GHz","categories":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/tags/OpenWrt/"}],"keywords":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://hocg.in/categories/OpenWrt/"}]},{"title":"关于 Android Studio 启动 Android 模拟器失败问题","slug":"关于Android Studio 启动Android模拟器失败问题","date":"2017-07-02T13:07:00.000Z","updated":"2017-07-02T13:07:55.000Z","comments":true,"path":"2017/07/02/关于Android Studio 启动Android模拟器失败问题/","link":"","permalink":"https://hocg.in/2017/07/02/关于Android Studio 启动Android模拟器失败问题/","excerpt":"起因Android Studio 启动虚拟机一直闪退，不显示任何报错信息","text":"起因Android Studio 启动虚拟机一直闪退，不显示任何报错信息 排查问题 尝试用命令启动模拟器, 方便查看其错误日志1234567891011121314# 查看你创建的设备emulator -list-avds# 启动命令emulator -netdelay none -netspeed full -avd New_Device_API_2# 以下为报错日志Hax is enabledHax ram_size 0x60000000HAX is working and emulator runs in fast virt mode.Failed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync HAX vcpu contextInternal error: Initial hax sync failed vcpu无法进行同步?? What??尝试进行了 Google，How do I fix “Failed to sync vcpu reg” error? 好吧, docker 之类的虚拟机引起了冲突 解决办法关掉用不着的虚拟机如 docker ..","categories":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/tags/Android/"},{"name":"Mac","slug":"Mac","permalink":"https://hocg.in/tags/Mac/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}]},{"title":"Google 使用技巧","slug":"Google-使用技巧","date":"2017-06-18T03:24:06.000Z","updated":"2017-11-11T15:11:01.049Z","comments":true,"path":"2017/06/18/Google-使用技巧/","link":"","permalink":"https://hocg.in/2017/06/18/Google-使用技巧/","excerpt":"摩擦 Google 利器。","text":"摩擦 Google 利器。 前提使用 https://www.google.com/ncr 模式并且是英文版。 技巧双引号 完全匹配搜索 减号 使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除特定的词。 星号 号代表任何文字，即*模糊搜索 ～ 匹配 该关键词 或 该关键词的同义词 OR 匹配关键词hocgin或者hocg.in + 匹配关键词hocgin与hocg.in同时存在 inurl 匹配url连接中包含该词汇，例如上方匹配 https://hocg.in/hocgin allinurl 等价于: inurl: hocgin inurl: hocg.in匹配url连接中既包含hocgin也包含hocg.in, 例如: https://hocg.in/hocgin inanchor 匹配a标签中的文字, 例如上方匹配 \\hocgin\\ intitle 匹配title标签中的文字, \\hocgin\\ allintitle 等价于: intitle: hocgin intitle: hocg.in匹配标题中既包含hocgin也包含hocg.in,例如: \\hocgin 的博客地址 hocg.in\\ filetype 匹配包含关键词hocgin的所有pdf文件 site 某个域名的搜索 ralated 返回 Google 人为相关的页面 混合使用示例图片来源 工具查询字词的释义 数学运算 天气查询 当前时间 日出 日落 音乐人搜索 省会 汇率 200美元换多少人民币，可以进行数学运算 设置计时器 Set timer XX seconds/minutes/hours，XX表示具体的数字。 两地点距离计算 当前位置 显示当前电脑IP 显示国家 GDP 绘制多元方程以及复杂的方程式 graph + 方程式 搜索某个单词的由来","categories":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Google","slug":"Google","permalink":"https://hocg.in/tags/Google/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}]},{"title":"字符串编码篇","slug":"字符串编码篇","date":"2017-05-12T13:09:03.000Z","updated":"2017-11-11T15:11:01.049Z","comments":true,"path":"2017/05/12/字符串编码篇/","link":"","permalink":"https://hocg.in/2017/05/12/字符串编码篇/","excerpt":"字符编码的来历..","text":"字符编码的来历.. ASCII 最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号 占位: 1个字节 GB2312 中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突 Unicode \\u[16进制] Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 占位: 通常是2个字节 UTF-8 本着节约的精神，又出现了把Unicode编码转化为“可变长编码”Note: UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节","categories":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}]},{"title":"Wireshark 的使用","slug":"Wireshark的使用","date":"2017-04-20T11:34:05.000Z","updated":"2017-11-11T15:11:01.049Z","comments":true,"path":"2017/04/20/Wireshark的使用/","link":"","permalink":"https://hocg.in/2017/04/20/Wireshark的使用/","excerpt":"抽空整理一下, 虽然Charles很好用, 但是某些情况下该软件也是不可替代的.","text":"抽空整理一下, 虽然Charles很好用, 但是某些情况下该软件也是不可替代的. 关于Wireshark适合研究 TCP,UDP 等协议. 因为限制并不能改包或模拟发包，只能分析协议若, 研究HTTP,HTTPS推荐使用Charles or Fiddler 关于抓包五颜六色的意义 更多详情查看 View - Coloring Rules 绿色背景（黑字）HTTP包 灰色背景（黑字）TCP包 蓝色背景 (黑字) DNS包 黑色背景 (红字) TCP错误包或者校验错误包 Wireshark主窗口 从上至下 菜单栏: 用于开始操作。 主工具栏: 提供快速访问菜单中经常用到的项目的功能。 过滤工具栏: 提供处理当前显示过滤得方法。 拦截的数据包列表(Packet list): 显示打开文件的每个包的摘要。点击面板中的单独条目，包的其他情况将会显示在另外两个面板中。 选中的数据包信息(Packet details): 显示您在Packet list面板中选择的包的更多详情。 选中的数据包字节码: 显示您在Packet list面板选择的包的数据，以及在Packet details面板高亮显示的字段。 状态栏: 显示当前程序状态以及捕捉数据的更多详情。 选中的数据包信息 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议 过滤表达式 协议过滤 tcp upd .. ip 过滤 来源 ip.src == 192.168.1.1目的地 ip.dst == 192.168.1.1 端口 tcp.port == 8080仅显示来源为8080的 tcp.srcport == 8080 Http模式 http.request.method==”GET” 逻辑运算符为 and or","categories":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://hocg.in/tags/Wireshark/"}],"keywords":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}]},{"title":"SQL的重新梳理","slug":"SQL重新梳理","date":"2017-04-07T01:19:09.000Z","updated":"2017-11-11T15:11:01.049Z","comments":true,"path":"2017/04/07/SQL重新梳理/","link":"","permalink":"https://hocg.in/2017/04/07/SQL重新梳理/","excerpt":"持续积累..","text":"持续积累.. 关于 SQL 执行顺序资料参考 例句123456select * from t_1 join t_2on t_1.id = t_2.fidwhere 1=1group by t_1.classNamehaving t_1.className = '1班'order by id desc; 这是一条简单/规范的基本SQL。 注意 SQL三个很重要的位置on/where/having它们分别对应着 join/from/group 形成后的虚表进行筛选。 select部分并不是一开始就执行的，而是表数据确认完毕，只差排序的时候执行的。并且select中的函数/DISTINCT/TOP也是在select执行阶段执行的 聚合函数需Group后才可执行, 普通函数随执行步骤执行(正常执行) 具体顺序 FROM FROM后面的表标识了这条语句要查询的数据源。和一些子句如，（1-J1）笛卡尔积，（1-J2）ON过滤，（1-J3）添加外部列，所要应用的对象。FROM过程之后会生成一个虚拟表VT1。(1-J1)笛卡尔积 这个步骤会计算两个相关联表的笛卡尔积(CROSS JOIN) ，生成虚拟表VT1-J1。(1-J2)ON过滤 这个步骤基于虚拟表VT1-J1这一个虚拟表进行过滤，过滤出所有满足ON 谓词条件的列，生成虚拟表VT1-J2。(1-J3)添加外部行 如果使用了外连接(外连接才会加入字段/数据)，保留表中的不符合ON条件的列也会被加入到VT1-J2中，作为外部行，生成虚拟表VT1-J3。此时 不符合ON的会被加入回来 WHERE 对VT1过程中生成的临时表进行过滤，满足where子句的列被插入到VT2表中。 数据现在还没有被分组，因此现在你不能使用聚合运算- GROUP BY 这个子句会把VT2中生成的表按照GROUP BY中的列进行分组。生成VT3表。每一个分组必须只能返回一行(除非被过滤掉)，即每一行整体都无重复，对于没有出现GROUP BY后面的列必须使用聚合函数(如 MAX ,MIN,COUNT,AVG等)，保证每一个GROUP只返回一行 HAVING 这个子句对VT3表中的不同的组进行过滤，满足HAVING条件的子句被加入到VT4表中。 SELECT 这个子句对SELECT子句中的元素进行处理，生成VT5表。(5-1)计算表达式 计算SELECT 子句中的表达式，生成VT5-1 如果这个sql语句是一个聚合查询，在GROUP BY之后，你只能使用GROUP BY中的列，对不属于GROUP集合中的列必须使用聚合运算(5-2)DISTINCT 寻找VT5-1中的重复列，并删掉，生成VT5-2(5-3)TOP 从ORDER BY子句定义的结果中，筛选出符合条件的列。生成VT5-3表 ORDER BY 从VT5-3中的表中，根据ORDER BY 子句的条件对结果进行排序，生成VC6表。唯一一个可以使用SELECT子句创建的别名的地方 聚合函数是对一组值执行计算并返回单一的值的函数 1234567SELECT C.customerid, COUNT(O.orderid) AS numordersFROM dbo.Customers AS C LEFT OUTER JOIN dbo.Orders AS O ON C.customerid = O.customeridWHERE C.city = 'Madrid'GROUP BY C.customeridHAVING COUNT(O.orderid) 关于 表 Joins Joins 子句用于结合两个或多个数据库中表的记录, 也就是说是通过某种联系建立表之间的关联, 并形成一张新表 SQL 定义了三种主要类型的连接 交叉连接 ( CROSS JOIN ), 又称 笛卡尔积 会形成庞大的表, 因此慎用。假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 cross join t2结果: 数据数量为20行数据(5 4), 5列 内连接 ( INNER JOIN ), 通常可省略 inner 通过 on 或 where 建立表之间的联系或者说表形成的条件假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 inner join t2 on t1.sid = t2.sid*结果: 查询操作列出与连接条件匹配的数据行, 5列 外连接 ( OUTER JOIN ) 外连接为内连接的扩展, 主要区别在于哪边为基准, 使用 on 进行数据关联外连接分为: 左外连接、右外连接、全外连接部分SQL语言并不包含全部种类, 例如SQLite 之包含 左外连接 左外连接 ( LEFT JOIN )假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 left join t2 on t1.sid = t2.sid*结果: 以左表为基准, 将数据按条件进行连接, 左表行全部显示, 若右表没有满足条件的行则显示为NULL, 5列 右外连接 ( RIGHT JOIN ) 假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 right join t2 on t1.sid = t2.sid*结果: 以右表为基准, 将数据按条件进行连接, 右表行全部显示, 若左表没有满足条件的行则显示为NULL, 5列 全外连接 ( FULL JOIN ) 假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 full join t2 on t1.sid = t2.sid*结果: 完整的显示两表的数据, 将数据按条件进行连接, 当没有被关联的表中没有存在满足条件的行时, 则显示为NULL, 5列","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"SQL","slug":"SQL","permalink":"https://hocg.in/tags/SQL/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Vue.js项目 部件简介 (未完待续)","slug":"Vue.js项目-部件简介","date":"2017-03-31T07:32:36.000Z","updated":"2017-03-31T13:15:33.000Z","comments":true,"path":"2017/03/31/Vue.js项目-部件简介/","link":"","permalink":"https://hocg.in/2017/03/31/Vue.js项目-部件简介/","excerpt":"🦋 目前国内前端MVVM最火的框架.. 前段时间写了一个About页面, 这几天顺带整理一下知识点.","text":"🦋 目前国内前端MVVM最火的框架.. 前段时间写了一个About页面, 这几天顺带整理一下知识点. Vue.js Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的.类似的有Angular.js. 可以建立DOM和数据之间的绑定 可以按功能/组件抽离HTML代码 相关Vue 项目实践 - 持续更新 功能部分基础 数值默认双向绑定 支持 条件语法特性/功能函数/生命周期 动态设定style/class 捆绑event 渲染生命周期高级 单页面组件 自定义指令 单元测试 插件 单文件组件.vue定义:12345678&lt;template&gt; &lt;h1&gt;This is title&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'Title' &#125;&lt;/script&gt; 使用:123456789101112131415&lt;template&gt; &lt;div id=\"app\"&gt; &lt;img src=\"./assets/logo.png\"&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Title from './components/Title' export default &#123; name: 'app', components: &#123; Title &#125; &#125;&lt;/script&gt; Vue Router 扩展 Vue按字面意思来看为Vue 路由其实质也就是用于单页应用管理页面跳转, 负责路径解析. 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]&#125;) Vuex 扩展 Vue当开发大型项目时, 为防止 Vue 太过臃肿, 使用 Vuex 管理数据状态. webpack 一款模块加载器兼打包工具使用模块的理念来处理 JS/CSS/图片等资源文件 指令123456789# 安装npm install webpack --save-dev# 执行webpack --display-error-details # 输出详细错误 --watch # 实时监听并自动打包 --config &lt;file&gt; # 指定配置文件打包 -p # 压缩打包 -d # 生成map映射文件 配置(webpack.config.js)12345678910111213141516171819module.exports = &#123; // 插件 plugins: [], // 页面入口 entry: &#123;&#125;, // 入口文件输出位置, 即处理后的文件存放位置 output: &#123;&#125;, module: &#123; // 文件处理加载器 rules: [] &#125;, // 额外处理 resolve: &#123; // 自动扩展文件后缀, require时可以进行省略 extensions: [], // 模块定义别名, require时可以进行路径省略, 直接使用别名 alias: &#123;&#125; &#125;&#125; 入口文件(main.js)1234567891011121314151617181920import Vue from 'vue'import App from './App'import router from './router'import store from './store/index'// 引入js, 加载器会自动进行处理import holderjs from 'holderjs'// 引入 css/scss, 加载器会自动进行处理import appScss from './assets/app.scss'import fontAwesomeCss from './assets/font-awesome-4.7.0/css/font-awesome.css'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 未完待续ing","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hocg.in/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://hocg.in/tags/HTML5/"},{"name":"前端","slug":"前端","permalink":"https://hocg.in/tags/前端/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"Vue 项目实践 - 持续更新","slug":"Vue.js-项目实践","date":"2017-03-26T07:40:08.000Z","updated":"2017-06-01T13:20:00.000Z","comments":true,"path":"2017/03/26/Vue.js-项目实践/","link":"","permalink":"https://hocg.in/2017/03/26/Vue.js-项目实践/","excerpt":"🐌 目前国内前端MVVM最火的框架.. 项目实践记录一些流程","text":"🐌 目前国内前端MVVM最火的框架.. 项目实践记录一些流程 相关 vue vue-router 给vue使用的路由 vuex 一个专为 Vue.js 应用程序开发的状态管理模式 webpack 快速搭建项目12345678910111213141516171819# 构建项目npm install -g vue-clivue init webpack &lt;project-name&gt;# 试行cd iPagenpm installnpm run dev# 安装 vuexnpm install vuex -S# 安装 sass 开发支持npm install --save-dev sass-loadernpm install --save-dev node-sassnpm install --save-dev css-loadernpm install --save-dev style-loader# 编译生成静态文件npm run build 目录结构12345678910111213141516. ├── README.md ├── build ├── config ├── index.html ├── node_modules ├── package.json ├── src // 源码| ├── App.vue // 父组件 | ├── assets // 静态文件 | ├── components // 公共组件 | ├── main.js // webpack打包入口文件 | └── router | └── index.js // 页面路由 ├── static └── test 遇到的问题","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://hocg.in/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://hocg.in/tags/HTML5/"},{"name":"前端","slug":"前端","permalink":"https://hocg.in/tags/前端/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"关于 Objective-C 的小笔记","slug":"关于 Objective-C 的小笔记","date":"2017-03-20T00:07:00.000Z","updated":"2017-07-02T13:14:22.000Z","comments":true,"path":"2017/03/20/关于 Objective-C 的小笔记/","link":"","permalink":"https://hocg.in/2017/03/20/关于 Objective-C 的小笔记/","excerpt":"之前学 swift3 顺带整理的小笔记","text":"之前学 swift3 顺带整理的小笔记 Objective-C介绍 文件后缀 文件类型 *.h 头文件。头文件包含类，类型，函数和常数的声明。 *.m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码 *.mm 源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。 说明 关键词 说明 #import 引入文件, 并确保相同的文件只会被包含一次 NSString* say = @”Hello World” 创建NSString对象 @interface/@implementation objective-c 一个类是由:定义和实现来构成的, @interface 用于定义, @implementation用于实现细节. @property与@synthesize @property用于在@interface声明getter与setter函数, @synthesize用于在@implementation实现getter与setter函数, 二者是搭配口味高版本(Xcode4.5)可省略@synthesize 基础框架 它包括 NSArray，NSDictionary中的NSSet等扩展数据类型的列表。 它由一组丰富的操作文件的函数，字符串，等等。 URL处理它提供的功能，如日期格式，数据处理，错误处理等实用工具 语法语法速读123456789101112131415161718192021222324252627282930313233/* 预处理(导包) */#import &lt;Foundation/Foundation.h&gt;/* 定义接口(继承:NSObject) */@interface SampleClass:NSObject- (void)sampleMethod;@end/* 实现接口(SampleClass) */@implementation SampleClass- (void)sampleMethod&#123; NSLog(@&quot;Hello, World!&quot;);&#125;@end/* 主函数 */int main() &#123; /* my first program in Objective-C */ SampleClass *sampleClass = [[SampleClass alloc]init]; /* - 调用函数 C: sampleClass.sampleMethod(args); OC: [对象 函数名: 参数] */ [sampleClass sampleMethod: args]; return 0;&#125; 类的语法 类分为: 类的定义(.h) 和 类的实现(.m) 定义 ( *.h )123456789101112131415@interface MyObject : NSObject&#123; // 此处变量默认为受保护(protected) int memberVar1; // 实体变量 id memberVar2;&#125;+(return_type) class_method; // &quot;+&quot; 表示 类方法-(return_type) instance_method1; // &quot;-&quot; 表示 实例方法-(return_type) instance_method2: (int) p1;// 这里的调用方式为: [obj instance_method3: 1 andPar: 2];// andPar 相当于外部的另外一个别名-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 实现 ( *.m )12345678910111213141516171819@implementation MyObject&#123; // 此处变量为私有(private) int memberVar3; //私有实体变量&#125;+(return_type) class_method &#123; .... //method implementation&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 创建对象1234// 注: alloc 与 init 都属于 NSObject 里的函数MyObject * my = [[MyObject alloc] init];// 无参构建, 也可采用以下方式 (Objective-C 2.0)MyObject * my = [MyObject new]; Note: { } 需如文这样标识, 才可表达出准确的语义, 读者自行领悟. 函数语法 函数分为: 类函数 和 对象函数 12345678910111213// 如上// 定义语法: 范围标识 (返回值)函数名:外部形参别名:(参数类型) 形参名 外部形参别名:(参数类型) 形参名// 注: 第一个 外部形参别名 可省略- (void)insertObject:(id)anObject atIndex:(NSUInteger) index+ (void)insertObject:(id)anObject atIndex:(NSUInteger) index// 调用// 对象调用 [对象 函数名: 参数1 外部形参别名: 参数2][obj insertObject: arg1 atIndex: arg2]// 类调用 [类名 函数名: 参数1 外部形参别名: 参数2][Object insertObject: arg1 atIndex: arg2]// 注:) 类调用 和 对象调用 的形式是一样的 属性语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@interface Person : NSObject&#123;/*相当于 @public 至 @private 之间的属性被暴露出去可通过实例直接访问, 例如: obj-&gt;name*/@public NSString *name;@private int age;&#125;/* 参考: http://justcoding.iteye.com/blog/1444548 使用范围: @interface, @protocol, @category 可声明特性: 读写属性： （readwrite/readonly） setter语意：（assign/retain/copy） 原子性： （atomicity/nonatomic） 使用效果(声明一个setter与getter方法): - (NSString*)name; - (void)setName: (NSString*)newName; */@property(copy) NSString *name;@property(readonly) int age;-(id)initWithAge:(int)age;@end@implementation Person/* 使用范围: @implementation 使用效果(自动实现一个setter与getter方法): - (NSString*)name &#123; return name; &#125; - (void)setName: (NSString*)newName &#123; name = newName; &#125; */@synthesize name;/* @dynamic 仅仅是告诉编译器这两个方法在运行期会有的，无需产生警告 */@dynamic age;-(id)initWithAge:(int)initAge&#123; age = initAge; // 注意：直接赋给成员变量，而非属性 return self;&#125;-(int)age&#123; return 29; // 注意：并非返回真正的年龄&#125;@end 类或协议的属性可以被动态的读取 类似反射机制 , 略过.. 快速枚举 一种省内存的循环遍历 , 略过.. 协议语法 类似 Java 中的接口123456789101112131415161718192021/*定义协议*/@protocol Locking- (void)lock;- (void)unlock;@end/*类的@interface 宣称使用 协议*/@interface SomeClass : SomeSuperClass &lt;Locking&gt;@end/*类的@implementation 实现 协议 细节*/@implementation SomeClass- (void)lock &#123; // 实现lock方法...&#125;- (void)unlock &#123; // 实现unlock方法...&#125;@end 动态类型 id 相当于 Java 中的 Object, 即 任意对象 类别 (Category) 语法 分类不仅可以增加类的方法，也可以代替原有的函数, 并不能新增变量动态增加和替换函数, 强得一匹 123456789101112131415161718192021222324252627282930313233/* 说明: 定义扩展 Integer类 接口, 新增/覆盖 函数 showstars 与 showint 语法: #import &quot;待扩展类接口文件.h&quot; @interface 待扩展类(扩展类) // 函数定义 @end*/#import &quot;Integer.h&quot;@interface Integer(Display)- (id) showstars;- (id) showint;@end/* 说明: 实现扩展 Integer类 接口, 新增/覆盖 函数 showstars 与 showint 语法: #import &quot;扩展类接口文件.h&quot; @implementation 待扩展类(扩展类) // 函数实现 @end*/#import &quot;Display.h&quot;@implementation Integer(Display)- (id) showstars &#123; ..&#125;- (id) showint &#123; ..&#125;@end NOTE: 使用时需#import 待扩展类与扩展类的接口文件(.h) 划重点 NSString*/NSObject*等 表示对象 self 某种程度相当于 this nil 基本上等同于 NULL 调用属性 self-&gt;name 一般(.h 存放@interface文件, .m 存放@implementation文件). 进行#import时, 只需#import .h文件","categories":[{"name":"Mac","slug":"Mac","permalink":"https://hocg.in/categories/Mac/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://hocg.in/tags/语法/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://hocg.in/tags/Objective-C/"}],"keywords":[{"name":"Mac","slug":"Mac","permalink":"https://hocg.in/categories/Mac/"}]},{"title":"PHP Laravel 快速入门","slug":"PHP-laravel-快速入门","date":"2017-03-01T06:59:38.000Z","updated":"2017-03-08T07:01:23.000Z","comments":true,"path":"2017/03/01/PHP-laravel-快速入门/","link":"","permalink":"https://hocg.in/2017/03/01/PHP-laravel-快速入门/","excerpt":"PHP 框架 Laravel 搭建开始, 慢慢更新~ 😜😜😜😜","text":"PHP 框架 Laravel 搭建开始, 慢慢更新~ 😜😜😜😜 Quit Start一. 安装composer, 用于管理依赖 123456# 全局安装 macOSbrew updatebrew tap josegonzalez/homebrew-phpbrew tap homebrew/versionsbrew install php55-intlbrew install josegonzalez/php/composer 二. 下载laravel 1composer global require \"laravel/installer\" 三. 创建项目 1composer create-project laravel/laravel --prefer-dist 四. 关于如何使用PhpStorm 默认已经配置好PHP开发环境了! 4.0.1 相关插件 Laravel Plugin [Optional] PHP Annotations Plugin [Optional] Symfony2 Plugin 4.1 配置Composer 右键项目根节点 -&gt; Composer -&gt; init composer, 配置PHP解释器和Composer路径 右键项目根节点 -&gt; Composer -&gt; add dependency, 添加barryvdh/laravel-ide-helper 或者 1composer require barryvdh/laravel-ide-helper 4.2 编辑config/app.php文件, 在providers节点下面添加 4.3 扩展命令工具 Preferences -&gt; Tools -&gt; Command Line Tool Support 使用: Tools -&gt; Run Command(⌘ + ⇧ + X) 4.4 配置 php-xdebug12# 检查是否安装php-xdebugphp -m 安装后，修改下php.ini把xdebug.so前的注释’;’去掉 五. 配置启动 六. 配置Debug 并且在根目录加入debug.ini 123456789101112xdebug.remote_enable = Onxdebug.remote_autostart = Onupload_max_filesize = 1000Mpost_max_size = 1005Mmax_execution_time = 120;xdebug.profiler_enable = On;xdebug.profiler_enable_trigger = Off;xdebug.profiler_output_dir = ./xdebug;xdebug.profiler_aggregate = On;xdebug.profiler_append = On;xdebug.profiler_output_name = &quot;cachegrind.out.%R.%u.%p&quot; 资源Laravel Live Templates for PhpStormLaravel 插件视频 标签 继承@extends 存在替换@yield(&#39;content&#39;)@section@endsection 增加@stack(&quot;appendCSS&quot;)@push(&#39;appendCSS&#39;)@endpush 注入@inject(&quot;xx&quot;, &quot;xx[Name]&quot;)","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://hocg.in/tags/Mac/"},{"name":"PHP","slug":"PHP","permalink":"https://hocg.in/tags/PHP/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Nginx 部署","slug":"Nginx-部署","date":"2017-02-24T01:12:22.000Z","updated":"2017-02-25T09:17:57.000Z","comments":true,"path":"2017/02/24/Nginx-部署/","link":"","permalink":"https://hocg.in/2017/02/24/Nginx-部署/","excerpt":"🎽 Nginx 是一个很强大的高性能Web和反向代理服务器","text":"🎽 Nginx 是一个很强大的高性能Web和反向代理服务器 前言环境OS: Ubuntu-16 安装依赖 PCRE zlib nginx 目录结构/opt|– nginx-1.10.1|– pcre-8.38`– zlib-1.2.8 shell 以下操作均在/opt目录 123# tar -zxvf nginx-1.10.1.tar.gz# cd nginx-1.10.1# ./configure ERROR:12345checking for OS + Linux 2.6.32-042stab113.21 x86_64checking for C compiler ... not found./configure: error: C compiler cc is not found 缺失编译部件, 解决办法如下:12# apt-get install build-essential libtool# ./configure Error:1234./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre=&lt;path&gt; option. 缺失PCRE, 移步官网下载(顶部有链接), 我是在/opt目录中解压注: pcre 没有 2 以下操作均在/opt目录 123# tar -jxvf pcre-8.38.tar.bz2# cd pcre-8.38# ./configure &amp;&amp; make &amp;&amp; make install 回到/opt/nginx-1.10.1目录继续进行1# ./configure --with-pcre=/opt/pcre-8.38 Error:1234./configure: error: the HTTP gzip module requires the zlib library.You can either disable the module by using --without-http_gzip_moduleoption, or install the zlib library into the system, or build the zlib librarystatically from the source with nginx by using --with-zlib=&lt;path&gt; option. 原因是缺失zlib,移步官网下载(顶部有链接), 同样是在/opt目录中解压 以下操作均在/opt目录 123# tar -zxvf zlib-1.2.8.tar.gz# cd zlib-1.2.8# ./configure &amp;&amp; make &amp;&amp; make install 回到/opt/nginx-1.10.1目录继续进行 123# ./configure --with-pcre=/opt/pcre-8.38 --with-zlib=/opt/zlib-1.2.8# make# make install 至此，安装结束。可查看ls /usr/local/nginx/目录显示如下文件:/usr/local/nginx/ 基础命令 以下命令均在/usr/local/nginx目录下运行 12345678# 启动./sbin/nginx# 检查配置./sbin/nginx -t# 重新加载配置./sbin/nginx -s reload# 查看配置文件cat ./conf/nginx.conf 扩展nginx.conf配置字段详解 模块待续ing","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"关于Chrome 插件开发的一些知识点","slug":"关于Chrome插件开发的一些知识点","date":"2017-02-04T05:20:51.000Z","updated":"2017-11-10T12:48:33.137Z","comments":true,"path":"2017/02/04/关于Chrome插件开发的一些知识点/","link":"","permalink":"https://hocg.in/2017/02/04/关于Chrome插件开发的一些知识点/","excerpt":"身为Chrome重度患者，生活和工作处处不离，这篇并不是入门教程，而是开发中的一些小Tip的记录.","text":"身为Chrome重度患者，生活和工作处处不离，这篇并不是入门教程，而是开发中的一些小Tip的记录. 我开发的Chrome 插件 天气预报 数据存储 HTML5 localStorage 存储在解析页面当前范围和网站共享localStorage Chrome API chrome.storage 存储在系统磁盘，适合少量数据 Web SQL Database 存储在系统磁盘，适合大量数据 脚本运行范围 background 浏览器打开后运行, 会一直存在于后台, 因此开发时更改后必须⌘+R重新加载 content_scripts 在网页加载后运行 html内导入的脚本 运行于该html页面, 例如: option页面和popup页面 Note: popup.js 于background.js 是可以进行共通的.使用var BG = chrome.extension.getBackgroundPage(); BG便是background.js的window对象 Action 入口 地址栏右侧图标外 browser_action 可显示badge 右键菜单 chrome.contextMenus 可在background中创建 地址栏右侧图标内外 page_action 新版的已更改显示在外围 PageAction API 多功能框 omnibox 对地址框进行监听 overrides 如, 管理书签/历史记录/新标签页等 (一个扩展只能替换一个页面) 桌面提醒 webkitNotifications.createNotification 权限 相当一部分Chrome API 使用需要在Manifest申明权限 页面间通信 popup 与 background 通信 使用上面提到的共通的特性。 使用 chrome.extension.onMessage.addListener进行通信监听 与 使用chrome.extension.sendMessage进行触发 option 与 (popup 或者 background) 通信 使用 chrome.extension.onMessage.addListener进行通信监听 与 使用chrome.extension.sendMessage进行触发 (popup 或者 background) 与 option 通信 使用 chrome.extension.onMessage.addListener进行通信监听, 触发方式比较麻烦, 查看以下例子:12345678chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function (tabs) &#123; if (!!tabs &amp;&amp; tabs.length &gt; 0) &#123; chrome.tabs.sendMessage(tabs[0].id, &#123; //message.. &#125;, callback); &#125; &#125;); i18 CSS __MSG_@@key JS chrome.i18n.getMessage(‘key’); 关于打包 &amp; 发布 扩展程序中进行打包，生成.crx(扩展程序) &amp; .pem(秘钥重要) 前往Chrome 开发者中心 认证需支付5美元用于认证 把.pem更名为key.pem并放入源码文件夹中，打包为.zip文件 上传 并编辑 (必填 (扩展描述、ICON(128x128)、扩展截图(1280x800 or 640x400)、类别、语言)) 如有遗漏或错误欢迎补充..","categories":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://hocg.in/tags/HTML5/"},{"name":"Chrome","slug":"Chrome","permalink":"https://hocg.in/tags/Chrome/"}],"keywords":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}]},{"title":"关于log4j报错","slug":"关于log4j报错","date":"2017-01-16T00:09:27.000Z","updated":"2017-02-04T05:57:15.000Z","comments":true,"path":"2017/01/16/关于log4j报错/","link":"","permalink":"https://hocg.in/2017/01/16/关于log4j报错/","excerpt":"Java开发中经常遇到日志冲突或者异常, 彻底的来此追根究底.","text":"Java开发中经常遇到日志冲突或者异常, 彻底的来此追根究底. 日志历史 log4j JCL + log4j SLF4J slf4j-XXX-version.jar [XXX指代log4j12, jdk14, jcl, nop 等] slf4j-api v1 log4j 早期直接实现日志打印v2 JCL + log4j 动态绑定, 面向JCL 接口实现的log4jv3 slf4j-api 提供 SLF4J接口 面向对象编程slf4j-XXX-version.jar 对接口和指定XXX种类日志的具体实现 slf4j 举例jar log4j-over-slf4j.jar 把log4j转为slf4j slf4j-log4j12.jar 以slf4j标准实现的log4j12 XXX-over-slf4j.jar 把日志重定向到slf4j eg.jcl-over-slf4j.jar 总结即.Component | | log to Apache Commons Logging V jcl-over-slf4j.jar — (redirect) —&gt; SLF4j —&gt; slf4j-log4j12-version.jar —&gt; log4j.jar —&gt; 输出日志解释:JCL实现的重定向为SLF4J日志形式, 然后SLF4J转为Log4j12输出!","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://hocg.in/tags/JAVA/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"Redis 相关","slug":"Redis-相关","date":"2016-10-20T01:11:48.000Z","updated":"2017-08-24T09:48:34.000Z","comments":true,"path":"2016/10/20/Redis-相关/","link":"","permalink":"https://hocg.in/2016/10/20/Redis-相关/","excerpt":"Redis 的部署和部位设计的实践, 还有常见问题的梳理! 💪","text":"Redis 的部署和部位设计的实践, 还有常见问题的梳理! 💪 前言官网 详情默认项 端口 6379 目录结构redis-3.2.4/|– redis.conf redis配置文件-- src编译后目录|-- redis-server启动bit文件`-- redis-cli终端bit文件` 安装 以下操作均在/opt1234567# 下载wget http://download.redis.io/releases/redis-3.2.4.tar.gz# 解压tar -zxvf redis-3.2.4.tar.gzcd redis-3.2.4# 编译， 生成`src`目录make 指令 以下操作均在/opt1234# 默认配置运行./redis-3.2.4/src/redis-server# 指定配置文件运行./redis-3.2.4/src/redis-server [config file] 疑问？ 如何使redis后台运行? 更改配置文件, 找到daemonize字段,更改no为yes, 重启redis 切记！要指定配置文件 如何更改redis默认6379端口? 更改配置文件, 找到port字段,更改为指定端口, 重启redis 切记！要指定配置文件 如何设置redis的验证密码? 更改配置文件, 找到requirepass字段, 设置相应的验证密码, 重启redis 切记！要指定配置文件由于增加了验证密码，因此客户端连接命令为redis-cli –a [upassword]","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Redis","slug":"Redis","permalink":"https://hocg.in/tags/Redis/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Ubuntu 下的 Oh My ZSH!","slug":"Ubuntu下的OhMyZSH!","date":"2016-09-30T08:18:09.000Z","updated":"2017-09-22T12:48:41.000Z","comments":true,"path":"2016/09/30/Ubuntu下的OhMyZSH!/","link":"","permalink":"https://hocg.in/2016/09/30/Ubuntu下的OhMyZSH!/","excerpt":"号称终极shell :)","text":"号称终极shell :) 前言什么是zsh？shell的一种,cat /etc/shells查看当前系统支持的shell 相关Link为什么说 zsh 是 shell 中的极品？ 环境OS: Ubuntu 16.04 x86_64 目录结构 ~/.zshrc 文件zsh配置文件 可用来更改Theme 加载Plugin ~/.oh-my-zsh oh-my-zsh目录 安装12345678910# 安装zsh$ sudo apt-get install zsh# 安装oh-my-zsh$ sudo apt-get install wget git$ wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh# 替换zsh为系统shell$ chsh -s /bin/zsh# 退出&amp;重新登入$ exit# 查看是否成功 配置文件zsh.config 注意 需更改.oh-my-zsh的目录 插件介绍 git;处于git项目下出现提示 autojump; 目录自动提示, 需要Linux 额外安装 12# ~/.bashrc 追加[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh git;处于git项目下出现提示 zsh-syntax-highlighting;高亮可用命令 12$ git clone git://github.com/jimmijj/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlightingplugins=(zsh-syntax-highlighting) colored-man-pages; 帮助文档高亮 colorize;更多代码高亮 copydir; 整个目录拷贝 command-not-found;命令行智能提示 history;查看输入历史 z; autojump同类 主题 ys 小技巧 转换路径时可以省去cd命令，直接输入路径即可 d 可以查看访问过的路径，然后输入数字就可以直接切换 输入不完整的路径/文件/命令，按下tab键可以出现提示，再按tab则可以实现路径补全 普通命令使用两次tab可进入选择模式， ctrl+f/b/n/p 可以向前后左右切换 kill + tab 强强强 alias -s xx=’xxx’ 快捷配置 相关设置 cat 代码高亮123pip install Pygments# 增加以下alias# alias ccat='pygmentize -g' 后续Oh My ZSH!","categories":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Oh My ZSH","slug":"Oh-My-ZSH","permalink":"https://hocg.in/tags/Oh-My-ZSH/"}],"keywords":[{"name":"IDE","slug":"IDE","permalink":"https://hocg.in/categories/IDE/"}]},{"title":"Glup 自动化构建工具","slug":"Glup-自动化构建工具","date":"2016-09-20T00:10:29.000Z","updated":"2017-09-22T12:55:01.000Z","comments":true,"path":"2016/09/20/Glup-自动化构建工具/","link":"","permalink":"https://hocg.in/2016/09/20/Glup-自动化构建工具/","excerpt":"Gulp.js 是一个自动化构建工具 😜","text":"Gulp.js 是一个自动化构建工具 😜 来源Glup 整合 Glup Glup用自动化构建工具增强你的工作流程！ 安装12$ npm install gulp -g$ npm install gulp --save-dev 插件 编译Sass (gulp-ruby-sass) Autoprefixer (gulp-autoprefixer) 缩小化(minify)CSS (gulp-minify-css) JSHint (gulp-jshint) 拼接 (gulp-concat) 丑化(Uglify) (gulp-uglify) 图片压缩 (gulp-imagemin) 即时重整(LiveReload) (gulp-livereload) 清理档案 (gulp-clean) 图片快取，只有更改过得图片会进行压缩 (gulp-cache) 更动通知 (gulp-notify)1$ npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-clean gulp-notify gulp-rename gulp-livereload gulp-cache --save-dev","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hocg.in/tags/NodeJS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"Ngrok使用指南","slug":"Ngrok使用指南","date":"2016-08-30T23:15:24.000Z","updated":"2017-02-04T05:39:31.000Z","comments":true,"path":"2016/08/31/Ngrok使用指南/","link":"","permalink":"https://hocg.in/2016/08/31/Ngrok使用指南/","excerpt":"Ngrok 是一款内部端口转发，对于微信类似的开发很有用的😆可参照墙内(花生壳 or nat123)","text":"Ngrok 是一款内部端口转发，对于微信类似的开发很有用的😆可参照墙内(花生壳 or nat123) 概述编译环境:Go 1.4.1 强烈建议根域名: web.hocg.in,即生成的域名为*.web.hocg.in文件结构:ngrok ├── bin │ └── ngrok.cfg ├── client.sh ├── code.sh └── server.sh部署环境:服务器OS: Ubuntu-15客户端OS: Ubuntu-16 安装环境依赖及源码下载 以下命令根目录统一在/opt 12345# 环境依赖sudo apt-get install build-essential golang mercurial git# 获取 ngrok 源码git clone https://github.com/tutumcloud/ngrok.git ngrokcd ngrok 生成证书 &amp;&amp; 编译 以下命令根目录统一在/opt/ngrok code.sh文件 生成证书 &amp;&amp; 编译服务端DOMAIN 为配置的根域名, 用于签名. 1234567891011121314151617181920212223#!/bin/bashecho \"开始清除..\"rm -rf assets/client/tls/ngrokroot.crtrm -rf assets/server/tls/snakeoil.crtrm -rf assets/server/tls/snakeoil.keyrm -rf device.*rm -rf rootCA.*DOMAIN=web.hocg.inecho \"设置域名为[*.$DOMAIN]\"echo \"开始生成秘钥..\"openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$DOMAIN\" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj \"/CN=$DOMAIN\" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000echo \"开始迁移秘钥..\"cp -rf rootCA.pem assets/client/tls/ngrokroot.crtcp -rf device.crt assets/server/tls/snakeoil.crtcp -rf device.key assets/server/tls/snakeoil.keyecho \"开始编译..\"make release-server 客户端 前置条件: Go需先增加对这些平台交叉编译的支持 Windowsgo的src目录 1GOOS=windows GOARCH=amd64 ./make.bash nginx目录,编译1GOOS=windows GOARCH=amd64 make release-client macOSgo的src目录 1GOOS=darwin GOARCH=amd64 ./make.bash nginx目录,编译1GOOS=darwin GOARCH=amd64 make release-client Linuxnginx目录,编译1make release-client 配置文件ngrok.cfg文件 server_addr 为配置的根域名， 4443为默认端口 12server_addr: web.hocg.in:4443trust_host_root_certs: false 运行文件server.sh文件 服务器运行DOMAIN 为配置的根域名.注释的那一句用于后台运行 1234567#!/bin/bash# $1 HTTP# $2 HTTPSkillall ngrokdDOMAIN=web.hocg.in# nohup ./bin/ngrokd -domain=\"$DOMAIN\" -httpAddr=\":$1\" -httpsAddr=\":$2\" &gt;/tmp/ngrok.log 2&gt;&amp;1 &amp;./bin/ngrokd -domain=\"$DOMAIN\" -httpAddr=\":$1\" -httpsAddr=\":$2\" client.sh文件 客户端运行, default:linux具体环境修改具体内容 1234#!/bin/bash# $1 Port# $2 domain./bin/ngrok -subdomain $2 -proto=http -config=./bin/ngrok.cfg $1 使用 若需变更域名, 需修改code.sh的DOMAIN、server.sh的DOMAIN与./bin/ngrok.cfg的server_addr 编译1sh code.sh 成功 检查ngrok/bin文件夹是否存在ngrok and ngrokd 服务端1sh server.sh 8888 9999 客户端1sh client.sh 8080 dm 检验访问:http://dm.web.hocg.in:8888 重要关于域名解析eg. *.web.hocg.in路径解析需配置*.web and web 两个A记录 关于签名最好在同一环境进行服务端和客户端的编译 小技巧 如何让服务端的ngrok后台运行 正常的nohup或&amp;是无法使ngrok后台运行的需使用screen 123456789# 安装\\# apt-get install screen# 使用screen -S [命名] [需放入后台的命令]# 使用 ctrl+A+D 让其运行在后台# 查看screen 后台进程screen -ls# 重新连接后台进程screen -r [进程id] 可能遇到的异常 Go-1.2.1语言版本不支持go version12345# github.com/gorilla/websocketsrc/github.com/gorilla/websocket/client.go:361: unknown tls.Config field 'GetCertificate' in struct literalsrc/github.com/gorilla/websocket/client.go:370: unknown tls.Config field 'ClientSessionCache' in struct literalsrc/github.com/gorilla/websocket/client.go:373: unknown tls.Config field 'CurvePreferences' in struct literalmake: *** [client] Error 2 官方Go-64的安装 Go编译器找不到go-bindata123GOOS=\"\" GOARCH=\"\" go get github.com/jteeuwen/go-bindata/go-bindata/bin/sh: 1: go: not foundmake: *** [bin/go-bindata] Error 127 请注意配置好GOROOT和GOPATH GOROOT为安装GO的目录GOPATH自定义一个GO插件下载目录 执行以下shell下载插件 1go get -u github.com/jteeuwen/go-bindata/... END:)","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Ngrok","slug":"Ngrok","permalink":"https://hocg.in/tags/Ngrok/"},{"name":"Tip","slug":"Tip","permalink":"https://hocg.in/tags/Tip/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Nexus 入门","slug":"Nexus入门","date":"2016-08-24T11:03:01.000Z","updated":"2016-10-26T09:01:49.000Z","comments":true,"path":"2016/08/24/Nexus入门/","link":"","permalink":"https://hocg.in/2016/08/24/Nexus入门/","excerpt":"适合nexus入门，不是手机，不是手机，不是手机 ．．ｏ（╯□╰）ｏ","text":"适合nexus入门，不是手机，不是手机，不是手机 ．．ｏ（╯□╰）ｏ 环境 Ubuntu-14.04.1 jdk1.8.0_102 nexus-2.12.0-01|官网 域名:nexus.hocg.in 前置条件 安装完jdk并配置好环境变量 eg: java查看是否成功 安装温馨提示: 以下操作都是在/opt目录下 下载&amp;解压123456# 下载wget https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.12.0-01-bundle.tar.gz# 解压tar -zxvf nexus-2.12.0-01-bundle.tar.gz# 清理rm -rf *.gz 文件/目录详解 nexus-2.12.0-01 程序目录 sonatype-work 仓库目录(内包含仓库配置及jar包仓库) 基本操作1./nexus-2.12.0-01/bin/nexus &#123; console | start | stop | restart | status | dump &#125; 访问 http://nexus.hocg.in:8081/nexus 默认账号:admin 默认密码: admin123 如何使用Maven 中配置仓库1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://nexus.hocg.in:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 问题如何修改默认8081端口12vim /opt/nexus-2.12.0-01/conf/nexus.properties# 修改application-port=8081项 如何创建用户登陆系统后，左侧Security &gt; Users中创建 如何使用构建账号修改Settings.xml文件 (Maven)1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus.hocg.in&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 如何修改用户密码登陆系统后，顶部点击用户名 &gt; Profile中修改 如何建立与中央仓库的索引 Note: Nexus会自动建立任务计划,一般远程仓库都比较大，构建会比较多，因此索引文件会很大，请确保磁盘大小充足. 可能出现的报错 1 WARNING - NOT RECOMMENDED TO RUN AS ROOT , 原因是提醒你是否确认用root用户运行12345678\\# ./nexus-2.12.0-01/bin/nexus restart****************************************WARNING - NOT RECOMMENDED TO RUN AS ROOT****************************************Stopping Nexus OSS...Nexus OSS was not running.Starting Nexus OSS...Started Nexus OSS. 解决:1234567891011vim ./nexus-2.12.0-01/bin/nexus# 加入系统变量vi /etc/profile# 加入export RUN_AS_USER=root# 修改RUN_AS_USER=root# 启动./nexus-2.12.0-01/bin/nexus start# 查看是否启动成功./nexus-2.12.0-01/bin/nexus status# 稍等几分钟再访问","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Nexus","slug":"Nexus","permalink":"https://hocg.in/tags/Nexus/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"Android L 及以上版本Rom包中提取apk","slug":"Android-L-及以上版本Rom包中提取apk","date":"2016-08-07T11:19:29.000Z","updated":"2018-05-05T17:58:03.000Z","comments":true,"path":"2016/08/07/Android-L-及以上版本Rom包中提取apk/","link":"","permalink":"https://hocg.in/2016/08/07/Android-L-及以上版本Rom包中提取apk/","excerpt":"提取想要的apk， 例如CM ROM包中的含天气的时钟不错！","text":"提取想要的apk， 例如CM ROM包中的含天气的时钟不错！ 以往版本 Android Rom包只需解压后，取出system包即可取出内部apk Now 解压后可以发现，文件发生了改变并且system.new.dat此文件是不支持直接解压的。 环境系统: win10工具: 下载 环境自备 操作步骤 普通方式解压ROM 运行下载工具中.bat文件Extractor.bat 根据提示选择1，并复制system.new.dat, system.transfer.list，file_contexts三个文件到bat文件所在目录 按任意键继续 完成后可以得到一个system文件夹 嘿嘿嘿.. 问题! 有可能在你安装apk的时候出现应用未安装的情况 可以尝试重新对apk进行签名 检查是否已经安装过该apk End","categories":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/tags/Android/"},{"name":"手机","slug":"手机","permalink":"https://hocg.in/tags/手机/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"https://hocg.in/categories/Android/"}]},{"title":"模块设计之对接同步订单模块","slug":"模块设计之对接同步订单模块","date":"2016-08-02T02:47:06.000Z","updated":"2018-05-05T07:43:59.744Z","comments":true,"path":"2016/08/02/模块设计之对接同步订单模块/","link":"","permalink":"https://hocg.in/2016/08/02/模块设计之对接同步订单模块/","excerpt":"实习期间设计的对接同步订单的某块, 缅怀..设计日期(2016.6)","text":"实习期间设计的对接同步订单的某块, 缅怀..设计日期(2016.6) 前言 #对接同步订单模块# 该部分是我入职后自主设计的一个模块，因为初期预计对接5家平台的订单，并考虑到后期可能对接更多平台和平台订单数量等，所以扩展性和性能方面是很值得深思的问题。 开发周期 (20day) 前期需求的多次变更，大大的浪费了开发周期. 库表设计 接口整理和整合设计(主要是对接平台的接口整合等) 代码编写 业务流程图表 商品表,存储商品信息, 主要配合方案匹配 授权表,存储用户授权信息，主要用于token管理 平台配置表,存储平台key信息 方案表,已存在，存储方案信息 v1版思路图 业务图 原先，该部分设计是不考虑对订单数据进行缓存处理的，但后期需求多次变更被迫进行数据缓存，因此再原先的基础上建立了线程池并对同步订单部分进行异步线程处理，因此增加了一张订单缓存表和事件队列表。 v2版思路图 业务图 后面又对缓存表进行了数据去重防止表数据爆炸性增长。 总结 把公共抽离出来，中间新增转化层可以很好的解决代码复用的问题.","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"设计思路","slug":"设计思路","permalink":"https://hocg.in/tags/设计思路/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"模块设计之消息模块","slug":"模块设计之消息模块","date":"2016-07-30T11:25:56.000Z","updated":"2018-05-05T07:44:06.607Z","comments":true,"path":"2016/07/30/模块设计之消息模块/","link":"","permalink":"https://hocg.in/2016/07/30/模块设计之消息模块/","excerpt":"新手上路，小心撞车..","text":"新手上路，小心撞车.. 前言 #消息模块# 这是我刚入职时所接触的第一个模块，也算是比较大的模块了。这个模块的业务是负责整个项目所有的消息出入口，包含短信发送，APP推送，邮件发送以及前后端人员站内消息。当时设计的时候需求架构比较简单而且时间紧迫(π__π)，没有从根本理清业务和功能后期存在的扩展。因此，这篇文章是记录当时架构的思路和需要改善的地方。 开发周期 (10day) 库表设计 接口整理和整合设计(短信&amp;友盟&amp;邮件等) 代码编写 业务流程图表 消息记录表, 主要负责消息出入口记录 事件触发表, 主要对消息进行控制，例如: 触发订单变更推送到用户/运营人员 and so on 消息状态表, 主要负责消息发送的状态，包含定时发送，撤销发送 and so on 图 类流程图 如图，此模式主要是利用工厂模式, 提供多种消息通道实例，由不同的消息通道对自身通道消息进行处理，类似于把西瓜，牛肉，白菜等送入不同的工厂进行加工，但是又由食品质量控制中心对其进行记录和检验。 优点: 后期便于扩展更多的通道模式缺点: 各个模式是靠类型区别的，不便于进行细节化处理(例如，对某部分APP推送进行定制化，进入某个Activity等细节化定制) 进一步优化类流程图 使用Route进行更细节的定制化处理更多实战，推荐 图 囧，单看图可能细分不出两者的差别，附上一段代码实例 123456789101112131415// 路由规则初始化，用于定义匹配规则NoticeRouter router = new NoticeRouter();route.rule() .noticeType(Notice.SMS) // ... 更多细节规则匹配 .handler(smsHandler) .end() .rule() .noticeType(Notice.EMail) // ... 更多细节规则匹配 .handler(emailHandler) .end()// 将通知实体通知路由处理router.route(message) 总结 充分考虑后期业务需求 (就算非必须的业务需求) 不要妄想需求是恒久不变的，需求=小三，扩展=真爱","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"设计思路","slug":"设计思路","permalink":"https://hocg.in/tags/设计思路/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"Mac的使用","slug":"Mac-使用","date":"2016-07-02T02:47:06.000Z","updated":"2016-08-27T05:29:43.000Z","comments":true,"path":"2016/07/02/Mac-使用/","link":"","permalink":"https://hocg.in/2016/07/02/Mac-使用/","excerpt":"留坑，刚刚起步，梳理中ing。","text":"留坑，刚刚起步，梳理中ing。 小技巧 在Dock 隐藏 iTerm2隐藏:1/usr/libexec/PlistBuddy -c \"Add :LSUIElement bool true\" /Applications/iTerm.app/Contents/Info.plist 显示:1/usr/libexec/PlistBuddy -c \"Delete :LSUIElement\" /Applications/iTerm.app/Contents/Info.plist","categories":[{"name":"OS","slug":"OS","permalink":"https://hocg.in/categories/OS/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Mac","slug":"Mac","permalink":"https://hocg.in/tags/Mac/"}],"keywords":[{"name":"OS","slug":"OS","permalink":"https://hocg.in/categories/OS/"}]},{"title":"谈JVM，各种过程","slug":"谈JVM-各种过程","date":"2016-06-12T11:37:49.000Z","updated":"2016-08-27T05:35:49.000Z","comments":true,"path":"2016/06/12/谈JVM-各种过程/","link":"","permalink":"https://hocg.in/2016/06/12/谈JVM-各种过程/","excerpt":"谈谈JVM 各种过程， XMind等我整理一下，稍后贴出 囧～欢迎指教..update: 2016-08-03 14:44:12 更新了图","text":"谈谈JVM 各种过程， XMind等我整理一下，稍后贴出 囧～欢迎指教..update: 2016-08-03 14:44:12 更新了图 总思路编译过程 -&gt; 运行过程[类加载器过程(类的装载过程) -&gt; 执行过程] 图 编译过程.java文件 -javac编译-&gt; .class文件 {-JIT编译(转化+优化)-&gt; 本地方法}[执行过程，当方法执行频率高] 图 运行过程类加载器 -&gt; (执行引擎 -&gt; 本地库接口)[Java 运行时数据区] -&gt; 本地方法库 图 类加载器过程[启动]类加载器(JNI) -&gt; [扩展]类加载器 -&gt; [系统]类加载器 -&gt; [自定义]类加载器 图 类装载过程加载文件到JVM内存 -&gt; (校验语言规范 -&gt; 分配结构存储类的信息 -&gt; 该类常量池中符号更改为直接引用)[Linking] -&gt; 类初始化 图 执行引擎执行过程(逐行读取指令)Thread启动 -生成-&gt; JVM栈 -执行方法-&gt; 压入栈帧(包含 局部变量数组&amp;操作数栈&amp;运行时常量池) -&gt; 逐行读取指令&amp;&amp;解释(JVM栈帧 程序计数器存放下一条指令) -&gt; {JIT(转化+优化)-&gt; 本地方法}[当方法执行频率高] -执行&amp;运算-&gt; 结果(存放 操作数栈中) -&gt; 推出栈帧 图 Java 运行时数据区(贯穿整个执行过程)共享型数据区：方法区(含运行时常量池[存放方法&amp;变量的实际地址])、堆(存放对象实例)隔离型数据区：JVM 栈、本地方法栈(JNI)、程序计数器 图","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://hocg.in/tags/JVM/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"谈JVM，字节码","slug":"谈JVM-字节码","date":"2016-06-12T11:37:49.000Z","updated":"2016-08-27T05:35:58.000Z","comments":true,"path":"2016/06/12/谈JVM-字节码/","link":"","permalink":"https://hocg.in/2016/06/12/谈JVM-字节码/","excerpt":"谈谈JVM，最近在研究破解jar，有这方面经验的麻烦指导一下思路..","text":"谈谈JVM，最近在研究破解jar，有这方面经验的麻烦指导一下思路.. 参考参考1指令整理 常用指令123# 反编译查看`类文件`所有信息javap -verbose [class] 局部变量类型 特殊字符表示 类型 描述 c char char类型 i int int类型 l long long类型 s short short类型 b byte byte类型 f float float类型 z boolean 布尔类型 a reference 引用 方法信息12345L1 LOCALVARIABLE this LMain; L0 L1 0 LOCALVARIABLE a I L0 L1 1 MAXSTACK = 0 MAXLOCALS = 2 局部变量参数 LOCALVARIABLE局部表大小 MAXLOCALS操作数栈大小 MAXSTACK 指令运算指令 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 加法指令:iadd,ladd,fadd,dadd 减法指令:isub,lsub,fsub,dsub 乘法指令:imul,lmul,fmul,dmul 除法指令:idiv,ldiv,fdiv,ddiv 求余指令:irem,lrem,frem,drem 取反指令:ineg,leng,fneg,dneg 位移指令:ishl,ishr,iushr,lshl,lshr,lushr 按位或指令:ior,lor 按位与指令:iand,land 按位异或指令:ixor,lxor 局部变量自增指令:iinc 比较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp 加载和存储指令 用于局部变量表和操作数栈之间来回传输 将一个局部变量加载到操作数栈的指令包括：iload,iload_&lt;n&gt;，lload、lload_&lt;n&gt;、float、fload_&lt;n&gt;、dload、dload_&lt;n&gt;，aload、aload_&lt;n&gt;。 将一个数值从操作数栈存储到局部变量标的指令：istore,istore_&lt;n&gt;,lstore,lstore_&lt;n&gt;,fstore,fstore_&lt;n&gt;,dstore,dstore_&lt;n&gt;,astore,astore_&lt;n&gt; 将常量加载到操作数栈的指令：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_&lt;i&gt;,lconst_&lt;l&gt;,fconst_&lt;f&gt;,dconst_&lt;d&gt; 局部变量表的访问索引指令:wide 一部分以尖括号结尾的指令代表了一组指令，如iload_&lt;i&gt;，代表了iload_0,iload_1等，这几组指令都是带有一个操作数的通用指令。 运算指令 对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶 加法指令:iadd,ladd,fadd,dadd 减法指令:isub,lsub,fsub,dsub 乘法指令:imul,lmul,fmul,dmul 除法指令:idiv,ldiv,fdiv,ddiv 求余指令:irem,lrem,frem,drem 取反指令:ineg,leng,fneg,dneg 位移指令:ishl,ishr,iushr,lshl,lshr,lushr 按位或指令:ior,lor 按位与指令:iand,land 按位异或指令:ixor,lxor 局部变量自增指令:iinc 比较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp 类型转换指令 将两种Java虚拟机数值类型相互转换 JVM支持宽化类型转换(小范围类型向大范围类型转换)： int类型到long,float,double类型 long类型到float,double类型 float到double类型 对象创建与操作 虽然类实例和数组都是对象，Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。 创建实例的指令:new 创建数组的指令:newarray,anewarray,multianewarray 访问字段指令:getfield,putfield,getstatic,putstatic 把数组元素加载到操作数栈指令:baload,caload,saload,iaload,laload,faload,daload,aaload 将操作数栈的数值存储到数组元素中执行:bastore,castore,castore,sastore,iastore,fastore,dastore,aastore 取数组长度指令:arraylength 检查实例类型指令:instanceof,checkcast 操作数栈管理指令直接操作操作数栈的指令：pop,pop2,dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2和swap NOTE: 压入栈顶(DUP)/弹出栈顶(POP) 控制转移指令 条件分支:ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnotnull,if_cmpeq,if_icmpne,if_icmlt,if_icmpgt等 复合条件分支:tableswitch,lookupswitch 无条件分支:goto,goto_w,jsr,jsr_w,ret 方法调用和返回指令 invokevirtual指令:调用对象的实例方法，根据对象的实际类型进行分派(虚拟机分派)。 invokeinterface指令:调用接口方法，在运行时搜索一个实现这个接口方法的对象，找出合适的方法进行调用。 invokespecial:调用需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法 invokestatic:调用类方法(static) 方法返回指令是根据返回值的类型区分的，包括ireturn(返回值是boolean,byte,char,short和int),lreturn,freturn,drturn和areturn，另外一个return供void方法，实例初始化方法，类和接口的类初始化i方法使用。 同步Eg:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// class version 52.0 (52)// access flags 0x21public class Main &#123; // compiled from: Main.java // access flags 0x11 public final I simpleField = 100 // access flags 0x0 &lt;init&gt;()V L0 LINENUMBER 12 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V L1 LINENUMBER 10 L1 ALOAD 0 BIPUSH 100 PUTFIELD Main.simpleField : I L2 LINENUMBER 13 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; BIPUSH 100 INVOKEVIRTUAL java/io/PrintStream.print (I)V L3 LINENUMBER 14 L3 RETURN L4 LOCALVARIABLE this LMain; L0 L4 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 16 L0 NEW Main DUP INVOKESPECIAL Main.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 17 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC &quot;--&gt;&quot; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L2 LINENUMBER 19 L2 RETURN L3 LOCALVARIABLE args [Ljava/lang/String; L0 L3 0 LOCALVARIABLE main LMain; L1 L3 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x21 public synchronized a(I)V throws java/lang/Exception L0 LINENUMBER 23 L0 RETURN L1 LOCALVARIABLE this LMain; L0 L1 0 LOCALVARIABLE a I L0 L1 1 MAXSTACK = 0 MAXLOCALS = 2&#125;","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hocg.in/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://hocg.in/tags/JVM/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"关于HTTPS","slug":"Https-签证","date":"2016-06-02T03:22:43.000Z","updated":"2017-02-04T05:37:54.000Z","comments":true,"path":"2016/06/02/Https-签证/","link":"","permalink":"https://hocg.in/2016/06/02/Https-签证/","excerpt":"这是一篇关于HTTPS的日常使用记录，例如:博客HTTPS化~来吧!年轻人!装逼HTTPS时代到了","text":"这是一篇关于HTTPS的日常使用记录，例如:博客HTTPS化~来吧!年轻人!装逼HTTPS时代到了 关于https什么是HTTPS ? 通俗的讲：隐私安全 GitHub page 使用https主要是使用 Kloudsec 申请账号，填入待解析的域名 把DNS解析转到该网站提供的地址 验证邮箱并填入GitHub page IP 开启相关服务 PROTECTION -&gt; SSL Encryption PLUGIN STORE成品NOTE: 2016年09月04日 发现Kloudsec已经倒闭了现在使用的是Cloudflare具体使用注册时有引导教程(需把域名解析服务器改为cloudflare的). 自己搭建的blog免费的使用 Startssl成品 TOMCAT 配置https环境 keytool 教程外网回调可尝试使用nat123 自己VPS使用HTTPSLet’s Encrypt :)","categories":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://hocg.in/tags/HTTPS/"}],"keywords":[{"name":"Server","slug":"Server","permalink":"https://hocg.in/categories/Server/"}]},{"title":"ES6 新特性","slug":"ES6-新特性","date":"2016-05-10T02:28:29.000Z","updated":"2017-09-22T12:53:46.000Z","comments":true,"path":"2016/05/10/ES6-新特性/","link":"","permalink":"https://hocg.in/2016/05/10/ES6-新特性/","excerpt":"NodeJS 的构建工具层出不穷，因此了解一下陈旧事物的进展。","text":"NodeJS 的构建工具层出不穷，因此了解一下陈旧事物的进展。 简介es6: ecmscript6 新特性 let 块级作用域, 注: es5中var声明的上全局范围的 const 常量 class 类 extends 继承 super 指代父类的实例 arrow functions 语法糖 12345/** * 语法: (参数) =&gt; &#123;执行代码&#125; **/function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; &#123; i + 1 &#125; //ES6 template string 模版字符 1234567/** * 语法: `$&#123;变量&#125;` **/ const name = 'hocgin'; console.log(`this is template strnig &lt;b&gt;$&#123;name&#125;&lt;/b&gt; `); destructuring 12345678let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: \"ken\", dog: \"lili\"&#125;let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default 默认值 12345678910/** * 语法: * function &lt;method name&gt;(param = &lt;default value&gt;) &#123; * ... * &#125; **/ function animal(type = 'cat')&#123; console.log(type) &#125; animal(); rest 可变参数 12345678910/** * 语法: * function &lt;method name&gt;(...params) &#123; * ... * &#125; **/ function animals(...types)&#123; console.log(types) &#125; animals('cat', 'dog', 'fish'); import export 模块设计 es6 把一个文件当作一个模块, 一个模块可export多个变量, 因此不同的export可对应不同的import 12345678910111213141516171819// 导出模块export animal// 导入模块 - 变量为 animalimport animal from './content'//--------------------// 导出模块export &#123;dog, cat&#125;// 导入模块 - 变量为 [dog, cat]import &#123;dog, cat&#125; from './content'//--------------------export &#123;dog, cat&#125;// 全部导入import * as animal from './content'// ormodule animal form './content'//--------------------// 默认导出, 一个模块只能使用 export default 一次export default 'dog dog'import animal from './content'","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hocg.in/tags/NodeJS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"绿化NodeJS for linux版","slug":"绿化nodejs-for-linux版","date":"2016-04-25T01:38:49.000Z","updated":"2016-08-27T05:35:32.000Z","comments":true,"path":"2016/04/25/绿化nodejs-for-linux版/","link":"","permalink":"https://hocg.in/2016/04/25/绿化nodejs-for-linux版/","excerpt":"起因，为了方便hexo发布博客，所以想把NodeJS绿化在U盘上..谁叫网上只有win版的呢！自己码起来～绿化 o(╯□╰)o","text":"起因，为了方便hexo发布博客，所以想把NodeJS绿化在U盘上..谁叫网上只有win版的呢！自己码起来～绿化 o(╯□╰)o 目录结构12345678Green4nodeJS├── hocgin.github.io // github博客目录├── node // nodejs基本目录│ ├── node-linux // nodejs源文件│ ├── cache // 创建一个空文件夹，即可│ ├── init-module // 创建一个空文件夹，即可│ └── userconfig // 创建一个空文件夹，即可└── init.sh // 初始化shell文件 *重要 初始化文件 主要是加载配置环境，初始化变量 init.sh 内容123456789101112131415161718#!/bin/bash# Author: hocgin@gmail.com# -------------Use--------------# source init.sh or . init.sh# ------------------------------NOW_PATH=$(cd \"$(dirname \"$0\")\"; pwd)NODE_NAME=\"node-linux\"NODE_HOME=$NOW_PATH\"/node/\"$NODE_NAMENODE_PATH=$NODE_HOME\"/bin\"NPM_PATH=$NODE_HOME\"/lib/node_modules/npm/bin\"sudo chmod +x -R $NPM_PATH\"/.\"export PATH=$PATH:$NODE_PATH:$NPM_PATH# \"/home/hocgin/.npmrc\"npm set userconfig $NOW_PATH\"/node/userconfig\"# \"/home/hocgin/.npm-init.js\"npm set init-module $NOW_PATH\"/node/init-module\"# \"/home/hocgin/.npm\"npm set cache $NOW_PATH\"/node/cache\" 修改 /node/node-linux/lib/node_modules/npm/bin/npm 文件12# NPM_CLI_JS=\"$basedir/node_modules/npm/bin/npm-cli.js\"NPM_CLI_JS=\"$basedir/npm-cli.js\" 完成 使用方法123456source init.sh# Or. init.shcd hocgin.github.io# 尽情hexo吧 注: 安装module时请加上 -g End","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://hocg.in/tags/NodeJS/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"使用Maven下载jar包 linux版","slug":"使用Maven下载jar包-linux版","date":"2016-04-25T01:38:49.000Z","updated":"2017-02-04T05:43:57.000Z","comments":true,"path":"2016/04/25/使用Maven下载jar包-linux版/","link":"","permalink":"https://hocg.in/2016/04/25/使用Maven下载jar包-linux版/","excerpt":"这只是学习Shell的小脚本, 练手工具罢了.. 折腾!折腾啊","text":"这只是学习Shell的小脚本, 练手工具罢了.. 折腾!折腾啊 目录结构123Green4nodeJS├── down.sh // 下载shell，o(╯□╰)o其实就是一条shell└── pom.xml // 正常maven配置 文件内容down.sh 内容：1234567891011#!/bin/sh# Author: hocgin@gmail.com# -------------Use--------------# sh down.sh# ------------------------------# 运行pom.xml 下载jarNOW_PATH=$(cd \"$(dirname \"$0\")\"; pwd)POM_XML=$NOW_PATH\"/pom.xml\"TARGET_DIR=$NOW_PATH\"/target\"mvn -f $POM_XML dependency:copy-dependenciessudo chmod -R 777 $TARGET_DIR pom.xml 内容： 正常maven的pom.xml内容 1234567891011121314151617181920&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 项目的名称 start --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;temp.download&lt;/groupId&gt; &lt;artifactId&gt;temp-download&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 项目的名称 end --&gt; &lt;dependencies&gt; &lt;!-- 要下载的jar start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20160212&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 要下载的jar end --&gt; &lt;/dependencies&gt;&lt;/project&gt; 完成 使用方法123456source init.sh# Or. init.shcd hocgin.github.io# 尽情hexo吧 End","categories":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Maven","slug":"Maven","permalink":"https://hocg.in/tags/Maven/"},{"name":"Shell","slug":"Shell","permalink":"https://hocg.in/tags/Shell/"}],"keywords":[{"name":"Coder","slug":"Coder","permalink":"https://hocg.in/categories/Coder/"}]},{"title":"hexo 功能扩展","slug":"hexo-功能扩展","date":"2016-03-26T05:44:28.000Z","updated":"2017-02-04T05:34:09.000Z","comments":true,"path":"2016/03/26/hexo-功能扩展/","link":"","permalink":"https://hocg.in/2016/03/26/hexo-功能扩展/","excerpt":"这是自己参照hexo进行私人订制的教程，也是实战的记录，感觉还不错，成品可参照本博客.. （如果我以后没换的话😶）","text":"这是自己参照hexo进行私人订制的教程，也是实战的记录，感觉还不错，成品可参照本博客.. （如果我以后没换的话😶） 须知站点目录: /主题目录: /themes/[主题名]主题配置文件: /themes/[主题名]/_config.yml站点配置文件: /_config.yml 添加微信公众号二维码首先，打开主题目录下的 layout/_macro/post.swig然后，找到节点footer加入以下代码1234567891011121314&lt;! -- 添加微信图标 start --&gt; &#123;% if theme.wechat_subscriber.enable %&#125; &#123;% if !is_home() %&#125; &lt;div class=\"hocgin-container\"&gt; &lt;div class=\"folder\"&gt; &lt;div class=\"paper\"&gt; &lt;img width=\"100%\" src=\"&#123;&#123; theme.wechat_subscriber.qcode &#125;&#125;\"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"hocgin-description\"&gt;&#123;&#123; theme.wechat_subscriber.description &#125;&#125;&lt;/div&gt; &#123;% endif %&#125; &#123;% endif %&#125;&lt;! -- 添加微信图标 end --&gt; 其次，到主题目录下的source/css创建文件夹_hocgin并在它之下创建css文件customize-hocgin.css以下是文件内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.hocgin-container *, *:before, *:after &#123; box-sizing: border-box;&#125;.hocgin-container &#123; position: relative; width: 100%; height: 100%;&#125;.hocgin-container &gt; .folder &#123; width: 220px; height: 180px; left: calc(50% - 110px); top: calc(70% - 90px); position: relative;&#125;.hocgin-container &gt; .folder &gt; .paper &#123; opacity: 1; position: absolute; overflow: hidden; width: 200px; height: 200px; top: calc(50% - 111px); left: calc(50% - 100px); transition: top 0.5s, opacity 0.4s; font-family: Verdana, Tahoma, sans-serif; font-size: 0.1em; padding: 1em; color: #644812; background-color: #fde1ab; -moz-box-shadow: 10px 10px rgba(0, 0, 0, 0.2); -webkit-box-shadow: 10px 10px rgba(0, 0, 0, 0.2); box-shadow: 10px 10px rgba(0, 0, 0, 0.2); -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125;.hocgin-container &gt; .folder:hover &gt; .paper &#123; top: calc(50% - 150px);&#125;.hocgin-container &gt; .folder.opened &gt; .paper &#123; top: calc(-250px); opacity: .9;&#125;.hocgin-description &#123; text-align: center; margin-top: 4px;&#125; 保存后，找到主题目录下source/css/main.styl(注：别的主题可能不一样) 追加12// --------------------------------------------------@import \"_hocgin/customize-hocgin.css\"; 最后，修改主题配置文件 追加12345# Customize args -- Hocginwechat_subscriber: enable: true qcode: [url] description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 效果http://hocg.in 底部加入打赏功能首先，打开主题目录下的 layout/_macro/post.swig然后，找到节点footer加入以下代码12345678910111213141516171819 &lt;! -- 添加打赏图标 start --&gt; &#123;% if theme.pay_money.enable %&#125; &#123;% if !is_home() %&#125; &lt;div class=\"hocgin-money\"&gt;&lt;div class=\"money-reward\"&gt; 赏 &lt;div class=\"money-pay\"&gt; &lt;img width=\"100%\" src=\"&#123;&#123; theme.pay_money.weixin_qcode &#125;&#125;\"/&gt; &lt;/div&gt; &lt;div class=\"money-pay\"&gt; &lt;img width=\"100%\" src=\"&#123;&#123; theme.pay_money.alipay_qcode &#125;&#125;\"/&gt; &lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;br/&gt; &#123;% endif %&#125; &#123;% endif %&#125; &lt;! -- 添加打赏图标 end --&gt; 其次，到主题目录下的source/css创建文件夹_hocgin并在它之下创建css文件money-customize-hocgin.css以下是文件内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.hocgin-money *, *:before, *:after &#123; box-sizing: border-box;&#125;.hocgin-money &gt; .money-reward &#123; font-size: 2.4rem; line-height: 4.6rem; display: block; width: 4.6rem; height: 4.6rem; margin: 0 auto; padding: 0; -webkit-user-select: none; text-align: center; vertical-align: middle; color: #fff; border: 1px solid #f1b60e; border-radius: 50%; background: #fccd60; background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #fccd60), color-stop(100%, #fbae12), color-stop(100%, #2989d8), color-stop(100%, #207cca)); background: -webkit-linear-gradient(top, #fccd60 0, #fbae12 100%, #2989d8 100%, #207cca 100%); background: linear-gradient(to bottom, #fccd60 0, #fbae12 100%, #2989d8 100%, #207cca 100%); position: relative;&#125;.hocgin-money &gt; .money-reward &gt; .money-pay &#123; position: absolute; overflow: hidden; width: 200px; height: 200px; visibility: hidden; top: calc(50% - 100px); left: calc(50% - 100px); opacity: 0; transition: top 0.5s, opacity 0.4s; font-family: Verdana, Tahoma, sans-serif; font-size: 0.1em; padding: 1em; color: #644812; background-color: #fff; -moz-box-shadow: 0 1px 1px 1px #efefef; -webkit-box-shadow: 0 1px 1px 1px #efefef; box-shadow: 0 1px 1px 1px #efefef; border: 1px solid #e6e6e6;&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay &#123; visibility: visible; opacity: 1; z-index: 10;&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay:nth-child(1) &#123; top: calc(50% - 250px);&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay:nth-child(2) &#123; top: calc(50% + 50px);&#125; 保存后，找到主题目录下source/css/main.styl(注：别的主题可能不一样) 追加12// --------------------------------------------------@import \"_hocgin/money-customize-hocgin.css\"; 最后，修改主题配置文件 追加12345# Customize args -- Hocginpay_money: enable: true weixin_qcode: http://7xs6lq.com1.z0.glb.clouddn.com/img/un/ali.pay.500.png alipay_qcode: http://7xs6lq.com1.z0.glb.clouddn.com/img/un/ali.pay.500.png 已知bug 因为没使用js(也不想使用)，安卓设备需要长按才能出现效果，而苹果设备无法显示效果，欢迎大家修复。┌|*´∀｀|┘ 效果http://hocg.in 防止百度转码主题目录下 \\layout\\_partials\\head.swig12&lt;meta http-equiv=”Cache-Control” content=”no-transform” /&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 添加搜索功能 2016年06月04日 安装hexo数据生成插件 Json格式的，有利于自主编写(暂时只介绍原生支持的，如果想自己编写下面的可以不用看) hexo-generator-json-content1$ npm i -S hexo-generator-json-content NexT 原生支持，不想折腾的可以使用 hexo-generator-search1$ npm install hexo-generator-search --save 站点配置文件 新增1234# Searchsearch: path: search.xml field: post OK！ 待续ing 结合服务器，实现自动部署 多说css美化","categories":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://hocg.in/tags/HTML5/"},{"name":"Hexo","slug":"Hexo","permalink":"https://hocg.in/tags/Hexo/"},{"name":"CSS3","slug":"CSS3","permalink":"https://hocg.in/tags/CSS3/"}],"keywords":[{"name":"Web","slug":"Web","permalink":"https://hocg.in/categories/Web/"}]},{"title":"安装完Ubuntu后,我该做什么","slug":"安装完Ubuntu后-我该做什么","date":"2016-03-20T06:34:20.000Z","updated":"2017-03-09T11:45:14.000Z","comments":true,"path":"2016/03/20/安装完Ubuntu后-我该做什么/","link":"","permalink":"https://hocg.in/2016/03/20/安装完Ubuntu后-我该做什么/","excerpt":"这是一篇我对Ubuntu日常使用和优化的整理，也是一篇借鉴前人的文章，还有一些可能会遇到的疑难杂病的“偏方”，希望对你有帮助:)update: 新增undistract-me终端命令完成提醒插件","text":"这是一篇我对Ubuntu日常使用和优化的整理，也是一篇借鉴前人的文章，还有一些可能会遇到的疑难杂病的“偏方”，希望对你有帮助:)update: 新增undistract-me终端命令完成提醒插件 yuan获取官方列表： http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8网易163： http://mirrors.163.com/.help/ubuntu.html 移除 删除libreoffice 1sudo apt-get remove libreoffice-common 删除Amazon的链接s 1sudo apt-get remove unity-webapps-common 删掉基本不用的自带软件 12sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-installsudo apt-get remove onboard deja-dup shang xia zuoyou 12sudo apt-get remove vim-commonsudo apt-get install vim 字体monaco苹果字体https://github.com/cstrap/monaco-font1curl -kL https://raw.github.com/cstrap/monaco-font/master/install-font-ubuntu.sh | bash consolas微软字体 Gnome3安装1.安装Gnome3桌面12345678910# 安装sudo add-apt-repository ppa:gnome3-team/gnome3sudo apt-get updatesudo apt-get install ppa-purgesudo ppa-purge ppa:gnome3-team/gnome3sudo apt-get dist-upgradesudo apt-get install gnome-themes-standard ubuntu-desktop gnome-shell# 删除sudo apt-get install ppa-purgesudo ppa-purge ppa:gnome3-team/gnome3 2.Gnome3系统下载 主题主题文件位置：~/.themes 或 /usr/share/themes 1.Paper1234# 下拉gitgit clone https://github.com/snwh/paper-gtk-theme.git# 运行安装脚本sh ./install-gtk-theme.sh 2.Numix-Circle 很赞 1234# 安装sudo apt-add-repository ppa:numix/ppasudo apt-get updatesudo apt-get install numix-icon-theme-circle 插件支持 gnome-tweak-tool Gnome3的调节软件可直接管理插件 1sudo apt-get install gnome-tweak-tool 插件下载网站: https://extensions.gnome.org/ 使用Chrome 插件 系统安装chrome-gnome-shell 1234sudo add-apt-repository ppa:ne0sight/chrome-gnome-shell# trustysudo apt-get updatesudo apt-get install chrome-gnome-shell 插件列表 名称 描述 推荐 Autohide battery 可以在电池充满的情况下隐藏电池图标 推荐 Battery status 可以显示当前电池电量以及可以使用的时间 推荐 Dash to dock 在屏幕左边显示一个快速启动条 推荐 Freon 显示当前磁盘，显卡，CPU等等温度 不推荐，推荐SysPeek Lock Keys 显示当前的 Num Lock, Caps Lock 的状态 推荐 Refesh wifi connections 在 wifi 列表上显示一个刷新图标 推荐 status title bar 讲状态条上的标题改为当前窗口的标题 推荐 Coverflow Alt-Tab 类似WIN 7切换特效 太显眼，不推荐 OpenWeather 天气预报 推荐 NetSpeed 显示网速 不推荐，推荐SysPeek system-monitor 显示当前系统信息 太显眼，不推荐 Dynamic Top Bar 在当前没有最大化窗口时使顶栏透明 推荐 Impatience Gnome Shell 动画提速 推荐 Better Volume Indicator 透过鼠标滚轮操作更便捷地调整音量 推荐 Media player indicator 显示音乐播放器的状态 推荐 Workspaces-to-dock 将工作区转变为一个可自动隐藏的停靠栏 推荐 Panel OSD 修改通知显示位置 推荐 Clipboard Indicator 剪贴板指示器 推荐 Caffeine 禁止自动挂起或锁屏 推荐 Transmission Daemon Indicator Transmission面板指示器 推荐，需要Transmission Daemon Icon Hider 显示/隐藏顶栏图标 推荐 Top Panel Workspace Scroll 在顶栏上滚动鼠标中键来快速切换工作区。在topbar按住shift+滚轮 推荐 Drop Down Terminal 终端快捷方式 推荐 Windows Blur Effects 给未激活的窗口添加模糊效果 不推荐 Modern Calc 功能齐全的计算器扩展 没找到 EasyScreenCast 录屏工具 推荐 Place status indicator 快速访问一些文件夹 推荐，没装上 Removable drive menu 显示连接到电脑的usb设备 推荐 User themes 用来启用自定义的shell主题 推荐，没装上 Workspace indicator 在顶栏显示当前示工作区的序号 推荐 touchpad-indicator 插入鼠标时自动使触摸板失效 推荐 壁纸1234567# 1.安装archiboldcurl -L -O http://archibold.io/sh/archiboldchmod +x archiboldsudo mv archibold /usr/bin# 2.执行archibold login-background [壁纸的位置] 此外还可以让桌面和锁屏界面使用动态壁纸，动态壁纸由一个xml文件构成，就像这样：12345678910111213141516171819202122232425262728293031323334&lt;background&gt; &lt;starttime&gt; &lt;year&gt;2011&lt;/year&gt; &lt;month&gt;11&lt;/month&gt; &lt;day&gt;24&lt;/day&gt; &lt;hour&gt;7&lt;/hour&gt; &lt;minute&gt;00&lt;/minute&gt; &lt;second&gt;00&lt;/second&gt; &lt;/starttime&gt; &lt;static&gt; &lt;duration&gt;3600.0&lt;/duration&gt; &lt;file&gt;picture1.jpg&lt;/file&gt; &lt;/static&gt; &lt;transition type=\"overlay\"&gt; &lt;duration&gt;18000.0&lt;/duration&gt; &lt;from&gt;picture1.jpg&lt;/from&gt; &lt;to&gt;/picture2.jpg&lt;/to&gt; &lt;/transition&gt; &lt;static&gt; &lt;duration&gt;18000.0&lt;/duration&gt; &lt;file&gt;picture2.jpg&lt;/file&gt; &lt;/static&gt; &lt;transition type=\"overlay\"&gt; &lt;duration&gt;21600.0&lt;/duration&gt; &lt;from&gt;picture2.jpg&lt;/from&gt; &lt;to&gt;picture1.jpg&lt;/to&gt; &lt;/transition&gt;&lt;/background&gt; 简单解释以下这个xml文件的含义： starttime：这个部分规定了壁纸切换起始时间，设置成过去的某个时间即可(设置成2020年就要等到2020年才会有效果)static：这个部分表示在duration规定的时间(以秒为单位)中壁纸都是file中给定的那张图片transition：这个部分表示在duration规定的时间内壁纸从from中的图片切换到to中的图片你可以添加任意多个static+transition的组合，只需要最后一个transition切换回最初的static那张图片就可以循环更换壁纸了。 那么如何启用这样的xml文件呢，单凭系统设置无法办到，我们需要使用dconf系统配置编辑器。首先打开dconf编辑器，展开org–gnome–desktop–background这一项，可以看到其中的picture-uri修这一项的默认值是file:///usr/share/backgrounds/gnome/adwaita-timed.xml，这个就是你刚装好桌面是的默认壁纸啦，将其改成你的xml文件就可以了。锁屏界面的壁纸更换方法也一样，只不过把org–gnome–desktop–background改成org–gnome–desktop–screensaver而已 软件安装指令安装 命令面板小提示 1234# 安装sudo apt updatesudo apt install python3-dev python3-pipsudo -H pip3 install thefuck 科学上网 Client-SS 123456789# 安装sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5# 安装 pipsudo pip install genpac# 下载自动翻墙列表genpac -p \"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" --output=\"~/Documents/autoproxy.pac\" --gfwlist-url=\"https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\" --user-rule-from=\"user-rules.txt\" 添加开机启动command：/usr/bin/ss-qt5 屏幕截图 Shutter 12345# 安装sudo apt-get install Shutter# 打开# 搜索 Shutter 音视频解码 ubuntu-restricted extras 12# 安装sudo apt-get install ubuntu-restricted-extras 终端命令执行完成提醒 1234567891011# 安装sudo apt-get install undistract-me# 配置vim ~/.bashrc# 新增如下两行# . /usr/share/undistract-me/long-running.bash# notify_when_long_running_commands_finish_install# 生效source ~/.bashrc# 测试sleep 11 GNOME MPV 代替VLC播放器 1234# 安装sudo add-apt-repository ppa:xuzhen666/gnome-mpvsudo apt-get updatesudo apt-get install gnome-mpv 视频播放 VLC播放器 123456# 安装sudo add-apt-repository ppa:videolan/master-dailysudo apt-get updatesudo apt-get install vlc# 使用# 搜索 vlc Grub引导 Grub Customizer可配置启动界面，启动项等 123456# 安装sudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get updatesudo apt-get install grub-customizer# 使用# 搜索 Grub Customizer Office WPS 12# 安装sudo apt-get install wps-office [小插件]指示器性能 SysPeek 1234# 安装sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get updatesudo apt-get install syspeeka Synapse 快速启动器 123sudo add-apt-repository ppa:synapse-core/testingsudo apt-get updatesudo apt-get install synapse Uget一款下载工具，配合 aria2 插件使用效果出色curl + area2 + axel 地址：参考 1234# 安装sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt-get updatesudo apt-get install uget redshift类似 f.lux 的屏幕色温调整工具 12# 安装sudo apt-get install redshift-gtk 添加开机启动command：redshift-gtk -l 39.92:116.46 -t 5500:4500 Go For It 一款整合了待办事项与计时器的生产力应用。 1234# 安装sudo add-apt-repository ppa:mank319/go-for-itsudo apt-get updatesudo apt-get install go-for-it Catfish 一款优雅迅捷的文件搜索工具12# 安装sudo apt-get install catfish 神级命令行软件 Tmux 说明1sudo apt-get install tmux cat代码高亮12# 安装pip install pygments 配置～/.bashrc加入alias cat=&#39;pygmentize -O style=monokai -f console256 -g&#39; 软件包安装系统管理 UbuntuTweak打开：搜索 Ubuntu Tweak同步软件 坚果云打开：搜索 Nutstore百度网盘桌面客户端 BCloud便签MarkDown编辑软件 HarooPad密码管理器 keepass2搜狗输入法有道词典VMware WorkstationChrome网易音乐数据库设计软件 DBdesigner4 - 问题1 听起来不错 Deluge Bittorrent 客户端 Nutty网络监测工具。 Synaptic 新立得软件包管理器 UNetbootin启动盘制作工具 Gpick拾色器。 gpaint 微软画图 ddm 驱动管理器 Navicat o(╯□╰)o 竟然是wine的 XMind 小技巧关闭系统检测报告12sudo gedit /etc/default/apport# 修改enabled=0 开机自动开启数字键1234567sudo apt-get install numlockxsudo vim /etc/gdm/Init/Default# -----------# 在文件最后exit 0的前面添加： if [ -x /usr/bin/numlockx ]; then numlockx on fi 重启即可 插入鼠标时自动使触摸板失效安装Touchpad Indicator (触摸板开关）123sudo add-apt-repository ppa:atareao/atareao sudo apt-get update sudo apt-get install touchpad-indicator 搜索 touchpad indicator 遇到显示俩个输入法图标情况有一定原因是自启项启动了一个 黑屏95% 是和显卡驱动有关 Chrome 每次打开都要求输入密码一、删除现在的密钥环 视图-&gt;根据密码环 在密码区会有一个“登录”为名字的密钥环，右击将其删除。二、添加新的密钥环 终端输入seahorse打开管理密钥环的软件，文件-&gt;新建-&gt;密码和密钥-&gt;输入名字(这里是以”chrome”为例)。密码设置为空 添加源安装后，not fount XX一、 试着访问该链接二、如果可以手动找到该路径，那便可以修改/etc/apt/source.list.d/目录下你添加的安装源文件例如1234vim /etc/apt/sources.list.d/sogoupinyin.list# 显示内容# deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main# 可修改链接部分。 网卡驱动 Realtek RTL8723AE 无线网卡驱动第一种(闭源驱动)： 1sudo apt-get install linux-firmware-nonfree 第二种(第三方驱动，PPA安装)： 123sudo add-apt-repository ppa:hanipouspilot/rtlwifisudo apt-get updatesudo apt-get install rtlwifi-new-dkms 当遇到产品无法输入中文的时候先尝试卸载ibus，如果还是不可以试试在xxx.sh的启动脚本中添加如下： 12XMODIFIERS=\"@im=fcitx\"export XMODIFIERS 到 123# ---------------------------------------------------------------------# Run the IDE.# --------------------------------------------------------------------- 之前。通用1sudo mv /usr/bin/ibus-daemon /usr/bin/ibus-daemon.fix 解决LC_CTYPE: cannot change locale (en_US.UTF-8) 错误12# 增加en_US.UTF-8locale-gen en_US.UTF-8 修复VMware故障，闪退 下载Uefi.priv、fix.sh、Uefi.der至于同一目录. 执行 1sh fix.sh","categories":[{"name":"OS","slug":"OS","permalink":"https://hocg.in/categories/OS/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://hocg.in/tags/Ubuntu/"},{"name":"Tips","slug":"Tips","permalink":"https://hocg.in/tags/Tips/"},{"name":"Gnome","slug":"Gnome","permalink":"https://hocg.in/tags/Gnome/"}],"keywords":[{"name":"OS","slug":"OS","permalink":"https://hocg.in/categories/OS/"}]},{"title":"hexo 使用小记","slug":"hexo-使用","date":"2016-03-15T13:31:42.000Z","updated":"2017-01-12T02:37:02.000Z","comments":true,"path":"2016/03/15/hexo-使用/","link":"","permalink":"https://hocg.in/2016/03/15/hexo-使用/","excerpt":"这是一篇关于如何使用hexo的收集Box &gt; 不定期更新吧！ update 2017年01月12日10:33:55","text":"这是一篇关于如何使用hexo的收集Box &gt; 不定期更新吧！ update 2017年01月12日10:33:55 参照 hexo 官方文档参照 next 主题参照 next 主题 for github参照 更多扩展使用 md文档头部 参数 描述 默认值 layout 布局 有哪些layout呢，请到 scaffolds 目录下查看，这些文件名称就是layout名称 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 description 添加本页描述 默认所有 photos 添加图片 hexo 基础命令1234567891011121314# 清除$ hexo clean# 上传 GitHub$ hexo deploy# 新建文章$ hexo new \"postName\"# 新建页面hexo new page \"pageName\"# 生成静态页面至public目录hexo generate# 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo server# 将.deploy目录部署到GitHubhexo deploy .md 扩展 扩大图片宽度 1&#123;% fi image-url, alt, title %&#125; 显示 更多按钮 123以上是摘要&lt;!--more--&gt;以下是余下全文 使用标签别名 1&#123;% cq %&#125; 标签别名 &#123;% endcq %&#125; 可能遇到的问题 当你发布的.md文件中携带逗号,(已知)，在多说评论插件中将无法识别评论条数(就是文章顶部那个) 借鉴办法：替换文件命名，将逗号已_或 分隔 换电脑后, 如何迁移？123456// 为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git --save// 为了建立RSS订阅，需要安装npm install hexo-generator-feed --save// 为了建立站点地图，需要安装npm install hexo-generator-sitemap --save 可能会遇到 ‘./build/Release/DTraceProviderBindings’] code: ‘MODULE_NOT_FOUND’ 1npm install hexo --no-optional End","categories":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://hocg.in/tags/Hexo/"}],"keywords":[{"name":"Other","slug":"Other","permalink":"https://hocg.in/categories/Other/"}]}]}