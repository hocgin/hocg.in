<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 下网络相关的命令]]></title>
    <url>%2F2019%2F04%2F01%2FLinux%20%E4%B8%8B%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux 下网络相关的命令 🔗Linux-Nettools vs Iproute2 net-toolsifconfig123456789101112131415161718192021222324enp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.8.23 netmask 255.255.255.0 broadcast 192.168.8.255 inet6 fe80::794c:57e0:a7ca:518e prefixlen 64 scopeid 0x20&lt;link&gt; ether 50:9a:4c:17:e9:da txqueuelen 1000 (Ethernet) RX packets 4412700 bytes 3603093632 (3.3 GiB) RX errors 0 dropped 20 overruns 0 frame 0 TX packets 1877167 bytes 507480177 (483.9 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 14009901 bytes 2441347518 (2.2 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 14009901 bytes 2441347518 (2.2 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0wlp3s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 ether 54:13:79:5b:c3:29 txqueuelen 1000 (Ethernet) RX packets 6 bytes 1296 (1.2 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 34 bytes 5037 (4.9 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 enp2s0: 网络设备号 flags=4163: 网络设备状态标识 mtu 1500: mtu inet 192.168.8.23 netmask 255.255.255.0 broadcast 192.168.8.255: IPv4 协议 inet6 fe80::794c:57e0:a7ca:518e: IPv6 协议 ether 50:9a:4c:17:e9:da TX: 发送/上行 RX: 接收/下行 packets 4412700: 包总数量 bytes 2441347518 (2.2 GiB): 流量大小 errors 0: 错误包数量 dropped 0: 丢包数量 overruns 0: 超时包数量 collisions 0: 冲突包数量 frame 0: 帧数量 txqueuelen 1000 (Ethernet): 存储传输数据缓存的大小 prefixlen 64 scopeid 0x20 route1234Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault 192.168.8.1 0.0.0.0 UG 100 0 0 enp2s0192.168.8.0 0.0.0.0 255.255.255.0 U 100 0 0 enp2s0 Genmask: 子网掩码 Destination: 目的地 Destination/Genmask 组成局域网 default = 0.0.0.0/0.0.0.0 Gateway: 网关 Flags: 网络标识 U (route is up): 路由启动状态 H (target is a host): 目标是主机 G (use gateway): 需要使用网关来传输 R (reinstate route for dynamic routing): D (dynamically installed by daemon or redirect): M (modified from routing daemon or redirect): ! (reject route): 拒绝/黑名单 Metric: 目标的距离 Ref: Use: 路线查找计数 Iface: 接收数据的网络接口 网络出口网卡 iproute2ip link 配置网络设备参数OSI 七层协议中, 二层相关信息eg. MTU, MAC, 开关…1234567891011121314151617181920212223242526272829303132333435363738ip link show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: enp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 50:9a:4c:17:e9:da brd ff:ff:ff:ff:ff:ff3: wlp3s0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DORMANT group default qlen 1000 link/ether 54:13:79:5b:c3:29 brd ff:ff:ff:ff:ff:ff# 显示状态详情ip -s link show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 RX: bytes packets errors dropped overrun mcast 2507975007 14838472 0 0 0 0 TX: bytes packets errors dropped carrier collsns 2507975007 14838472 0 0 0 0 2: enp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 50:9a:4c:17:e9:da brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 3657508487 4607298 0 23 0 154201 TX: bytes packets errors dropped carrier collsns 536627449 1943192 0 0 0 0 3: wlp3s0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN mode DORMANT group default qlen 1000 link/ether 54:13:79:5b:c3:29 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 1296 6 0 0 0 0 TX: bytes packets errors dropped carrier collsns 5037 34 0 0 0 0 # 操作特定网卡 eg. ip link set eth0 upip link set &#123;网络设备&#125; &#123;操作&#125;- 网络设备: eg. enp2s0 - 操作 - up: 开启 - down: 关闭 - address: Mac 地址`ff:ff:ff:ff:ff:ff` - name: 网络设备名称 - mtu: mtu值`1500` ip addr 配置网络相关信息OSI 七层协议中, 三层相关信息eg. 网关, 子网掩码.. 123456789101112131415161718192021222324252627281: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: enp2s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 50:9a:4c:17:e9:da brd ff:ff:ff:ff:ff:ff inet 192.168.8.23/24 brd 192.168.8.255 scope global noprefixroute enp2s0 valid_lft forever preferred_lft forever inet6 fe80::794c:57e0:a7ca:518e/64 scope link noprefixroute valid_lft forever preferred_lft forever3: wlp3s0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000 link/ether 54:13:79:5b:c3:29 brd ff:ff:ff:ff:ff:ff# 设定IP相关参数ip address &#123;add|del&#125; &#123;IP相关配置&#125; &#123;网络设备&#125; &#123;相关参数&#125;- add|del: 新增或删除- IP相关配置: eg. 192.168.8.23/24- 网络设备: eg. enp2s0- 相关参数: - broadcast: 广播地址, &quot;+&quot;为自动计算 - label: 別名别名 - scope: 作用域 - global - site - link - host lo: 网卡label. : 网络设备状态标识 BROADCAST, MULTICAST: 可以发送广播, 可以发送多播包 LOOPBACK: 本地环回 UP: 网络设备状态 LOWER_UP: 已连线 mtu 65536: 最大传输单元 qdisc pfifo_fast: 排队规则. noqueue pfifo_fast group default: 所在组. inet 127.0.0.1/8: IPv4 地址及子网掩码 inet6 fe80::794c:57e0:a7ca:518e/64: IPv6 地址及子网掩码 brd ff:ff:ff:ff:ff:ff: 广播地址 scope global: 作用域. global: 允许所有来源 site: 仅IPv6, 允许仅本机连接 link: 仅允许自我连接 host: 仅允许本主机内部连接 noprefixroute enp2s0 preferred_lft forever: valid_lft forever: 有效期限 qlen 1000 ip route 路由相关设置 1234567891011ip routedefault via 192.168.8.1 dev enp2s0 proto static metric 100 192.168.8.0/24 dev enp2s0 proto kernel scope link src 192.168.8.23 metric 100# 设定route相关参数ip route &#123;add|del&#125; &#123;IP|网络&#125; &#123;via 网关&#125; &#123;网络设备&#125;- add|del: 新增或删除- IP|网络: eg. IP 或 192.168.8.23/24- 网关: 指定出口网关(可选)- 网络设备: 指定出口网络设备 eg. enp2s0- mtu: 配置mtu参数 192.168.8.0/24: 网络 dev enp2s0: 网络设备 proto kernel: 路由协议 [redirect, kernel, boot, static, ra] scope link: 作用域 网络侦查ping 网络状态 12345➜ ~ ping www.baidu.com -c 5PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=54 time=20.6 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=54 time=20.5 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=54 time=20.4 ms 64 bytes: ICMP封包大小 icmp_seq=3: 侦测序号 ttl=54: 默认255, 每经过一个含MAC地址时-1 time=20.5 ms: 耗时 traceroute 网路状态12345678910111213➜ ~ traceroute www.baidu.com traceroute to www.baidu.com (14.215.177.39), 30 hops max, 60 byte packets 1 192.168.8.1 (192.168.8.1) 0.784 ms 1.348 ms 1.866 ms 2 192.168.5.1 (192.168.5.1) 0.138 ms 0.174 ms 0.217 ms 3 1.224.77.125.broad.xm.fj.dynamic.163data.com.cn (125.77.224.1) 1.458 ms 1.486 ms 1.694 ms 4 61.154.238.229 (61.154.238.229) 4.692 ms 4.704 ms 61.154.238.225 (61.154.238.225) 2.400 ms 5 61.154.238.77 (61.154.238.77) 5.834 ms 117.30.27.185 (117.30.27.185) 1.948 ms 61.154.238.77 (61.154.238.77) 6.106 ms 6 * 202.97.40.169 (202.97.40.169) 19.847 ms 202.97.78.37 (202.97.78.37) 19.233 ms 7 113.96.4.90 (113.96.4.90) 32.771 ms 28.773 ms 113.96.4.106 (113.96.4.106) 42.485 ms 8 * * * 9 14.29.117.234 (14.29.117.234) 19.359 ms 14.29.121.182 (14.29.121.182) 17.646 ms 14.29.121.190 (14.29.121.190) 28.106 ms10 * * *11 * * * 每个序号都是同一层进行三次连接的耗时 * * *: 可能是防火墙问题或路由问题 netstat 查看本机的网络连接1234# 目前所有的网络线路状态# netstat -tulnpProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:8000 0.0.0.0:* LISTEN 10247/node Proto: 网络协议 Recv-Q: 未使用字节 Send-Q: 没有确认的字节 Local Address: 本地地址+端口 Foreign Address: 目标地址+端口 stat: 状态 ESTABLISED: 已连线 SYN_SENT: 发送连线确认包 SYN_RECV: 接收连线确认包 FIN_WAIT1: 正在断线中-第一步 FIN_WAIT2: 正在断线中(等待对方确认)-第二步 TIME_WAIT: 已断线(等待关闭)-第三步 LISTEN: 正在监听 PID/Program name: 进程和PID host, nslookup, dig 域名转IP host123456789➜ ~ host www.baidu.com 114.114.114.114Using domain server:Name: 114.114.114.114Address: 114.114.114.114#53Aliases: www.baidu.com is an alias for www.a.shifen.com.www.a.shifen.com has address 14.215.177.39www.a.shifen.com has address 14.215.177.38 nslookup123456789➜ ~ nslookup www.google.comServer: 218.85.152.99Address: 218.85.152.99#53Non-authoritative answer:Name: www.google.comAddress: 75.126.150.210Name: www.google.comAddress: 2400:cb00:2048:1::6814:224e dig12345678910111213141516171819202122232425262728293031323334➜ ~ dig www.google.com; &lt;&lt;&gt;&gt; DiG 9.11.3-1-Debian &lt;&lt;&gt;&gt; www.google.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 26052;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 4, ADDITIONAL: 8;; QUESTION SECTION:;www.google.com. IN A;; ANSWER SECTION:www.google.com. 600 IN A 75.126.150.210;; AUTHORITY SECTION:google.com. 153873 IN NS ns2.google.com.google.com. 153873 IN NS ns1.google.com.google.com. 153873 IN NS ns3.google.com.google.com. 153873 IN NS ns4.google.com.;; ADDITIONAL SECTION:ns1.google.com. 340640 IN A 216.239.32.10ns1.google.com. 160867 IN AAAA 2001:4860:4802:32::ans2.google.com. 147310 IN A 216.239.34.10ns2.google.com. 167153 IN AAAA 2001:4860:4802:34::ans3.google.com. 170088 IN A 216.239.36.10ns3.google.com. 343381 IN AAAA 2001:4860:4802:36::ans4.google.com. 342199 IN A 216.239.38.10ns4.google.com. 340238 IN AAAA 2001:4860:4802:38::a;; Query time: 3 msec;; SERVER: 218.85.152.99#53(218.85.152.99);; WHEN: Tue Apr 02 11:54:08 CST 2019;; MSG SIZE rcvd: 296 Hook tcpdump 1234567891011121314151617181920212223242526272829➜ ~ sudo tcpdump -i enp2s0tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on enp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes16:03:36.920320 IP 192.168.8.23.32842 &gt; 106.37.75.114.80: Flags [.], ack 1334, win 1134, options [nop,nop,TS val 2465645746 ecr 4170196622], length 016:07:25.848706 IP 192.168.8.23.45512 &gt; 203.107.41.32.9015: Flags [P.], seq 858:897, ack 771, win 37440, length 3915:23:53.248962 IP6 fe80::485c:9c0f:61ce:2886 &gt; ff02::1:ffb6:3f84: ICMP6, neighbor solicitation, who has fe80::32e1:71ff:feb6:3f84, length 3215:23:53.249199 IP 192.168.8.23.55804 &gt; FJ-DNS.xm.fj.cn.domain: 41679+ PTR? 4.8.f.3.6.b.f.f.1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.f.f.ip6.arpa. (90)15:23:53.251749 IP FJ-DNS.xm.fj.cn.domain &gt; 192.168.8.23.55804: 41679 NXDomain* 0/1/0 (154)15:23:53.251809 IP 192.168.8.23.57994 &gt; FJ-DNS.xm.fj.cn.domain: 8140+ PTR? 6.8.8.2.e.c.1.6.f.0.c.9.c.5.8.4.0.0.0.0.0.0.0.0.0.0.0.0.0.8.e.f.ip6.arpa. (90)15:23:53.254241 ARP, Request who-has 192.168.8.250 tell 192.168.8.134, length 4615:23:53.255081 IP FJ-DNS.xm.fj.cn.domain &gt; 192.168.8.23.57994: 8140 NXDomain* 0/1/0 (139)# 指令tcpdump [-AennqX] [-i 网络接口] [-w 导出文件] [-c 次数] \ [-r 导入文件] [过滤规则]-A： 显示为ASCII码-e: OSI 二层显示MAC封包-nn: 解析地址(显示为ip和端口)-q: 打印简短的信息-X: 显示16进制及ASCII码-i: 需要监听的网络接口-w: 写出存储文件-r: 读取存储文件-c: 监听数量过滤规则: 可以使用 and 和 or 进行组合 - &apos;host foo&apos;, &apos;host 127.0.0.1&apos; ：监听特定的主机 - &apos;net 192.168&apos; ：监听特定的网段 - &apos;src host 127.0.0.1&apos; &apos;dst net 192.168&apos;： 监听特定的来源(src)或目的地(dst) - &apos;tcp port 21&apos;：监听特定的协议，如 tcp, udp, arp, ether.. 15:23:53.248962: 时:分:秒.毫秒 IP: 使用的协议 192.168.8.23.32842 &gt;: 发起端 106.37.75.114.80: 接收端 Flags [.]: 传输标识 [.P]: 推送PUSH ack 1334: ack 号 seq 858:897: 传输资料 858~897 byte iptables 访问控制 tc 流量控制 mtr 显示网络路径的状况]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch 随手记]]></title>
    <url>%2F2019%2F03%2F23%2FElasticsearch%20%E9%9A%8F%E6%89%8B%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Elasticsearch 随手记 😋 ElasticSearch 对比 MySQL Index -&gt; Database Type -&gt; Table Document -&gt; Row 索引模版数据类型 字符串类型 string,text,keyword 整数类型 integer,long,short,byte 浮点类型 double,float,half_float,scaled_float 逻辑类型 boolean 日期类型 date 范围类型 range 二进制类型 binary 复合类型 数组类型 array 对象类型 object 嵌套类型 nested 地理类型 地理坐标类型 geo_point 地理地图 geo_shape 特殊类型 IP类型 ip 范围类型 completion 令牌计数类型 token_count 附件类型 attachment 抽取类型 percolator API 接口 pretty 格式化explain=true 分析 通配符 监控操作 监控12# 查询所有监控指令curl --user elastic:changeme -XGET http://127.0.0.1:9200/_cat 节点操作 查看节点状态 12# 查看设置curl --user elastic:changeme -XGET http://127.0.0.1:9200/_cluster/settings?pretty 实时更改配置 123456789# 永久生效curl --user elastic:changeme -XPUT http://127.0.0.1:9200/_cluster/settings -H "Content-type: application/json" -d '&#123; "persistent": &#123; &#125;&#125;'# 暂时生效curl --user elastic:changeme -XPUT http://127.0.0.1:9200/_cluster/settings -H "Content-type: application/json" -d '&#123; "transient": &#123;&#125;&#125;' 数据操作 创建索引模版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455curl --user elastic:changeme -XPUT http://127.0.0.1:9200/db_test2 -H "Content-type: application/json" -d '&#123; "settings":&#123; # 节点数量 "number_of_replicas": 0, # 分片数量 # "number_of_shards": 5, # 索引存储类型 # "index.store.type": "niofs", # 默认检索字段 # "index.query.default_field": "title" # "index.unassigned.node_left.delayed_timeout": "5m" &#125;, "mappings": &#123; "example": &#123; # 动态变更 "dynamic": false, # 5.x 以上废除 "_all": &#123; "enabled": false &#125;, "properties": &#123; "example_id": &#123; "type": "long" &#125;, "name": &#123; "type": "text", # 指定分词器 "analyzer": "ik_max_word", "search_analyzer": "ik_max_word" &#125;, "text": &#123; "type": "keyword" &#125;, "title": &#123; "type": "text", "index": true &#125;, "createdAt": &#123; "type": "date", "format": "strict_date_optional_time||epoch_millis" &#125;, "age": &#123; "type": "integer" &#125;, "location": &#123; # es 中存储结构为: &#123;lon: 0.000, lat: 0.000&#125; "type": "geo_point" &#125;, "suggest": &#123; "type": "completion" &#125; &#125; &#125; &#125;&#125;' 删除索引模版 1curl --user elastic:changeme -XDELETE http://127.0.0.1:9200/db_test 查询索引模版 1curl --user elastic:changeme -XGET http://127.0.0.1:9200/db_test\?pretty 插入数据 123curl --user elastic:changeme -XPOST http://127.0.0.1:9200/db_test/example -H "Content-type: application/json" -d '&#123; "example_id": 666&#125;' 查询数据 12345678910111213# 查询所有curl --user elastic:changeme -XPOST http://127.0.0.1:9200/db_test/example/_search?pretty# 按条件查询curl --user elastic:changeme -XPOST http://127.0.0.1:9200/db_test/example/_search?pretty&amp;explain=true -H "Content-type: application/json" -d '&#123; "query": &#123; "match": &#123; "example_id": 666 &#125; &#125;&#125;'# 查询指定curl --user elastic:changeme -XGET http://127.0.0.1:9200/db_test/example/PiAmoGkBJAdUJ3wD4CMC?pretty=true 分析操作 分词器接口123456789# 使用默认分词器curl --user elastic:changeme -XPOST http://127.0.0.1:9200/_analyze?pretty -H 'Content-Type:application/json' -d'&#123; "text": "Hello World" &#125;'# 使用指定分词器curl --user elastic:changeme -XPOST http://127.0.0.1:9200/_analyze?pretty -H 'Content-Type:application/json' -d'&#123; "analyzer": "ik_max_word", "text": "Hello World" &#125;' Java 调用 创建索引 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private boolean createOrUpdateIndex(Long id) &#123; if (house == null) &#123; return false; &#125; ExampleIndexTemplate template = // .. 通过构建得出 SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(QueryBuilders.termQuery("example_id", id)); logger.debug(requestBuilder.toString()); SearchResponse searchResponse = requestBuilder.get(); boolean success; long totalHit = searchResponse.getHits().getTotalHits(); if (totalHit == 0) &#123; success = create(template); &#125; else if (totalHit == 1) &#123; String esId = searchResponse.getHits().getAt(0).getId(); success = update(id, template); &#125; else &#123; success = deleteAndCreate(totalHit, template); &#125;&#125;// -- private boolean create(ExampleIndexTemplate indexTemplate) &#123; try &#123; IndexResponse response = this.esClient.prepareIndex(INDEX_NAME, INDEX_TYPE) .setSource(objectMapper.writeValueAsBytes(indexTemplate), XContentType.JSON).get(); if (response.status() == RestStatus.CREATED) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (JsonProcessingException e) &#123; return false; &#125; &#125; private boolean update(Long id, ExampleIndexTemplate indexTemplate) &#123; try &#123; UpdateResponse response = this.esClient.prepareUpdate(INDEX_NAME, INDEX_TYPE, id).setDoc(objectMapper.writeValueAsBytes(indexTemplate), XContentType.JSON).get(); if (response.status() == RestStatus.OK) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (JsonProcessingException e) &#123; return false; &#125; &#125; private boolean deleteAndCreate(long totalHit, ExampleIndexTemplate indexTemplate) &#123; DeleteByQueryRequestBuilder builder = DeleteByQueryAction.INSTANCE .newRequestBuilder(esClient) .filter(QueryBuilders.termQuery("example_id", indexTemplate.getId())) .source(INDEX_NAME); BulkByScrollResponse response = builder.get(); long deleted = response.getDeleted(); if (deleted != totalHit) &#123; return false; &#125; else &#123; return create(indexTemplate); &#125; &#125; 移除索引模版 12345678private void remove(Long id) &#123; DeleteByQueryRequestBuilder builder = DeleteByQueryAction.INSTANCE .newRequestBuilder(esClient) .filter(QueryBuilders.termQuery("example_id", id)) .source(INDEX_NAME); BulkByScrollResponse response = builder.get(); long deleted = response.getDeleted();&#125; 简单搜索 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 通过搜索查询出id， 然后于 mysql 之类数据库进行聚合List&lt;Serializable&gt; search(SearchBody body)&#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); // 满足filter子句的条件。但是不会像Must一样，参与计算分值 boolQuery.filter( // QueryBuilders.termQuery // QueryBuilders.rangeQuery //.. )// 提高权重, 如果需要的话// boolQuery.must(// QueryBuilders.matchQuery("title", body.getKeywords())// .boost(2.0f)// ); // [必须满足的意思] 满足must子句的条件，并且参与计算分值 boolQuery.must( // QueryBuilders.multiMatchQuery 关键词匹配多个字段 //.. ) // 满足should子句的条件。在一个Bool查询中，如果没有must或者filter，有一个或者多个should子句，那么只要满足一个就可以返回 boolQuery.should( //.. ) // 不满足must_not定义的条件 boolQuery.should( //.. ) SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) // 查询条件 .setQuery(boolQuery) // 排序 .addSort( "createdAt", "DESC" ) // 开始位置 .setFrom(0) .setSize(100) // 设置该字段可以有效减少返回数据量 .setFetchSource("id", null); SearchResponse response = requestBuilder.get(); List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); for (SearchHit hit : response.getHits()) &#123; System.out.println(hit.getSource()); ids.add(Longs.tryParse(String.valueOf(hit.getSource().get("example_id")))); &#125; return ids;&#125; 自动补全 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 匹配Collection&lt;String&gt; suggest(String prefix)&#123; CompletionSuggestionBuilder suggestion = SuggestBuilders.completionSuggestion("suggest").prefix(prefix).size(5); SuggestBuilder suggestBuilder = new SuggestBuilder(); suggestBuilder.addSuggestion("autocomplete", suggestion); SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .suggest(suggestBuilder); SearchResponse response = requestBuilder.get(); Suggest suggest = response.getSuggest(); if (suggest == null) &#123; return ServiceResult.of(new ArrayList&lt;&gt;()); &#125; Suggest.Suggestion result = suggest.getSuggestion("autocomplete"); int maxSuggest = 0; Set&lt;String&gt; suggestSet = new HashSet&lt;&gt;(); for (Object term : result.getEntries()) &#123; if (term instanceof CompletionSuggestion.Entry) &#123; CompletionSuggestion.Entry item = (CompletionSuggestion.Entry) term; if (item.getOptions().isEmpty()) &#123; continue; &#125; for (CompletionSuggestion.Entry.Option option : item.getOptions()) &#123; String tip = option.getText().string(); if (suggestSet.contains(tip)) &#123; continue; &#125; suggestSet.add(tip); maxSuggest++; &#125; &#125; if (maxSuggest &gt; 5) &#123; break; &#125; &#125; return suggestSet;&#125;// 设置权重private boolean updateSuggest(ExampleIndexTemplate indexTemplate) &#123; AnalyzeRequestBuilder requestBuilder = new AnalyzeRequestBuilder( this.esClient, AnalyzeAction.INSTANCE, INDEX_NAME, // 会被搜索的字段的值.. ); // 使用的分词器 requestBuilder.setAnalyzer("ik_smart"); AnalyzeResponse response = requestBuilder.get(); List&lt;AnalyzeResponse.AnalyzeToken&gt; tokens = response.getTokens(); if (tokens == null) &#123; return false; &#125; List&lt;HouseSuggest&gt; suggests = new ArrayList&lt;&gt;(); for (AnalyzeResponse.AnalyzeToken token : tokens) &#123; // 生效限制 if ("&lt;NUM&gt;".equals(token.getType()) || token.getTerm().length() &lt; 2) &#123; continue; &#125; ExampleSuggest suggest = // .. suggests.add(suggest); &#125; // 其他影响因素 ExampleSuggest suggest = // .. suggests.add(suggest); indexTemplate.setSuggest(suggests); return true;&#125; 聚合统计 1234567891011121314151617181920212223242526272829303132333435long aggregateNumber(String c1, String c2, String c3)&#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery() .filter(QueryBuilders.termQuery( // 聚合条件 )) .filter(QueryBuilders.termQuery( // 聚合条件 )) .filter(QueryBuilders.termQuery( "field_name", c1 )); SearchRequestBuilder requestBuilder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addAggregation( AggregationBuilders.terms("agg_number") .field("field_name") ).setSize(0); logger.debug(requestBuilder.toString()); SearchResponse response = requestBuilder.get(); if (response.status() == RestStatus.OK) &#123; Terms terms = response.getAggregations().get("agg_number"); if (terms.getBuckets() != null &amp;&amp; !terms.getBuckets().isEmpty()) &#123; return terms.getBucketByKey(c1).getDocCount(); &#125; &#125; else &#123; return 0L; &#125; return 0L;&#125; 位置范围查询 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Collection&lt;Long&gt; mapQuery(SearchBody body) &#123; BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); boolQuery.filter(QueryBuilders.termQuery( // .. )); boolQuery.filter( QueryBuilders.geoBoundingBoxQuery("location") .setCorners( // 左上角 new GeoPoint(body.getLeftLatitude(), body.getLeftLongitude()), // 右下角 new GeoPoint(body.getRightLatitude(), body.getRightLongitude()) )); SearchRequestBuilder builder = this.esClient.prepareSearch(INDEX_NAME) .setTypes(INDEX_TYPE) .setQuery(boolQuery) .addSort( // .. ) .setFrom(0) .setSize(100); List&lt;Long&gt; ids = new ArrayList&lt;&gt;(); SearchResponse response = builder.get(); if (RestStatus.OK != response.status()) &#123; return ids; &#125; for (SearchHit hit : response.getHits()) &#123; ids.add(hit.getSource().get("example_id")); &#125; return ids;&#125; JSON格式查询语法官方文档 概要 must参与计算分值 -&gt; and filter不参与计算分值 -&gt; and should -&gt; or must_not -&gt; not1234567891011121314151617181920212223242526272829303132// 布尔查询&#123; "query": &#123; "bool": &#123; // The clause (query) must appear in matching documents and will contribute to the score. // 所有"must"条件必须匹配成功, 且计算分数 "must": [ &#123; "match": &#123; "title": "Search" &#125;&#125;, &#123; "match": &#123; "content": "Elasticsearch" &#125;&#125; ], // The clause (query) must appear in matching documents. However unlike must the score of the query will be ignored. Filter clauses are executed in filter context, meaning that scoring is ignored and clauses are considered for caching. // 所有"filter"条件必须匹配成功, 不计算分数(因此查询速度较快) "filter": [ &#123; "term": &#123; "status": "published" &#125;&#125;, &#123; "range": &#123; "publish_date": &#123; "gte": "2015-01-01" &#125;&#125;&#125; ], // The clause (query) should appear in the matching document. If the bool query is in a query context and has a must or filter clause then a document will match the bool query even if none of the should queries match. In this case these clauses are only used to influence the score. If the bool query is a filter context or has neither must or filter then at least one of the should queries must match a document for it to match the bool query. This behavior may be explicitly controlled by settings the minimum_should_match parameter. // 情况一(嵌套bool): 当"should"条件在"must"条件或者"filter"条件内, 此时不要求满足"should"条件, 但是会影响到查询分数 // 情况二(单条bool): 当"should"条件不在"must"条件或者"filter"条件内, 默认情况至少有一个"should"子句需要满足(可通过配置`minimum_should_match`参数进行变更) "should": [ &#123; "range": &#123;"age" : &#123; "gte" : 10, "lte" : 20 &#125;&#125;&#125; ], "minimum_should_match": 1, // The clause (query) must not appear in the matching documents. Clauses are executed in filter context meaning that scoring is ignored and clauses are considered for caching. Because scoring is ignored, a score of 0 for all documents is returned. // 所有"must_not"条件不能匹配成功 "must_not": [ &#123; "term": &#123; "tag" : "wow" &#125;&#125;, &#123; "term": &#123; "tag" : "elasticsearch" &#125;&#125; ] &#125; &#125;&#125; 全文搜索 会走分析器 match描述: 匹配查询, 只需包含部分。eg: hello world, 只匹配”hello”或者”world”可接受类型: text/numerics/dates1234567891011121314151617181920GET /_search// 简单查询&#123; "query": &#123; "match" : &#123; "message" : "this is a test" &#125; &#125;&#125;// 复杂查询&#123; "query": &#123; "match" : &#123; "message" : &#123; "query": "this is a test", "参数": "值" &#125; &#125; &#125;&#125; match_phrase 描述: 匹配词组查询, 多个词一起被查询. eg: hello world, 匹配”hello world” match_phrase_prefix 描述: 同match_phrase但是最后一个词会被当作前缀去匹配. eg: hello wo, 可匹配到”hello world” multi_match 描述: 同match但是可以作用在多个字段上，且字段支持表达式 12345678910GET /_search&#123; "query": &#123; "multi_match" : &#123; "query": "this is a test", "fields": [ "subject", "*_name" ], "参数": "值" &#125; &#125;&#125; common 描述: 根据词频进行匹配. 123456789101112GET /_search&#123; "query": &#123; "common": &#123; "body": &#123; "query": "this is bonsai cool", // 词频率: [0, 1] "cutoff_frequency": 0.001 &#125; &#125; &#125;&#125; query_string 描述: 根据表达式进行匹配, 输入的值为表达式, 支持一些内置参数和语法。 12345678GET /_search&#123; "query": &#123; "query_string": &#123; "query": "(content:this OR name:this) AND (content:that OR name:that)" &#125; &#125;&#125; simple_query_string 描述: 与query_string类似, 支持一些更简便的符号。 12345678910GET /_search&#123; "query": &#123; "simple_query_string" : &#123; "query": "\"fried eggs\" +(eggplant | potato) -frittata", "fields": ["title^5", "body"], "default_operator": "and" &#125; &#125;&#125; 条件查询 精准搜索一般用于结构化数据而非全文匹配: numbers, dates, and enums term 描述: 匹配单个值, 类似”=”, 但是其具备Elasticsearch的特性如: 分数 123456789101112131415161718192021222324252627282930// 简单POST _search&#123; "query": &#123; "term" : &#123; "user" : "Kimchy" &#125; &#125;&#125;// 复杂，设定匹配分数之类的GET _search&#123; "query": &#123; "bool": &#123; "should": [ &#123; "term": &#123; "status": &#123; "value": "urgent", "boost": 2.0 &#125; &#125; &#125;, &#123; "term": &#123; "status": "normal" &#125; &#125; ] &#125; &#125;&#125; terms 描述: 匹配多个值, 类似”in” 1234567// 简单GET /_search&#123; "query": &#123; "terms" : &#123; "user" : ["kimchy", "elasticsearch"]&#125; &#125;&#125; terms_set 描述: 定制化匹配规则 1234567891011GET /my-index/_search&#123; "query": &#123; "terms_set": &#123; "codes" : &#123; "terms" : ["abc", "def", "ghi"], "minimum_should_match_field": "required_matches" &#125; &#125; &#125;&#125; range 描述: 范围匹配, 支持: string，date，numeric 123456789101112GET _search&#123; "query": &#123; "range" : &#123; "age" : &#123; "gte" : 10, "lte" : 20, "boost" : 2.0 &#125; &#125; &#125;&#125; exists 描述: 存在查询, 必须至少存在一个非null值. eg: user: [null, ‘hocgin’] 123456GET /_search&#123; "query": &#123; "exists" : &#123; "field" : "user" &#125; &#125;&#125; prefix 描述: 前缀匹配. 12345GET /_search&#123; "query": &#123; "prefix" : &#123; "user" : "ki" &#125; &#125;&#125; wildcard 描述: 通配符匹配。类似like 123456GET /_search&#123; "query": &#123; "wildcard" : &#123; "user" : "ki*y" &#125; &#125;&#125; regexp 描述: 正则匹配，允许使用正则表达式。⚠️: 性能取决于正则表达式写法，建议用饥饿模式 12345678GET /_search&#123; "query": &#123; "regexp":&#123; "name.first": "s.*y?" &#125; &#125;&#125; fuzzy 描述: 模糊查询. 适用于拼写错误时搜索。 123456GET /_search&#123; "query": &#123; "fuzzy" : &#123; "user" : "ki" &#125; &#125;&#125; type 描述: 文档类型查询 12345678GET /_search&#123; "query": &#123; "type" : &#123; "value" : "_doc" &#125; &#125;&#125; ids 描述: 根据id字段过滤文档数据 123456789GET /_search&#123; "query": &#123; "ids" : &#123; "type" : "_doc", "values" : ["1", "4", "100"] &#125; &#125;&#125; 复合查询 constant_score 描述: 忽略评分查询, 查询速度更快(使用缓存)。 1234567891011GET /_search&#123; "query": &#123; "constant_score" : &#123; "filter" : &#123; "term" : &#123; "user" : "kimchy"&#125; &#125;, "boost" : 1.2 &#125; &#125;&#125; Bool 查询 描述: 使用其他查询的bool值组合的查询。详细参考概要 123456789101112131415161718192021222324POST _search&#123; "query": &#123; "bool" : &#123; "must" : &#123; "term" : &#123; "user" : "kimchy" &#125; &#125;, "filter": &#123; "term" : &#123; "tag" : "tech" &#125; &#125;, "must_not" : &#123; "range" : &#123; "age" : &#123; "gte" : 10, "lte" : 20 &#125; &#125; &#125;, "should" : [ &#123; "term" : &#123; "tag" : "wow" &#125; &#125;, &#123; "term" : &#123; "tag" : "elasticsearch" &#125; &#125; ], "minimum_should_match" : 1, "boost" : 1.0 &#125; &#125;&#125; Dis Max Query 描述: 取多个条件查询结果中，得分最高的查询结果。可以通过: tie_breaker 来关联其他查询结果的分数。 123456789101112131415161718GET /_search&#123; "query": &#123; "dis_max" : &#123; // 此处相当于除最佳匹配外，其他匹配结果的参与程度. --- 言外之意, 多方面考虑 "tie_breaker" : 0.7, "boost" : 1.2, "queries" : [ &#123; "term" : &#123; "age" : 34 &#125; &#125;, &#123; "term" : &#123; "age" : 35 &#125; &#125; ] &#125; &#125;&#125; Function Score Query 描述: 打分器. 最后打分阶段，引入一些最佳值的计算方式. — 言外之意，作弊器 1234567891011GET /_search&#123; "query": &#123; "function_score": &#123; "query": &#123; "match_all": &#123;&#125; &#125;, "boost": "5", "random_score": &#123;&#125;, "boost_mode":"multiply" &#125; &#125;&#125; Boosting Query 描述: 设置条件的权重. 123456789101112131415161718GET /_search&#123; "query": &#123; "boosting" : &#123; "positive" : &#123; "term" : &#123; "field1" : "value1" &#125; &#125;, "negative" : &#123; "term" : &#123; "field2" : "value2" &#125; &#125;, "negative_boost" : 0.2 &#125; &#125;&#125; 连接查询 Nested Query 描述 1234567891011121314151617181920GET /_search&#123; "query": &#123; "nested" : &#123; // 嵌套对象路径 "path" : "obj1", // 影响的计分方式 "score_mode" : "avg", "query" : &#123; "bool" : &#123; "must" : [ // ⚠️: 字段必须是完整路径 &#123; "match" : &#123;"obj1.name" : "blue"&#125; &#125;, &#123; "range" : &#123;"obj1.count" : &#123;"gt" : 5&#125;&#125; &#125; ] &#125; &#125; &#125; &#125;&#125; Has Child Query 描述: 进行子文档查询, 返回父文档. 慢查询，慎用 1234567891011121314GET /_search&#123; "query": &#123; "has_child" : &#123; "type" : "blog_tag", "score_mode" : "min", "query" : &#123; "term" : &#123; "tag" : "something" &#125; &#125; &#125; &#125;&#125; Has Parent Query 描述: 父文档查询，返回子文档. 12345678910111213GET /_search&#123; "query": &#123; "has_parent" : &#123; "parent_type" : "blog", "query" : &#123; "term" : &#123; "tag" : "something" &#125; &#125; &#125; &#125;&#125; Parent Id Query 描述: 父ID查询，返回子文档 123456789GET /my_index/_search&#123; "query": &#123; "parent_id": &#123; "type": "my_child", "id": "1" &#125; &#125;&#125; 地理位置查询 需要geo_shape类型 GeoShape Query描述: GeoShape 查询，查询在多边形(基于GeoJSON)内的点。既: 用一个多边形去搜索。 123456789101112131415161718192021GET /example/_search&#123; "query":&#123; "bool": &#123; "must": &#123; "match_all": &#123;&#125; &#125;, "filter": &#123; "geo_shape": &#123; "location": &#123; "shape": &#123; "type": "envelope", "coordinates" : [[13.0, 53.0], [14.0, 52.0]] &#125;, "relation": "within" &#125; &#125; &#125; &#125; &#125;&#125; Geo Bounding Box Query 描述: 地理边界框查询，即用一个边界范围去搜索。 123456789101112131415161718192021222324GET /_search&#123; "query": &#123; "bool" : &#123; "must" : &#123; "match_all" : &#123;&#125; &#125;, "filter" : &#123; "geo_bounding_box" : &#123; "pin.location" : &#123; "top_left" : &#123; "lat" : 40.73, "lon" : -74.1 &#125;, "bottom_right" : &#123; "lat" : 40.01, "lon" : -71.12 &#125; &#125; &#125; &#125; &#125; &#125;&#125; Geo Distance Query 描述: 地理距离查询 12345678910111213141516171819GET /my_locations/_search&#123; "query": &#123; "bool" : &#123; "must" : &#123; "match_all" : &#123;&#125; &#125;, "filter" : &#123; "geo_distance" : &#123; "distance" : "200km", "pin.location" : &#123; "lat" : 40, "lon" : -70 &#125; &#125; &#125; &#125; &#125;&#125; Geo Polygon Query 描述: 地理多边形查询, 返回围栏内的数据 123456789101112131415161718192021GET /_search&#123; "query": &#123; "bool" : &#123; "must" : &#123; "match_all" : &#123;&#125; &#125;, "filter" : &#123; "geo_polygon" : &#123; "person.location" : &#123; "points" : [ &#123;"lat" : 40, "lon" : -70&#125;, &#123;"lat" : 30, "lon" : -80&#125;, &#123;"lat" : 20, "lon" : -90&#125; ] &#125; &#125; &#125; &#125; &#125;&#125; 定制化查询 More Like This Query 描述: 根据字段进行匹配文字的相识度，一般用于进行文章或内容的相识度推荐 1234567891011GET /_search&#123; "query": &#123; "more_like_this" : &#123; "fields" : ["title", "description"], "like" : "Once upon a time", "min_term_freq" : 1, "max_query_terms" : 12 &#125; &#125;&#125; Script Query 描述: 脚本查询，使用特定的语法脚本进行查询。 123456789101112131415GET /_search&#123; "query": &#123; "bool" : &#123; "filter" : &#123; "script" : &#123; "script" : &#123; "source": "doc['num1'].value &gt; 1", "lang": "painless" &#125; &#125; &#125; &#125; &#125;&#125; Percolate Query 描述: Percolate查询，可用于匹配存储在索引中的查询, 1234567891011GET /my-index/_search&#123; "query" : &#123; "percolate" : &#123; "field" : "query", "document" : &#123; "message" : "A new bonsai tree in the office" &#125; &#125; &#125;&#125; Wrapper Query 描述: 包装器查询, 将查询条件字符串 base64 编码 123456789GET /_search&#123; "query" : &#123; "wrapper": &#123; // &#123;"term" : &#123; "user" : "Kimchy" &#125;&#125; "query" : "eyJ0ZXJtIiA6IHsgInVzZXIiIDogIktpbWNoeSIgfX0=" &#125; &#125;&#125; 跨度查询 Span Term Query 描述: 等价于term 123456GET /_search&#123; "query": &#123; "span_term" : &#123; "user" : "kimchy" &#125; &#125;&#125; Span Multi Term Query 描述: 多个跨度查询组合, 允许 (wildcard, fuzzy, prefix, range or regexp query) 之一 12345678910GET /_search&#123; "query": &#123; "span_multi":&#123; "match":&#123; "prefix" : &#123; "user" : &#123; "value" : "ki", "boost" : 1.08 &#125; &#125; &#125; &#125; &#125;&#125; Span First Query 描述: 跨度优先查询， 1234567891011GET /_search&#123; "query": &#123; "span_first" : &#123; "match" : &#123; "span_term" : &#123; "user" : "kimchy" &#125; &#125;, "end" : 3 &#125; &#125;&#125; Span Near Query 描述: 接受多个跨度查询，其匹配必须在彼此的指定距离内，并且可能以相同的顺序。 1234567891011121314GET /_search&#123; "query": &#123; "span_near" : &#123; "clauses" : [ &#123; "span_term" : &#123; "field" : "value1" &#125; &#125;, &#123; "span_term" : &#123; "field" : "value2" &#125; &#125;, &#123; "span_term" : &#123; "field" : "value3" &#125; &#125; ], "slop" : 12, "in_order" : false &#125; &#125;&#125; Span Or Query 描述: 组合多个跨度查询 - 返回与任何指定查询匹配的文档。 123456789101112GET /_search&#123; "query": &#123; "span_or" : &#123; "clauses" : [ &#123; "span_term" : &#123; "field" : "value1" &#125; &#125;, &#123; "span_term" : &#123; "field" : "value2" &#125; &#125;, &#123; "span_term" : &#123; "field" : "value3" &#125; &#125; ] &#125; &#125;&#125; Span Not Query 描述: 包装另一个span查询，并排除与该查询匹配的任何文档。 1234567891011121314151617181920GET /_search&#123; "query": &#123; "span_not" : &#123; "include" : &#123; "span_term" : &#123; "field1" : "hoya" &#125; &#125;, "exclude" : &#123; "span_near" : &#123; "clauses" : [ &#123; "span_term" : &#123; "field1" : "la" &#125; &#125;, &#123; "span_term" : &#123; "field1" : "hoya" &#125; &#125; ], "slop" : 0, "in_order" : true &#125; &#125; &#125; &#125;&#125; Span Containing Query 描述: 接受跨度查询列表，但仅返回与第二个跨度查询匹配的跨度。 123456789101112131415161718192021curl -X GET "localhost:9200/_search" -H 'Content-Type: application/json' -d'&#123; "query": &#123; "span_containing" : &#123; "little" : &#123; "span_term" : &#123; "field1" : "foo" &#125; &#125;, "big" : &#123; "span_near" : &#123; "clauses" : [ &#123; "span_term" : &#123; "field1" : "bar" &#125; &#125;, &#123; "span_term" : &#123; "field1" : "baz" &#125; &#125; ], "slop" : 5, "in_order" : true &#125; &#125; &#125; &#125;&#125;' Span Within Query 描述: 只要其跨度落在由其他跨度查询列表返回的跨度内，就会返回单跨度查询的结果。 123456789101112131415161718192021curl -X GET "localhost:9200/_search" -H 'Content-Type: application/json' -d'&#123; "query": &#123; "span_within" : &#123; "little" : &#123; "span_term" : &#123; "field1" : "foo" &#125; &#125;, "big" : &#123; "span_near" : &#123; "clauses" : [ &#123; "span_term" : &#123; "field1" : "bar" &#125; &#125;, &#123; "span_term" : &#123; "field1" : "baz" &#125; &#125; ], "slop" : 5, "in_order" : true &#125; &#125; &#125; &#125;&#125;' Span Field Masking Query 描述: 允许查询不同的字段span-near或span-or跨不同字段。 123456789101112131415161718192021222324252627curl -X GET "localhost:9200/_search" -H 'Content-Type: application/json' -d'&#123; "query": &#123; "span_near": &#123; "clauses": [ &#123; "span_term": &#123; "text": "quick brown" &#125; &#125;, &#123; "field_masking_span": &#123; "query": &#123; "span_term": &#123; "text.stems": "fox" &#125; &#125;, "field": "text" &#125; &#125; ], "slop": 5, "in_order": false &#125; &#125;&#125;' 插件 elasticsearch-plugin install {url} 中文分词插件 文档ElasticSearch 官方文档全文搜索引擎 Elasticsearch 入门教程]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K8s 与 kubeadm 使用的一些记录]]></title>
    <url>%2F2019%2F03%2F08%2Fk8s%E4%B8%8Ekubeadm%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇是了解 k8s 过程随手记录与之相关的一些概念 Docker底层技术 限制, Cgoups 用来分配资源的, 如cpu,内存 隔离, Namespace技术 有点类似命名空间的概念, 隔离进程 容器本质既特殊进程 pid=1 文件系统, pivot_root/chroot 构建文件系统 文件层, Union File System k8s 处理容器间的关系, 既编排 Master Node 组件和职责 Master 节点 kube-apiserver 负责API服务 etcd 持久化数据 kubelet 核心 与容器交互(CRI) 管理宿主机(Device Plugin) 网络配置(CNI) 持久化存储(CSI) kube-scheduler 负责调度 kube-controller-manager 负责容器编排 Worker 节点 kubeadm准备源环境 OS: Ubuntu 16.04 LTS Master 节点 准备源环境 123456789curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.listdeb http://apt.kubernetes.io/ kubernetes-xenial mainEOFapt-get update# E: The method driver /usr/lib/apt/methods/https could not be found.# sudo apt-get install apt-transport-httpsapt-get install -y docker.io kubeadm 准备kubeadm.yml脚本 123456789apiVersion: kubeadm.k8s.io/v1alpha1kind: MasterConfigurationcontrollerManagerExtraArgs: horizontal-pod-autoscaler-use-rest-clients: "true" horizontal-pod-autoscaler-sync-period: "10s" node-monitor-grace-period: "10s"apiServerExtraArgs: runtime-config: "api/all=true"kubernetesVersion: "stable-1.11" 执行 kubeadm 初始化 1kubeadm init config kubeadm.yml 执行结果 1234567891011121314151617# ...Your Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join 10.140.0.2:6443 --token 9tf8vg.633b2jjzzsglp9n6 --discovery-token-ca-cert-hash sha256:7bc87892cf9715e1393da6c9aace18e13bc6eeeec2ed8bbf8f01d3bccc5b0c20 需要的集群配置 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 部署网络插件 1kubectl apply -f https://git.io/weave-kube-1.6 Cluster 节点 同 [Master 节点 1. 准备源环境] 将 Cluster 加入 Master 管理 执行 [Master 节点 4. 执行结果 中的 kubeadm join ...]:重点: 有一种情况, 当kubeadm init生成的token过期时, 可使用kubeadm token create重新生成 基本指令123456789101112131415# 查看节点状态kubectl get nodes# 查看节点对象的详情kubectl describe node k8s-3# 查看该节点, kube-system 系统上 pods 状态kubectl get pods -n kube-system# 安装插件, 例如: 安装网络插件kubectl apply -f https://git.io/weave-kube-1.6# 移除所有 Taint, "-" 匹配 ":xx"# 注意: 单机 Master 需要使用kubectl taint nodes --all node-role.kubernetes.io/master- 插件1234567# Dashboard, 仪表盘, 项目地址: https://github.com/kubernetes/dashboardkubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml# Rook, 云存储, 项目地址: https://github.com/rook/rookkubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/operator.yamlkubectl apply -f https://raw.githubusercontent.com/rook/rook/master/cluster/examples/kubernetes/ceph/cluster.yaml 高可用项目12# RocketMQkubectl apply -f https://raw.githubusercontent.com/apache/rocketmq-externals/master/rocketmq-docker/4.4.0/kubernetes/deployment.yaml 编排文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051apiVersion: extensions/v1beta1 # 必选，版本号kind: Deployment # 必选metadata: # 元数据 name: rocketmq# =========== 控制器部分 ===========spec: replicas: 1 # Pods 数量# =========== Pods 部分 =========== template: metadata: labels: app: rocketmq spec: containers: - name: broker image: rocketmqinc/rocketmq:4.4.0 command: ["sh","mqbroker", "-n","localhost:9876"] imagePullPolicy: IfNotPresent ports: - containerPort: 10909 # 容器端口 # - hostPort: 10909 # 主机端口 - containerPort: 10911 volumeMounts: - mountPath: /root/logs name: brokeroptlogs - mountPath: /root/store name: brokeroptstore - name: namesrv image: rocketmqinc/rocketmq:4.4.0 command: ["sh","mqnamesrv"] imagePullPolicy: IfNotPresent ports: - containerPort: 9876 volumeMounts: - mountPath: /root/logs name: namesrvoptlogs - mountPath: /root/store name: namesrvoptstore volumes: - name: brokeroptlogs hostPath: path: /data/broker/logs - name: brokeroptstore hostPath: path: /data/broker/store - name: namesrvoptlogs hostPath: path: /data/namesrv/logs - name: namesrvoptstore hostPath: path: /data/namesrv/store 知识点: service·pods·node·cluster·container Service: 一组 pods. 知识点: nodePort·port·targetPort·containerPortservice相关 Service 的类型为 ClusterIP port: 暴露在 Service(Cluster IP) 上的端口, 即集群中使用. service 暴露在 cluster ip 上的端口，:port 是提供给集群内部客户访问 service 的入口 targetPort: 指定 pod 上的端口, 会被映射到 port 上. targetPort 是 pod 上的端口，从 port 和 nodePort 上到来的数据最终经过 kube-proxy 流入到后端 pod 的 targetPort 上进入容器 Service 的类型为 NodePort nodePort: 用于集群外部访问 Cluster IP 只能集群内部访问(源与目标需要满足两个条件: kube-proxy正常运行，跨主机容器网络通信正常)，NodePort 会在每个 kubelet 节点的宿主机开启一个端口，用于应用集群外部访问。 容器相关类似docker -p containerPort: 容器需要暴露的端口 hostPort: 容器暴露的端口映射到的主机端口，默认与Container相同 随笔 紧密交互关系, Pod 共享一组 Network Namespace, 一组数据卷 Service 分配 Pod 固定的虚拟IP Pod 洁癖机制, Taint/Toleration kubeadm 方案, 一键部署, 可通过配置实现生产环境使用(未到GA阶段) minikuke 方案, 一键部署, 仅能用于本地实验 kops 方案, 可用于部署生产环境]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做单元测试]]></title>
    <url>%2F2019%2F02%2F02%2F%E5%A6%82%E4%BD%95%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[如何在项目中做好单元测试，在此总结和记录 单元测试栗子 各层测试方式Controller 层 使用 Rest 模拟请求 Mock 相关 Service 接口 Service 层 使用 Mockit Mock 函数 Mapper 层- 使用 @Sql 制造数据链接 参考示例 小谈 Java 单元测试 - 芋道源码 - CSDN博客 Apollo（阿波罗）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于项目结构划分]]></title>
    <url>%2F2019%2F01%2F12%2F%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[关于项目结构划分的思考和总结 项目分层 Controller 参数常规合法性校验 每个Controller函数对应一个Service函数 Service 业务层，复用性低 参数业务合法性校验，使用 throw 处理异常 Manager 可复用逻辑层 主要是Cache、MQ、复合Manager、RCP、HTTP等服务 Mapper 数据库访问层 1. 只允许自己的Service访问，其他Service访问仅能通过其Service领域模型DO Data Object 与数据库表结构对应，作为 Mapper 的返回值 DTO Data Transfer Object 数据传输对象，作为 Service 或 Manager 的返回值 BO Business Object 业务对象，作为 Service 的返回值，封装了业务逻辑的对象 AO Application Object 应用对象， VO View Object 显示层对象，通常为 Web 层返回内容或模版渲染传输对象 Query 数据查询对象，上层封装的查询对象 简化后的方案 Mapper 层返回的 DO 仅允许传入到 Service 或 Manager Service 或 Manager 返回的 VO 仅允许传入到 Controller 或 TService 总结12C -Query—&gt; S —DTO—&gt; MC &lt;—VO- S &lt;—DO- M 链接原文地址]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 图片墙]]></title>
    <url>%2F2018%2F12%2F31%2F2018%20%E5%9B%BE%E7%89%87%E5%A2%99%2F</url>
    <content type="text"></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>图片墙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React使用过程中的记录点]]></title>
    <url>%2F2018%2F11%2F20%2FReact%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%AE%B0%E5%BD%95%E7%82%B9%2F</url>
    <content type="text"><![CDATA[React 使用过程中的一些记录.. 定义清晰可维护的接口 避免 render替代方式 123const SplitTimes = (props) =&gt; &#123; //TODO: 返回JSX&#125; 回调类 props 属性使用前缀on 1&lt;div onDone=&#123;&#125;/&gt; 尽量写 props-type 组件的内部实现 解构赋值 123constructor() &#123; super(...arguments); //永远正确！&#125; 避免内联函数 1234567&lt;ControlButtons activated=&#123;this.state.isStarted&#125; onStart=&#123;() =&gt; &#123; /* TODO */&#125;&#125; onPause=&#123;() =&gt; &#123; /* TODO */&#125;&#125; onReset=&#123;() =&gt; &#123; /* TODO */&#125;&#125; onSplit=&#123;() =&gt; &#123; /* TODO */&#125;&#125;/&gt; 利用属性初始化（property initializer）来定义 state 和成员函数。 1234567891011121314state = &#123; isStarted: false, startTime: null, currentTime: null, splits: [], &#125;onReset = () =&gt; &#123; this.setState(&#123; startTime: null, currentTime: null, splits: [], &#125;); &#125; 组件化样式 避免内联 style123&lt;h1 style=&#123;&#123; 'font-family': 'monospace' &#125;&#125;&gt;&#123;ms2Time(milliseconds)&#125;&lt;/h1&gt; 聪明组件和傻瓜组件 不用 PureComponent 写一个傻瓜组件123456const Joke = React.memo(() =&gt; ( &lt;div&gt; &lt;img src=&#123;SmileFace&#125; /&gt; &#123;this.props.value || 'loading...' &#125; &lt;/div&gt;)); render props 模式 高阶组件 可以是普通属性，也可以是children 123456789101112131415161718192021const Auth= (props) =&gt; &#123; const userName = getUserName(); if (userName) &#123; const allProps = &#123;userName, ...props&#125;; return ( &lt;React.Fragment&gt; &#123;props.login(allProps)&#125; &lt;/React.Fragment&gt; ); &#125; else &#123; &lt;React.Fragment&gt; &#123;props.nologin(props)&#125; &lt;/React.Fragment&gt; &#125;&#125;; &lt;Auth login=&#123;(&#123;userName&#125;) =&gt; &lt;h1&gt;Hello &#123;userName&#125;&lt;/h1&gt;&#125; nologin=&#123;() =&gt; &lt;h1&gt;Please login&lt;/h1&gt;&#125; /&gt; 提供者模式 新版-提供者模式1234567891011121314151617181920const ThemeContext = React.createContext();const ThemeProvider = ThemeContext.Provider;const ThemeConsumer = ThemeContext.Consumer;class Subject extends React.Component &#123; render() &#123; return ( &lt;ThemeConsumer&gt; &#123; (theme) =&gt; ( &lt;h1 style=&#123;&#123;color: theme.mainColor&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/h1&gt; ) &#125; &lt;/ThemeConsumer&gt; ); &#125;&#125; 组合组件 模式 = 问题场景 + 解决办法 组合组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 案例 &lt;Tabs&gt; &lt;TabItem&gt;One&lt;/TabItem&gt; &lt;TabItem&gt;Two&lt;/TabItem&gt; &lt;TabItem&gt;Three&lt;/TabItem&gt; &lt;/Tabs&gt;// TabItemconst TabItem = (props) =&gt; &#123; const &#123;active, onClick&#125; = props; const tabStyle = &#123; 'max-width': '150px', color: active ? 'red' : 'green', border: active ? '1px red solid' : '0px', &#125;; return ( &lt;h1 style=&#123;tabStyle&#125; onClick=&#123;onClick&#125;&gt; &#123;props.children&#125; &lt;/h1&gt; );&#125;;// Tabsclass Tabs extends React.Component &#123; state = &#123; activeIndex: 0 &#125; render() &#123; const newChildren = React.Children.map(this.props.children, (child, index) =&gt; &#123; if (child.type) &#123; return React.cloneElement(child, &#123; active: this.state.activeIndex === index, onClick: () =&gt; this.setState(&#123;activeIndex: index&#125;) &#125;); &#125; else &#123; return child; &#125; &#125;); return ( &lt;Fragment&gt; &#123;newChildren&#125; &lt;/Fragment&gt; ); &#125;&#125; React 单元测试 测试框架 Jest 组件状态 props 是组件外传递进来的数据，state 代表的就是 React 组件的内部状态。 判断一个数据放在哪 如果数据由外部传入，放在 props 中； 如果是组件内部状态，是否这个状态更改应该立刻引发一次组件重新渲染？如果是，放在 state 中；不是，放在成员变量中。 函数参数的 state 更新12345678// 1function increment(state, props) &#123; return &#123;count: state.count + 1&#125;;&#125;this.setState(increment);// 2 this.setState((preState, props) =&gt; (&#123;&#125;) Redux 使用模式 connect( mapStateToProps , mapDispatchToProps ) 前者把 state 映射到 props 上 后者把 dispatch 映射到 props 上123456789// 后续写法connect(( state )=&gt;(&#123; count: state.count,&#125;), ( dispatch )=&gt;(&#123; onIncrement: () =&gt; dispatch(&#123;type: 'INCREMENT'&#125;), $fetch: (&#123;payload, callback&#125;)=&gt; dispatch(&#123;type: 'fetch', payload, callback&#125;),&#125;))// this.props.$fetch(&#123;&#125;) React Router 路由的种类 HashRouter /#/about BrowserRouter /about 推荐 拥抱异步渲染 在 componentDidMount 发起网络请求]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java IO、NIO、AIO]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%85%B3%E4%BA%8EJava%20IO%E3%80%81NIO%E3%80%81AIO%2F</url>
    <content type="text"><![CDATA[关于Java常用数据结构，后期继续整理 关于 IO BIO 同步并阻塞 NIO 同步非阻塞 AIO(NIO.2) JDK7, 异步非阻塞 NIO Channel 通道 传输 Buffer 缓冲区 存储 Selectors 多路复用器 监听 Channel IO 状况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349/** * Created by hocgin on 2018/7/2. * email: hocgin@gmail.com * NIO * Non-blocking IO（非阻塞IO） * - Selectors 多路复用器，用于监控 SelectableChannel IO状况 * -- SelectableChannel * ----SocketChannel * ----ServerSocketChannel * ----DatagramChannel * &lt;p&gt; * ----Pipe.SinkChannel 单向管道-写 * ----Pipe.SourceChannel 单向管道-读 * &lt;p&gt; * - Channels * &lt;p&gt; * - Buffers * -- capacity 总容量 * -- limit 界限，可操作最大范围 * -- position 当前操作位置 * -- mark 标记，记录position * &lt;p&gt; * 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity */public class NIOTest &#123; /** * 阻塞模式的 Socket NIO */ @Test public void nio_client() &#123; String path = "/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java"; try ( SocketChannel channel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 9898)); FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); ) &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); while (inChannel.read(buffer) != -1) &#123; buffer.flip(); channel.write(buffer); buffer.clear(); &#125; channel.shutdownOutput(); /** * 接收反馈 */ while (channel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); buffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 阻塞模式的 Socket NIO */ @Test public void nio_server() &#123; try ( ServerSocketChannel channel = ServerSocketChannel.open(); ) &#123; channel.bind(new InetSocketAddress(9898)); SocketChannel socketChannel = channel.accept(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (socketChannel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.limit())); buffer.clear(); &#125; buffer.put("接收完毕".getBytes()); buffer.flip(); socketChannel.write(buffer); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 非阻塞模式的 Socket NIO */ @Test public void nio_client2() &#123; try ( SocketChannel channel = SocketChannel.open(new InetSocketAddress("127.0.0.1", 9898)); ) &#123; // 非阻塞 channel.configureBlocking(false); ByteBuffer buffer = ByteBuffer.allocate(1024); /** * 发送信息 */ buffer.put(LocalDateTime.now().toString().getBytes()); buffer.flip(); channel.write(buffer); /** * 接收反馈 */ &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 非阻塞模式的 Socket NIO */ @Test public void nio_server2() &#123; try ( ServerSocketChannel channel = ServerSocketChannel.open(); ) &#123; // 非阻塞 channel.configureBlocking(false); channel.bind(new InetSocketAddress(9898)); Selector selector = Selector.open(); /** * 注册通道 指定事件类型 */ channel.register(selector, SelectionKey.OP_ACCEPT); while (selector.select() &gt; 0) &#123; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey action = iterator.next(); if (action.isAcceptable()) &#123; SocketChannel socketChannel = channel.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (action.isReadable()) &#123; SocketChannel socketChannel = (SocketChannel) action.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); try &#123; while (socketChannel.read(buffer) != -1) &#123; buffer.flip(); String s = new String(buffer.array(), 0, buffer.limit()); if (!Strings.isNullOrEmpty(s)) &#123; System.out.println(s); &#125; buffer.clear(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; iterator.remove(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void aio_server() throws IOException, InterruptedException &#123;// AsynchronousChannelGroup group = AsynchronousChannelGroup.withCachedThreadPool(Executors.newCachedThreadPool(), 10); AsynchronousServerSocketChannel channel = AsynchronousServerSocketChannel.open(); channel.bind(new InetSocketAddress(9898)); channel.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Void&gt;() &#123; final ByteBuffer buffer = ByteBuffer.allocate(1024); @Override public void completed(AsynchronousSocketChannel result, Void attachment) &#123; try &#123; result.read(buffer).get(); buffer.flip(); System.out.println(String.format("服务端 成功 :%s", new String(buffer.array()).trim())); result.close(); channel.accept(null, this); &#125; catch (IOException | InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, Void attachment) &#123; System.out.println("failed"); &#125; &#125;); LockSupport.park(); &#125; @Test public void aio_client() throws IOException &#123; AsynchronousSocketChannel channel = AsynchronousSocketChannel.open(); channel.connect(new InetSocketAddress("127.0.0.1", 9898), null, new CompletionHandler&lt;Void, Void&gt;() &#123; @Override public void completed(Void result, Void attachment) &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.put("你好".getBytes()); buffer.flip(); channel.write(buffer); &#125; @Override public void failed(Throwable exc, Void attachment) &#123; System.out.println(exc); &#125; &#125;); &#125; /** * Buffer * * @throws IOException */ @Test public void buffer() throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); System.out.println(buffer.position()); // 0 System.out.println(buffer.limit()); // 1024 System.out.println(buffer.capacity()); // 1024 buffer.put("asd".getBytes()); buffer.flip(); // 设置读取的范围限制至 position byte[] dst = new byte[buffer.limit()]; buffer.get(dst); System.out.println(new String(dst, 0, dst.length)); buffer.rewind(); // 重读 position = 0 mark = -1 buffer.clear(); // 清空 position = 0 limit = capacity mark = -1 buffer.mark(); // 标记 mark = position buffer.reset(); // position恢复为标记位置 position = mark buffer.hasRemaining(); // 是否有剩余数据 position &lt; limit buffer.remaining(); // 剩余数量 limit - position &#125; /** * getChannel * - 本地 * - FileInputStream/FileOutputStream * - RandomAccessFile * - 网络 * - Socket * - ServerSocket * - DatagramSocket * - JDK 7 * - xxChannel.open() * - Files.newByteChannel() * - Channels.newXXX */ @Test public void channel() throws IOException &#123; String path = "/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java"; FileInputStream in = new FileInputStream(path); ReadableByteChannel channel = Channels.newChannel(in); ByteBuffer buffer = ByteBuffer.allocate(1024); while (channel.read(buffer) != -1) &#123; buffer.flip(); System.out.println(String.format("%s", new String(buffer.array(), 0, buffer.limit()))); buffer.clear(); &#125; channel.close(); in.close(); &#125; /** * 直接缓冲区 */ @Test public void channel2() &#123; String path = "/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java"; try ( FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE) ) &#123; MappedByteBuffer inMap = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMap = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size()); byte[] bytes = new byte[inMap.limit()]; inMap.get(bytes); outMap.put(bytes); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 通道间的数据传输(直接缓冲区) */ @Test public void transfer() &#123; String path = "/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java"; try ( FileChannel inChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(path), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE) ) &#123; inChannel.transferTo(0, inChannel.size(), outChannel);// inChannel.transferFrom(outChannel,0, inChannel.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 分散读取(Scatter) * 聚集写入(Gather) */ @Test public void scatter() &#123; String path = "/Users/hocgin/Document/Projects/GitHub/23-Day/src/test/java/in/hocg/Test.java"; try ( RandomAccessFile f = new RandomAccessFile(path, "rw"); ) &#123; FileChannel channel = f.getChannel(); ByteBuffer allocate1 = ByteBuffer.allocate(1024); ByteBuffer allocate2 = ByteBuffer.allocate(1024); ByteBuffer[] all = &#123;allocate1, allocate2&#125;; // 分散读取 channel.read(all); // 聚集写入 channel.write(all); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; SortedMap&lt;String, Charset&gt; map = Charset.availableCharsets(); System.out.println(map); System.out.println(Charset.defaultCharset()); Charset charset = Charset.forName("UTF-8"); CharsetEncoder charsetEncoder = charset.newEncoder(); CharsetDecoder charsetDecoder = charset.newDecoder(); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 GitLab 来对 Spring Boot 项目进行 CI/CD]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%BD%BF%E7%94%A8%20GitLab%20%E6%9D%A5%E5%AF%B9%20Spring%20Boot%20%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%20CI%3ACD%2F</url>
    <content type="text"><![CDATA[利用 GitLab Pipelines 来进行项目的持续集成和部署。 使用 GitLab CI 构建 Spring Boot 项目搭建 GitLab CE 使用 Docker 方式搭建 GitLab CE 12345678910sudo docker run --detach \ --publish 443:443 \ --publish 80:80 \ --publish 2222:22 \ --name gitlab \ --restart always \ --volume /data/gitlab/config:/etc/gitlab \ --volume /data/gitlab/logs:/var/log/gitlab \ --volume /data/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest 搭建 GitLab Runner123456sudo docker run --rm -t -d -i -p 8084:8080 \ -v /data/gitlab-runner:/etc/gitlab-runner \ -v /var/run/docker.sock:/var/run/docker.sock \ --add-host ad4aac43c567:172.17.0.2 \ --name gitlab-runner \ gitlab/gitlab-runner 此处需注意--add-host请自行替换为GitLab CE Docker 容器 ID，此处是为了让 GitLab CE Docker 容器可以被 GitLab Runner 访问到, 如果使用公网 IP 可以忽略。 如果通过/etc/hosts仍然无法解决HOST问题, 请自行更改/data/gitlab-runner/config.toml文件，在[runners.docker]节点下面添加extra_hosts = [&quot;ad4aac43c567:172.17.0.2&quot;]。 注册 Runner12345678910sudo docker exec -it gitlab-runner gitlab-runner register -n \ --url http://192.168.1.13/ \ --registration-token pfHxurfRMBctWwkqrt1c \ --tag-list=docker-privileged \ --description "dockersock" \ --docker-privileged=false \ --docker-image "docker:latest" \ --docker-volumes /var/run/docker.sock:/var/run/docker.sock \ --docker-volumes /root/m2:/root/.m2 \ --executor docker url: GitLab CE 里面 CI 栏目查看 registration-token: GitLab CE 里面 CI 栏目查看 tag-list: 标签, 后续用于执行步骤时指定 Runner description: 描述 docker-image: 外层使用的 Docker 镜像 executor: 执行器 编写 .gitlab-ci.yml点击.gitlab-ci.yml查看 一键部署点击获取, 记得修改HOST。 源码GitLab-CI]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java-数据结构]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%85%B3%E4%BA%8EJava-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[关于Java常用数据结构，后期继续整理 List List必须保持元素特定的顺序 LinkedList List、Queue 双链表Node 非线程安全的 转换为线程安全Collections.synchronizedList(new LinkedList(...)); 特点: 实现了List、Deque接口，双向链表，适合频繁插入/删除，不适合使用set、set。 ArrayList List 数组实现 非线程安全的 特点: 动态长度(默认长度为10，增长默认为当前长度的1/2，不可大于Integer.MAX_VALUE - 8，否则 OutOfMemoryError), get、set直接访问。 Vector List 线程安全 用synchronized修饰函数 CopyOnWriteArrayList List 数组实现 线程安全 特点: 数组长度默认为0，每次修改都会重新增长长度和拷贝数组。 Stack 线程安全 数组实现 特点: 模拟栈。 工具类 转换为线程安全Collections.synchronizedList(new ArrayList(...)); 内部是用List实现存储的 与Vector差别是可以传入定制的锁。 转为不可变List Collections.unmodifiableList(new ArrayList&lt;&gt;()) 门面模式(List) 线程安全 特点: 不可变。 常用技巧123456789101112131415161718192021222324252627282930313233@Testpublic void lists() &#123; /** * 打乱数组 */ List&lt;Integer&gt; list = Arrays.asList(1, 2, 3); Collections.shuffle(list); System.out.println(String.format("打乱 %s", list)); /** * 移除所有 NULL */ list.removeIf(Objects::isNull); /** * 去重 */ list = list.stream().distinct().collect(Collectors.toList()); /** * 分组 */ Map&lt;String, List&lt;Integer&gt;&gt; collect = list.stream() .collect(Collectors.groupingBy(Object::toString)); /** * 查找一个元素 */ Integer integer = list.stream().filter(item -&gt; &#123; return item == 1; &#125;).findAny().orElse(null); &#125; Set Set不能有重复元素 HashSet Set 线程不安全 利用 HashMap 的 Key 值进行存储。 无序 利用Hash存储，存取和查找高效。 LinkedHashSet Set 线程不安全 利用 LinkedHashMap 的 Key 值进行存储。 按插入排序 TreeSet Set 线程不安全 利用 TreeMap 的 Key 值进行存储。 插入有序, 默认自然排序。 Queue Queue保持一个队列(先进先出)的顺序. PriorityQueue Queue 线程不安全 数组实现 Deque Queue 双端队列ArrayDeque Queue 数组实现 线程不安全 动态长度 BlockingQueueDelayQueueMap 用于保存具有”映射关系”的数据 HashMap 不能保证key-value对的顺序 线程不安全 LinkedHashMap 插入顺序 线程不安全 TreeMap 线程不安全 插入有序, 默认自然排序。 ConcurrentHashMap 线程安全 特点: 分多个块 整理了两张图 推荐]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java多线程-几个辅助类]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%87%A0%E4%B8%AA%E8%BE%85%E5%8A%A9%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[关于Java多线程-几个辅助类，后期继续整理 几个辅助类 CountDownLatch 计数器 CyclicBarrier 同步器 Phaser 1.7 阶段性、同步、计数 Example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188 ExecutorService executorService = Executors.newFixedThreadPool(4); /** * 计数器 latch.await() 会等待计数为 0 * @throws InterruptedException */ @Test public void countDownLatch() throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(4); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(latch::countDown); System.out.println(String.format("index: %d", latch.getCount())); &#125;); latch.await(); System.out.println(String.format("index: %d", latch.getCount()));// index: 4// index: 3// index: 2// index: 1// index: 0 &#125; /** * 等待指定数目的线程完成后, 才继续执行 * @throws InterruptedException */ @Test public void cyclicBarrier() throws InterruptedException &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, ()-&gt;&#123; System.out.println("所有任务执行完成，继续"); &#125;); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format("已经完成数目: %d/%d", cyclicBarrier.getNumberWaiting(), cyclicBarrier.getParties())); Thread.sleep(100); cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format("进行其他任务 %s", Thread.currentThread().getName())); &#125;); &#125;); Thread.sleep(1000); // 已经完成数目: 0/4// 已经完成数目: 0/4// 已经完成数目: 0/4// 已经完成数目: 0/4// 所有任务执行完成，继续// 进行其他任务 pool-1-thread-4// 进行其他任务 pool-1-thread-2// 进行其他任务 pool-1-thread-1// 进行其他任务 pool-1-thread-3 &#125; /** * 配置同时允许申请许可的数目，如果数目已满则进行阻塞等待释放许可。 * Semaphore 可配置是否使用公平机制，类似Lock * @throws InterruptedException */ @Test public void semaphore() throws InterruptedException &#123; Semaphore semaphore = new Semaphore(2); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format("正在申请许可 ID:%s", Thread.currentThread().getName())); semaphore.acquire(); System.out.println(String.format("申请许可成功 %s", Thread.currentThread().getName())); Thread.sleep(100); System.out.println(String.format("进行任务 %s", Thread.currentThread().getName())); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(String.format("释放许可 %s", Thread.currentThread().getName())); semaphore.release(); &#125; &#125;); &#125;); Thread.sleep(1000); // 正在申请许可 ID:pool-1-thread-2// 正在申请许可 ID:pool-1-thread-1// 申请许可成功 pool-1-thread-2// 正在申请许可 ID:pool-1-thread-4// 正在申请许可 ID:pool-1-thread-3// 申请许可成功 pool-1-thread-1// 进行任务 pool-1-thread-1// 进行任务 pool-1-thread-2// 释放许可 pool-1-thread-1// 释放许可 pool-1-thread-2// 申请许可成功 pool-1-thread-4// 申请许可成功 pool-1-thread-3// 进行任务 pool-1-thread-4// 进行任务 pool-1-thread-3// 释放许可 pool-1-thread-4// 释放许可 pool-1-thread-3 &#125; /** * 阶段性, 会等待所有人完成该步骤再进入下一个步骤 * - 每个阶段均可进行加入或移除 * * 函数 * - arriveAndAwaitAdvance 等待阶段 * - arriveAndDeregister 移除 * - bulkRegister 加入 */ @Test public void phaser() throws InterruptedException &#123; Phaser phaser = new Phaser(4); /** * 阶段性任务 */ System.out.println("【阶段性任务】"); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format("第一步 %s", Thread.currentThread().getName())); Thread.sleep(100); phaser.arriveAndAwaitAdvance(); Thread.sleep(100); System.out.println(String.format("第2步 %s", Thread.currentThread().getName())); phaser.arriveAndAwaitAdvance(); Thread.sleep(100); System.out.println(String.format("第三步 %s", Thread.currentThread().getName())); phaser.arriveAndAwaitAdvance(); System.out.println("Done"); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;); Thread.sleep(1000); /** * 计数任务 */ System.out.println("【计数任务】"); LongStream.range(0, 4).forEach((i)-&gt;&#123; executorService.submit(()-&gt;&#123; try &#123; System.out.println(String.format("已经完成 %s", Thread.currentThread().getName())); Thread.sleep(100); phaser.awaitAdvance(phaser.getPhase()); //cyclicBarrier.await(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;); phaser.arrive(); System.out.println("计数完成"); // 【阶段性任务】// 第一步 pool-1-thread-2// 第一步 pool-1-thread-3// 第一步 pool-1-thread-1// 第一步 pool-1-thread-4// 第2步 pool-1-thread-2// 第2步 pool-1-thread-1// 第2步 pool-1-thread-4// 第2步 pool-1-thread-3// 第三步 pool-1-thread-1// 第三步 pool-1-thread-4// 第三步 pool-1-thread-2// 第三步 pool-1-thread-3// Done// Done// Done// Done// 【计数任务】// 计数完成// 已经完成 pool-1-thread-2// 已经完成 pool-1-thread-4// 已经完成 pool-1-thread-3// 已经完成 pool-1-thread-1 &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java多线程-可见性、CAS、AQS、锁]]></title>
    <url>%2F2018%2F03%2F03%2F%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81CAS%E3%80%81AQS%E3%80%81%E9%94%81%2F</url>
    <content type="text"><![CDATA[关于Java多线程-可见性、CAS、AQS、锁 前提 解决多线程操作出现的脏读和数据、操作不一致问题。 volatile可见性 Java 内存分为主内存和工作内存。正常情况每个线程都拥有自己的工作内存，然后每隔一段时间会同步到主内存上，因此会存在不一致的情况。而volatile则是为了让标记字段的读取和写入都是在主内存中，保证其一致性。注意:但其仍不能保证写入操作的原子性。 CAS Compare And Swap, 比较并交换。用于解决多线程使用锁造成的性能损耗。Java 是利用Unsafe来实现CAS，进行硬件级别的原子性操作。 AQS AbstractQueuedSynchronizer, 这个为 Java 类, 公平锁FairSync和非公平锁NonfairSync均是通过此实现的。其利用队列来实现阻塞锁和同步。 ABA 问题 情景: 初始值为A[线程1获取的值为A][线程2获取的值为A,并更改值A为值B,再更改值B为值A][线程1更改值A为值B]。出现问题: 线程1感觉不到值有一段变化的过程，这是乐观锁出现的问题。解决方案: AtomicStampedReference/AtomicMarkableReference你值得拥有。 AtomicStampedReference 每次修改会存储版本号,版本号实现用int。 AtomicMarkableReference 每次修改会存储版本号,版本号实现用boolean。 锁的名词可重入锁 已获取的锁可以不必去重新申请。 synchronized/ReentrantLock 是可重入锁. 可中断锁 可以取消申请锁的操作。 synchronized 不是可中断锁。 公平锁 公平锁是根据请求顺序分发锁, 唤醒需要时间，能保- 证操作的顺序。 非公平锁会出现插队情况，性能高，但是不能保证操作的顺序。 synchronized 不是公平锁。 ReentrantLock/ReentrantReadWriteLock默认情况是非公平锁NonfairSync,但可以设置为公平锁FairSync 乐观锁 每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止。 Atomic* 乐观锁 由于在多线程操作中无法保证操作的原子性，因此引入了锁和CAS。AtomicStampedReference/AtomicMarkableReference 用于解决 CAS 的 ABA 问题 单 AtomicInteger Integer类型 AtomicLong Long类型 AtomicBoolean Boolean类型,内部使用int实现。 AtomicReference 对象类型 数组 AtomicIntegerArray Integer数组 AtomicLongArray Long数组 AtomicReferenceArray 对象数组 对象内字段 AtomicIntegerFieldUpdater 对象内Integer类型字段 AtomicLongFieldUpdater 对象内Long类型字段 AtomicReferenceFieldUpdater 对象内对象类型字段 根据版本号进行操作 AtomicStampedReference 每次修改会存储版本号,版本号实现用int。 AtomicMarkableReference 每次修改会存储版本号,版本号实现用boolean。 锁和同步 锁和同步的作用保证代码区域在同一时间只运行一个线程去执行,其余线程处于阻塞状态(BLOCKED)。 锁和同步的差异。 作用范围, Lock 可以跨方法，synchronized 只能在同一个方法中。 公平锁, Lock 使用公平锁，synchronized 使用非公平锁。 可中断，Lock 可以使用lockInterruptibly()中断锁，synchronized 无法中断。 当 synchronized 无法访问时会被阻塞，Lock 提供tryLock()减少阻塞时间。 不释放锁操作 同步代码中使用Thread.sleep/Thread.yield, 线程处于WAITING/TIMED_WAITING状态 同步代码中线程被suspend() 会释放锁操作 同步代码被break、return 同步代码被异常或错误终止 同步代码块执行结束 同步代码块被 wait(), 线程处于WAITING/TIMED_WAITING状态 锁Lock的相关实现 NonfairSync、FairSync ReentrantLock1234567891011121314151617181920212223242526272829303132 /** * 可重入锁 * 已获取的锁可以不必去重新申请。 * 例如： * synchronized(lock)&#123; * synchronized(lock)&#123; * //.. * &#125; * &#125; */@Testpublic void reentrantLock() &#123; ReentrantLock lock = new ReentrantLock(); System.out.println(String.format("是否公平锁 %b", lock.isFair())); // 是否公平锁 false /** * 可重入锁, 在同一个线程内不用反复申请锁(只是计数+1)。 * 如果不同线程会尝试关掉当前线程(interrupt) */ lock.lock(); System.out.println(String.format("该锁是否已被获取 %b", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format("是否有线程在等待获取该锁 %b", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.lock(); System.out.println(String.format("该锁是否已被获取 %b", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format("是否有线程在等待获取该锁 %b", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.unlock(); System.out.println(String.format("该锁是否已被获取 %b", lock.isHeldByCurrentThread())); // 该锁是否已被获取 true System.out.println(String.format("是否有线程在等待获取该锁 %b", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false lock.unlock(); System.out.println(String.format("该锁是否已被获取 %b", lock.isHeldByCurrentThread())); // 该锁是否已被获取 false System.out.println(String.format("是否有线程在等待获取该锁 %b", lock.hasQueuedThreads())); // 是否有线程在等待获取该锁 false&#125; ReentrantReadWriteLock 读写锁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 /** * 读写锁 * 读锁 &amp; 读锁 之间不会堵塞 * 写锁 &amp; 读锁/写锁 都会发生堵塞 */ @Test public void reentrantReadWriteLock() throws InterruptedException &#123; ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); Runnable rRunable = () -&gt; &#123; lock.readLock().lock(); System.out.println(String.format("获取 %s锁 %s", lock.isWriteLocked()?"写":"读", Thread.currentThread().getName())); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format("关掉 %s锁 %s", lock.isWriteLocked()?"写":"读", Thread.currentThread().getName())); lock.readLock().unlock(); &#125;; Runnable wRunable = () -&gt; &#123; lock.writeLock().lock(); System.out.println(String.format("获取 %s锁 %s", lock.isWriteLocked()?"写":"读", Thread.currentThread().getName())); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(String.format("关掉 %s锁 %s", lock.isWriteLocked()?"写":"读", Thread.currentThread().getName())); lock.writeLock().unlock(); &#125;; Thread rthread = new Thread(rRunable); Thread rthread2 = new Thread(rRunable); Thread wthread = new Thread(wRunable); Thread wthread2 = new Thread(wRunable); /** * 读-&gt;写-&gt;读 * * 获取 读锁 Thread-1 * 关掉 读锁 Thread-1 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 * 获取 读锁 Thread-2 * 关掉 读锁 Thread-2 */// System.out.println("读-&gt;写-&gt;读");// rthread.start();// Thread.sleep(100);// wthread.start();// Thread.sleep(100);// rthread2.start(); /** * 读-&gt;读-&gt;写 * 获取 读锁 Thread-1 * 获取 读锁 Thread-2 * 关掉 读锁 Thread-1 * 关掉 读锁 Thread-2 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 */// System.out.println("读-&gt;读-&gt;写");// rthread.start();// Thread.sleep(100);// rthread2.start();// Thread.sleep(100);// wthread.start(); /** * 写-&gt;写-&gt;读 * 获取 写锁 Thread-3 * 关掉 写锁 Thread-3 * 获取 写锁 Thread-4 * 关掉 写锁 Thread-4 * 获取 读锁 Thread-1 * 关掉 读锁 Thread-1 */ System.out.println("写-&gt;写-&gt;读"); wthread.start(); Thread.sleep(100); wthread2.start(); Thread.sleep(100); rthread.start(); Thread.sleep(5000); &#125; StampedLock 邮票锁, ReentrantReadWriteLock 的升级版写锁、读锁、新增(乐观读锁、锁的转换) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 邮票锁 * @throws InterruptedException */@Testpublic void stampedLock() throws InterruptedException &#123; StampedLock lock = new StampedLock(); int demo = 0; /** * 写锁 */ long stamp = lock.writeLock(); try &#123; demo = 1; &#125;finally &#123; lock.unlockWrite(stamp); &#125; /** * 读锁 */ stamp = lock.readLock(); try &#123; System.out.println(demo); &#125;finally &#123; lock.unlockRead(stamp); &#125; /** * 乐观读锁 * 一般情况读写并不冲突，但也可以通过检测申请乐观读锁后是否有写锁被申请，如果有可以再进行重新申请为读锁。 */ stamp = lock.tryOptimisticRead(); if (!lock.validate(stamp)) &#123; stamp = lock.readLock(); try &#123; System.out.println(demo); &#125; finally &#123; lock.unlockRead(stamp); &#125; &#125; else &#123; System.out.println(demo); &#125;&#125; Synchronized使用级别 实例对象函数this锁 静态函数class锁 代码块指定的锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class SynchronizedTest &#123; /** * 当线程1同步块正在执行，线程2处于阻塞状态(BLOCKED) * * @throws InterruptedException */ @Test public void state() throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; synchronized (SynchronizedTest.class) &#123; try &#123; // 不会让出锁 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread thread = new Thread(runnable); Thread thread2 = new Thread(runnable); thread.start(); thread2.start(); Thread.sleep(100); System.out.println(String.format("阻塞的线程2(%s) 状态: %s", thread2.getName(), thread2.getState())); // 阻塞的线程2(Thread-2) 状态: BLOCKED &#125; /** * 多个同步块共用一把锁, 当线程1同步块1正在执行，线程2在同步块2处于阻塞状态(BLOCKED) */ @Test public void multiSync() throws InterruptedException &#123; class Demo &#123; private final Object LOCK = new Object(); public void sync1() throws InterruptedException &#123; synchronized (LOCK) &#123; Thread.sleep(1000); &#125; &#125; public void sync2() &#123; synchronized (LOCK) &#123; System.out.println("执行中.."); &#125; &#125; &#125; Demo demo = new Demo(); Thread thread = new Thread(() -&gt; &#123; try &#123; demo.sync1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); Thread thread2 = new Thread(demo::sync2); thread.start(); thread2.start(); Thread.sleep(100); System.out.println(String.format("阻塞的线程2(%s) 状态: %s", thread2.getName(), thread2.getState())); // 阻塞的线程2(Thread-2) 状态: BLOCKED &#125; /** * 死锁 * * @throws InterruptedException */ @Test public void deadlock() throws InterruptedException &#123; Object LOCK = new Object(); Object LOCK2 = new Object(); Thread thread = new Thread(() -&gt; &#123; synchronized (LOCK) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (LOCK2) &#123; ; &#125; &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; synchronized (LOCK2) &#123; synchronized (LOCK) &#123; ; &#125; &#125; &#125;); thread.start(); thread2.start(); Thread.sleep(100); boolean b = thread.getState().equals(Thread.State.BLOCKED) &amp;&amp; thread2.getState().equals(Thread.State.BLOCKED); if (b) &#123; System.out.println(String.format("%s 和 %s 死锁", thread.getName(), thread2.getName())); &#125; else &#123; System.out.println("未发生死锁"); &#125; // Thread-1 和 Thread-2 死锁 &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java-Unsafe/LockSupport]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%85%B3%E4%BA%8EJava-Unsafe%3ALockSupport%2F</url>
    <content type="text"><![CDATA[关于Java Unsafe/LockSupport Unsafe 一个高效底层函数，可以实现内存管理、对象实例化(不通过构造函数)、操作函数+类+变量(通过使用地址)、多线程同步(挂起锁、CAS)、挂起和恢复、数组、内存屏障。 具体实践代码 Unsafe 中在高并发和高性能的场景下具有显著的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package in.hocg.lock;import org.junit.jupiter.api.Test;import sun.misc.Unsafe;import java.lang.reflect.Field;/** * Created by hocgin on 2018/3/2. * email: hocgin@gmail.com */public class UnsafeTest &#123; static class Demo &#123; private Integer integer; static &#123; System.out.println("static&#123;&#125;"); &#125; &#123; System.out.println("&#123;&#125;"); &#125; public Demo() &#123; integer = 0; System.out.println("Demo()"); &#125; public Integer getInteger() &#123; System.out.println("getInteger()"); return integer; &#125; public void setInteger(Integer integer) &#123; System.out.println("setInteger()"); this.integer = integer; &#125; &#125; /** * 使用 Unsafe 创建对象，不会调用构造函数。 * * @throws NoSuchFieldException * @throws IllegalAccessException * @throws InstantiationException */ @Test public void instantiation() throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Demo o = ((Demo) getUnsafe().allocateInstance(Demo.class)); System.out.println(String.format("hashCode:: %d", o.hashCode())); // 此处会打印 "static&#123;&#125;" 因此仍然会执行静态代码块内容 &#125; /** * 使用 Unsafe 修改私有字段 */ @Test public void altering() throws NoSuchFieldException, IllegalAccessException &#123; Demo demo = new Demo(); Field field = demo.getClass().getDeclaredField("integer"); Unsafe unsafe = getUnsafe(); unsafe.putObject(demo, unsafe.objectFieldOffset(field), 1); System.out.println(String.format("getInteger() = %d", demo.getInteger())); &#125; /** * 使用 Unsafe 抛出异常 * * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void throwing() throws NoSuchFieldException, IllegalAccessException &#123; getUnsafe().throwException(new NullPointerException()); &#125; /** * 分配一块GC无法管理的内存区域 */ @Test public void memory() throws NoSuchFieldException, IllegalAccessException &#123; Unsafe unsafe = getUnsafe(); int size = 1024; // 分配内存地址 long address = unsafe.allocateMemory(size * 1); // 写入 unsafe.putInt(address + 4 * 1, 100); // 读取 int i = unsafe.getInt(address + 4 * 1); System.out.println(i); // 释放内存 unsafe.freeMemory(address); &#125; /** * 进行CAS操作，单纯使用 Java 并不能有效的解决CAS操作, 其主要通过 Unsafe 使用硬件级别来解决CAS操作 * @throws NoSuchFieldException * @throws IllegalAccessException */ @Test public void cas() throws NoSuchFieldException, IllegalAccessException &#123; Unsafe unsafe = getUnsafe(); Demo demo = new Demo(); Field field = demo.getClass().getDeclaredField("integer"); /** * compareAndSwapXXX * 参数 * 1. 指定对象 * 2. 字段的偏移地址 * 3. 当前值 * 4. 期望值 * 返回值 * "认为的旧值"=="实际旧值",修改成"期望值"再返回 True: 修改成功 * "认为的旧值"!="实际旧值",直接返回 False: 修改失败 */ boolean state; // CAS 状态 Integer integer1 = 0; // 认为的旧值 Integer integer2 = demo.getInteger(); // 实际旧值 int o1 = 1; // 期望值 while (!(state = unsafe.compareAndSwapObject(demo, unsafe.objectFieldOffset(field), integer1, o1))) &#123; System.out.println("再次尝试修改"); &#125; System.out.println(String.format("1 .CAS State: %b, 认为的旧值 %d, 实际旧值 %d, 期望值 %d", state, integer1, integer2, o1)); integer2 = demo.getInteger(); // 实际旧值 state = unsafe.compareAndSwapObject(demo, unsafe.objectFieldOffset(field), integer1, o1); System.out.println(String.format("2 .CAS State: %b, 认为的旧值 %d, 实际旧值 %d, 期望值 %d", state, integer1, integer2, o1)); &#125; /** * 利用OS底层的方式来实现挂起，相较于Object.wait()拥有更好的性能 * @throws NoSuchFieldException * @throws IllegalAccessException * @throws InterruptedException */ @Test public void park() throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123; Unsafe unsafe = getUnsafe(); Thread thread = new Thread(() -&gt; &#123; /** * 参数 * 1. isAbsolute, 是否为绝对时间。 * 2. time, 第一个参数(isAbsolute)为 True 时该参数应为纳秒, False 时该参数应为毫秒。0为无线等待，直到unpark。 */ unsafe.park(false, 0); // 挂起 -&gt; WAITING &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format("线程 %s 状态 %s", thread.getName(), thread.getState())); Thread.sleep(100); unsafe.unpark(thread); Thread.sleep(100); System.out.println(String.format("线程 %s 状态 %s", thread.getName(), thread.getState())); &#125; /** * Basic * Unsafe unsafe = Unsafe.getUnsafe(); * * @return * @throws IllegalAccessException * @throws NoSuchFieldException */ public static Unsafe getUnsafe() throws IllegalAccessException, NoSuchFieldException &#123; Field f = Unsafe.class.getDeclaredField("theUnsafe"); f.setAccessible(true); return (Unsafe) f.get(null); &#125;&#125; LockSupport 其本质是Unsafe的薄封装。 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void park() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; /** * 进行挂起 * 本质使用 UNSAFE.park(false, 0L); */ LockSupport.park(); &#125;); thread.start(); Thread.sleep(1000); System.out.println(String.format("挂起线程状态 %s", thread.getState())); // WAITING /** * 进行解除 * 本质使用 UNSAFE.unpark(thread) */ LockSupport.unpark(thread); Thread.sleep(100); System.out.println(String.format("解除挂起线程状态 %s", thread.getState())); // TERMINATED&#125;@Testpublic void blocker() throws InterruptedException &#123; Thread thread = new Thread(()-&gt;&#123; /** * 线程内部有个 parkBlocker 字段, LockSupport 本质上使用 Unsafe 进行内存修改。 */ LockSupport.park("sdas"); &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format("挂起 %s", LockSupport.getBlocker(thread))); // 挂起 sdas LockSupport.unpark(thread); Thread.sleep(100); System.out.println(String.format("解除挂起 %s", LockSupport.getBlocker(thread))); // 解除挂起 null &#125; 阻塞和解除阻塞 总结: 使用LockSupport更具有灵活性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static final Object LOCK = new Object();/** * notifyAll 实现 * @throws InterruptedException */@Testpublic void notifyAll2() throws InterruptedException &#123; Runnable runnable = () -&gt; &#123; System.out.println(String.format("开始运行 %s", Thread.currentThread().getName())); synchronized (LOCK) &#123; try &#123; LOCK.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(String.format("解除锁 %s", Thread.currentThread().getName())); &#125;; CompletableFuture.allOf(CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable)); Thread.sleep(1000); synchronized (LOCK) &#123; LOCK.notify(); System.out.println("通知完毕"); &#125;&#125;/** * unpark 通知所有需自己实现 * @throws InterruptedException */@Testpublic void unparkAll() throws InterruptedException &#123; List&lt;Thread&gt; threads = Collections.synchronizedList(new ArrayList&lt;&gt;()); Runnable runnable = () -&gt; &#123; Thread thread = Thread.currentThread(); threads.add(thread); System.out.println(String.format("开始运行 %s", thread.getName())); LockSupport.park(); System.out.println(String.format("解除锁 %s", thread.getName())); &#125;; CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable), CompletableFuture.runAsync(runnable)); Thread.sleep(1000); for (Thread thread : threads) &#123; LockSupport.unpark(thread); &#125; System.out.println("通知完毕");&#125; park/unpark 与 wait/notify 总结相比于使用 Object.wait/Object.notify,LockSupport.unpark/LockSupport.park 更具有灵活性。 不局限于同步块内 灵活的 API(例如时间) 可指定唤醒(当多个进入wait时Object.notify是随机唤醒其中一个)。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java并发-线程]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[关于Java并发-线程 并发和并行并行: 多核同时执行并发: 单核切换执行 线程线程状态Thread.State @since 1.5关于 Java Thread 状态不得不说的故事(网络上各种版本).. 线程的状态原文URL 多线程操作 关于wait和notify此处涉及到线程中的几个状态，请勿混淆。 使用wait/notify对线程进行操作使用wait/notify对线程进行操作 可能的误区 子线程被关闭，子线程所开启的子线程(子子线程)会不会被关闭？答案: 不会的, 子线程的子线程本质上和子线程是同一等级的并不会被其影响。 守护线程什么情况会被关闭？答案: 1. 守护线程执行完(自然关闭)。 2.所有用户线程的关闭(强行关闭) 什么是守护线程？答案: 当线程t.setDaemon(true)该线程即为守护线程。铛铛铛，最出名的守护线程GC。 用户线程 和 守护线程 的区别？答案: 守护线程[setDaemon(true)]和用户线程大体并没啥区别, 但是守护线程的生命周期是随着所有用户线程的关闭而退出的。 如何杀死一个Java线程？答案: Java已经不推荐使用stop进行线程的关闭了。如果线程是那种持久型操作类型的，建议开辟一个守护类型的线程进行回收(想法参照Go)。 1234567891011121314151617181920@Testpublic void interrupt() throws InterruptedException &#123; Thread thread = new Thread(() -&gt; &#123; while (!Thread.currentThread().isInterrupted()) &#123; System.out.println("Do something"); &#125; &#125;); thread.start(); Thread.sleep(100); System.out.println(String.format("线程 %s 状态 %s", thread.getName(), thread.getState())); /** * 线程 RUNNABLE 状态会标记为关闭，并不进行关闭。 * 线程 其他 状态会标记并进行关闭。 * - 已经不推荐使用 thread.stop(); 可能会引起资源问题。 */ thread.interrupt(); Thread.sleep(100); System.out.println(String.format("线程 %s 状态 %s", thread.getName(), thread.getState()));&#125; 线程池前置 Runable 无返回值 Callable 有返回值 Future 返回结果 newCachedThreadPool() 创建一个可缓存的线程池，其指定线程池中线程的存活时间，默认为 60s。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 这边源码有注释:当你想实现一些缓存相关的细节(如超时时间)，应该自己使用ThreadPoolExecutor的构造函数来创建。 newSingleThreadExecutor 创建一个新的单线程Executor，其指定线程池中线程最大数量为1。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 此处为何使用门面模式呢？注释写明只暴露ExecutorService接口的方法, 应该是为了防止强制使用ThreadPoolExecutor相关函数。 相比于newFixedThreadPool(1), 该函数保证不会被重新分配到其他的线程。 newFixedThreadPool 创建一个固定大小的线程池12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 注释中说明: 提交的任务线程将一直存在，直到使用 ExecutorService#shutdown 进行退出 newScheduledThreadPool 创建一个固定大小且可定时的线程池 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; newSingleThreadScheduledExecutor 创建一个大小为1且可定时的线程池 1234public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125; 同样使用了门面模式 newWorkStealingPool 并行 创建一个并行线程池(并行数目默认为:系统可用线程数目)@since 1.8 123456public static ExecutorService newWorkStealingPool() &#123; return new ForkJoinPool (Runtime.getRuntime().availableProcessors(), ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; Fork/Join 并行 使用并行进行操作@since 1.7 相关类/接口说明 ForkJoinTask 顶层接口, 其实现了Future。 RecursiveTask 有返回值 RecursiveAction 无返回值 ForkJoinPool 类似Executor 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Main.java* 响应结果:* TASK:ForkJoinPool.commonPool-worker-1* TASK:ForkJoinPool.commonPool-worker-1* TASK:ForkJoinPool.commonPool-worker-2* TASK:ForkJoinPool.commonPool-worker-1* 有效值 4* TASK:ForkJoinPool.commonPool-worker-2* 有效值 5* TASK:ForkJoinPool.commonPool-worker-1* 有效值 6* TASK:ForkJoinPool.commonPool-worker-1* 有效值 7* 22**/ @Test public void forkJoinPool() throws ExecutionException, InterruptedException &#123; ForkJoinPool forkJoinPool = ForkJoinPool.commonPool(); IRecursiveTask iRecursiveTask = new IRecursiveTask(); ForkJoinTask&lt;Integer&gt; task = forkJoinPool.submit(iRecursiveTask); System.out.println(task.get()); &#125;/*** IRecursiveTask.java* .fork() 进行任务分裂，并使用线程进行执行* .join() 等待执行完成并获取结果**/public class IRecursiveTask extends RecursiveTask&lt;Integer&gt; &#123; public static AtomicInteger FLAG = new AtomicInteger(0); @Override protected Integer compute() &#123; System.out.println("TASK:" + Thread.currentThread().getName()); FLAG.addAndGet(1); if (FLAG.get() &gt; 3) &#123; System.out.println(String.format("有效值 %d", FLAG.get())); return FLAG.get(); &#125; // 为什么不用 this.fork()？ // this.fork() 返回的是 this Integer join1 = new IRecursiveTask().fork().join(); Integer join2 = new IRecursiveTask().fork().join(); return join1 + join2; &#125;&#125; CompletableFuture/CompletionStage 异步+并行 相比于1.7进行了更简便、友好的封装，并增加了异步通知的功能，摆脱了阻塞问题。@since 1.8 CompletableFuture CompletableFuture实现了CompletionStage用于进行异步并行,并提供函数让多个CompletionStage可以进行组合操作和或操作。 静态函数, 返回CompletionStage CompletableFuture.anyOf 任意一个执行完成 CompletableFuture.allOf 所有执行完成 CompletableFuture.supplyAsync 执行单个异步,有返回值(默认使用:ForkJoinPool#commonPool())。 CompletableFuture.runAsync 执行单个异步,无返回值 CompletableFuture.completedFuture 设定结果 CompletionStage 函数 thenXXX 流的流向(等待上一步执行完成) thenApplyXXX 进行输入的转换(Apply：有输入有输出) thenRunXXX 对上一个结果不关心，也没有返回值(Run：无输入无输出) thenAcceptXXX 进行输入对处理(Accept：有输入无输出) thenAcceptBothXXX(CompletionStage,BiConsumer) 加入CompletionStage, 进行指定处理(组合操作，有输入无输出)。 thenCombineXXX(CompletionStage,BiFunction) 加入CompletionStage, 进行指定处理(组合操作，有输入有输出)。 runAfterXXX 运行之后 runAfterBothXXX(CompletionStage, Runnable) 加入CompletionStage, 并在其运行后指定执行(组合操作，无输入无输出)。 runAfterEither(CompletionStage, Runnable) (或操作) 完成 whenCompleteXXX 完成之后处理。(有输入无输出) handleXXX 完成之后处理。(有输入有输出) 异常处理 exceptionally 异常处理。 其他 .complete() // 立即结束并返回指定的结果 .completeExceptionally() //立即异常结束 说明: xxxEither 加入CompletionStage进行OR操作(与之前的进行对比),取最先返回的结果取其结果值。 xxxAsync 都是异步执行 稍微提一下,线程组 为管理 Thread 而存在的，可以进行批量标记、检查。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志系统ELK在Spring Boot上的初步集成]]></title>
    <url>%2F2018%2F01%2F22%2F%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%20ELK%20%E5%9C%A8%20Spring%20Boot%20%E4%B8%8A%E7%9A%84%E5%88%9D%E6%AD%A5%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[日志系统 ELK 在 Spring Boot 上的初步集成 😋 ELK Elasticsearch + Logstash + Kibana，一个比较流行的日志系统。当然，你也可以尝试使用阿里云。如果钱多的话:) Logstash 日志搬运, 可以指定从 Redis/Log4j..处获取日志信息，然后进行过滤，再提交给 Elasticsearch 进行分析。 1234# 安装 &amp; 启动brew install logstash# brew services restart logstash# ./bin/logstash -f config/logstash.conf Elasticsearch 日志存储 / 查询 / 分析 123# 安装 &amp; 启动brew install elasticsearchbrew services restart elasticsearch 如果你想直接查看、操作或者研究 elasticsearch 存储的内容，可以考虑使用 elasticsearch-head 进行操作。 UI 操作界面12345git clone git://github.com/mobz/elasticsearch-head.gitcd elasticsearch-headnpm installnpm run startopen http://localhost:9100 如果 Elasticsearch 安装了 X-Path 那么需要在配置文件中(elasticsearch.yml), 加入:123http.cors.enabled: true http.cors.allow-origin: '*' http.cors.allow-headers: "Authorization" 对了, 这里有一款elasticsearch-head Chrome Plug-in 推荐。 Kibana UI 界面 1234wget https://www.elastic.co/downloads/kibanatar -xvf kibana.tar.gz./kibana/bin/kibanaopen http://localhost:5601/ Spring Boot 集成 pom.xml 引入 logback 支持。 12345&lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt;&lt;/dependency&gt; 在 resources/ 文件夹内创建 logback-spring.xml 文件。 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender"&gt; &lt;destination&gt;dev.local:4560&lt;/destination&gt; &lt;encoder charset="UTF-8" class="net.logstash.logback.encoder.LogstashEncoder"/&gt; &lt;/appender&gt; &lt;include resource="org/springframework/boot/logging/logback/base.xml"/&gt; &lt;root level="INFO"&gt; &lt;appender-ref ref="LOGSTASH"/&gt; &lt;appender-ref ref="CONSOLE"/&gt; &lt;/root&gt;&lt;/configuration&gt; 配置 logstash, 创建 logstash.conf。 123456789101112131415input &#123; tcp &#123; port =&gt; 4560 codec =&gt; json_lines &#125;&#125;output &#123; elasticsearch &#123; action =&gt; &quot;index&quot; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;applog&quot; ; user =&gt; &quot;elastic&quot; ; password =&gt; &quot;changeme&quot; &#125;&#125; 启动logstash ./bin/logstash -f logstash.conf 使用。12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest@Slf4jpublic class TestControllerTest &#123; Random random = new Random(); @Test public void testList() throws Exception &#123; while (true) &#123; Thread.sleep(1000); log.info("Hello world form hocgin"); if (random.nextBoolean()) &#123; log.info("sksdjkf " + random.nextInt(1000)); &#125; &#125; &#125;&#125; 关于 Kibana 安全配置 Configuring Security in Kibana 安装 x-pack. 123456logstash-plugin install x-packelasticsearch-plugin install x-packkibana-plugin install x-pack 修改 config/kibana.yml 12elasticsearch.username: &quot;elastic&quot; elasticsearch.password: &quot;changeme&quot; 修改 logstash.conf。 123456789101112131415input &#123; tcp &#123; port =&gt; 4560 codec =&gt; json_lines &#125;&#125;output &#123; elasticsearch &#123; action =&gt; &quot;index&quot; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;applog&quot; user =&gt; &quot;elastic&quot; password =&gt; &quot;changeme&quot; &#125;&#125; 如果忘记 ElasticSearch 密码 停止 ElasticSearch 服务 创建一个管理员用户 1x-pack/users useradd my_admin -p my_password -r superuser 启动 ElasticSearch 服务 使用 API 修改密码1234567891011121314curl -u my_admin -XPUT 'http://localhost:9200/_xpack/security/user/elastic/_password?pretty' -H 'Content-Type: application/json' -d'&#123; "password" : "new_password"&#125;'``## ELK Docker- [ELK Docker](https://github.com/spujadas/elk-docker)简而言之:```shell# :5601 - Kibana# :9200 - Elasticsearch# :5044 - Logstashsudo docker run -p 5601:5601 -p 9200:9200 -p 5044:5044 -it --name elk sebp/elk :2019年3月23日，星期六 补充 ELKL配置文件位置: {}/config/123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384; 输入input &#123; file &#123; path =&gt; [&quot;&#123;path&#125;&quot;] ; 设置类型 type =&gt; &quot;nginx_access&quot; ; 起点位置 start_position =&gt; &quot;beginning&quot; &#125;&#125;; 数据清洗filter &#123; if [type] == &quot;nginx_access&quot; &#123; grok &#123; patterns_dir =&gt; &quot;&#123;path&#125;&quot; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;NGINXACCESS&#125;&quot; &#125; &#125; ; 格式化date字段时间格式 date &#123; match =&gt; [&quot;timestamp&quot;, &quot;dd/MMM/YYYY:HH:mm:ss Z&quot;] &#125; ; 解析param字段 if[param] &#123; ruby &#123; init =&gt; &quot;@kname = [&apos;quote&apos;, &apos;url_args&apos;]&quot; code =&gt; &quot; new_event = LogStash::Event.new(Hash[@kname.zip(event.get(&apos;param&apos;).split(&apos;?&apos;))]) new_event.remove(&apos;@timestamp&apos;) event.append(new_event) &quot; &#125; &#125; if[url_args] &#123; ruby &#123; init =&gt; &quot;@kname = [&apos;key&apos;, &apos;value&apos;]&quot; code =&gt; &quot; event.set( &apos;nested_args&apos;, event.get(&apos;url_args&apos;).split(&apos;&amp;&apos;).collect &#123;|i| Hash[@kname.zip(i.split(&apos;=&apos;))]&#125; ) &quot; remove_field =&gt; [&quot;url_args&quot;, &quot;param&quot;, &quot;quote&quot;] &#125; &#125; ;修改指定字段的内容 mutate &#123; ; 转换类型 convert =&gt; [&quot;response&quot;, &quot;integer&quot;] remove_field =&gt; [&quot;timestamp&quot;] &#125; &#125; &#125;; 输出output &#123; stdout &#123; codec =&gt; rubydebug &#125; elasticsearch &#123; ; 位置 hosts =&gt; [&quot;&#123;url&#125;&quot;] ; 索引格式 index =&gt; &quot;logstash-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;&quot; document_type =&gt; &quot;%&#123;type&#125;&quot; ; 每次多少数量 flush_size =&gt; 200 ; 发送间隔时间 idle_flush_time =&gt; 1 ; 是否重新清洗 sniffing = true ; 用户名 user =&gt; &quot;&#123;user&#125;&quot; ; 密码 password =&gt; &quot;&#123;password&#125;&quot; &#125;&#125; 解析器文件位置: {}/config/patterns/ K配置文件位置: {}/config/kibana.yml123elasticsearch.url: '&#123;url&#125;'elasticsearch.username: '&#123;username&#125;'elasticsearch.password: '&#123;password&#125;' 默认端口: 8601]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot启动过程和Bean的创建过程]]></title>
    <url>%2F2018%2F01%2F15%2FSpring%20Boot%20%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%20Bean%20%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这几天分析了一下 Spring Boot 启动过程和 Bean 的创建过程，在此记录下来。如果有什么不对的地方，欢迎提出🙏。 启动过程123456789101112131415161718192021222324252627282930// 将 new SpringApplicationBuilder(sources...) 加入 sources 列表。// ---------------推断是否是Web环境------------// SpringApplication.deduceMainApplicationClass#248// 主要是否包含 javax.servlet.Servlet ..// ---------------Initializer------------// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// - spring-boot-actuator-1.5.8.RELEASE.jar// - spring-data-redis-1.8.8.RELEASE.jar// - ..// 获得 Key 为`org.springframework.context.ApplicationContextInitializer`的所有节点(Class), 实例化并通过 @Order 进行排序。// ---------------Listener------------// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// - spring-boot-actuator-1.5.8.RELEASE.jar// - spring-data-redis-1.8.8.RELEASE.jar// - ..// 获得 Key 为`org.springframework.context.ApplicationListener`的所有节点(Class), 实例化并通过 @Order 进行排序。// ---------------推断Main类------------// SpringApplication.deduceMainApplicationClass#252// 推断当前应用的入口函数(方法名为main)。 new SpringApplicationBuilder() .sources(Application.class) // -------判断是否热部署状态--------- // ---如果设置了 parent() 进行配置----- // configureAsChildIfNecessary(args);如果配置了会加入一个 ParentContextApplicationContextInitializer // ---------初始化当前应用---------- // SpringApplication.run(args) .run(args); 分析 SpringApplication.run(args)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 计时器, 用于记录启动时间StopWatch stopWatch = new StopWatch();stopWatch.start();ConfigurableApplicationContext context = null;FailureAnalyzers analyzers = null;// 设置为无输入/输出设备模式configureHeadlessProperty();// 使用 ClassLoader// 分析引入所有包的: META-INF/spring.factories 文件// 获得 Key 为`org.springframework.boot.SpringApplicationRunListener`的所有节点(Class), 实例化并通过 @Order 进行排序。// 并封装进入 SpringApplicationRunListeners 类。SpringApplicationRunListeners listeners = getRunListeners(args);// 由 SpringApplicationRunListeners 控制类的启动。listeners.starting();try &#123; // 封装我们提供的 args 参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 根据是否 Web 环境(webEnvironment) 获得环境(StandardServletEnvironment/StandardEnvironment) // - 加载默认的参数源(StandardServletEnvironment.customizePropertySources) // - 加载我们提供的启动参数(args)作为参数源。当然，前提是 addCommandLineProperties 为 true。 // 通过 SpringApplicationRunListeners.environmentPrepared(..) 处理上面提供的应用环境参数。 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); // 打印 banner。本身是由 Banner 类实现的 Banner printedBanner = printBanner(environment); // 实例化一个应用的当前环境, Spring Boot 提供了2种环境根据是否是web环境进行动态实例化(webEnvironment), 分别是(AnnotationConfigEmbeddedWebApplicationContext/ConfigurableWebApplicationContext) // 这是会创建两个用于扫描注解的重要对象 // - AnnotatedBeanDefinitionReader 读取器, 设置环境参数，创建时注册了一系列的用于 Bean 的解析器(AnnotatedBeanDefinitionReader#65) // - ClassPathBeanDefinitionScanner 扫描器, 设置路径 &amp; 环境 &amp; 拦截器(Component.class) context = createApplicationContext(); // ----------创建失败解析器------------ // 当初始化出现错误时进行错误分析器 // 使用 ClassLoader // 分析引入所有包的: META-INF/spring.factories 文件 // - spring-boot-actuator-1.5.8.RELEASE.jar // - spring-data-redis-1.8.8.RELEASE.jar // - .. // 获得 Key 为`org.springframework.boot.diagnostics.FailureAnalyzer`的所有节点(Class), 实例化并通过 @Order 进行排序。 // 并加入 FailureAnalyzers 管理。 analyzers = new FailureAnalyzers(context); // 详情见下方【SpringApplication.prepareContext(..)】 prepareContext(context, environment, listeners, applicationArguments, printedBanner); // 详情见下方【分析 AbstractApplicationContext.refreshContext(context);】 refreshContext(context); // ApplicationRunner &amp; CommandLineRunner.run 按类型从 Bean 容器中取出，并调用 run(..) afterRefresh(context, applicationArguments); // 广播通知 SpringApplicationRunListener.finished listeners.finished(context, null); // 关闭计时器，记录启动时间 stopWatch.stop(); // 是否启动日志 if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context;&#125; catch (Throwable ex) &#123; // 处理退出异常, 存储 ExitCodeEvent // 广播通知 listener(listener.finished(context, exception);) // 使用 analyzers 进行失败分析 handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex);&#125; 分析 SpringApplication.prepareContext(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; // 设置环境参数 context.setEnvironment(environment); // // - 注册自定义 beanNameGenerator，如果有的话。 // - 注册自定义 resourceLoader，如果有的话。 // 其中, resourceLoader 分为两种类型 // - GenericApplicationContext(ResourceLoader) // - DefaultResourceLoader(ClassLoader) postProcessApplicationContext(context); // 初始化所有之前加载的 ApplicationContextInitializer 节点 applyInitializers(context); // 所有监听器通知进入 contextPrepared 阶段 listeners.contextPrepared(context); // 是否启动日志 if (this.logStartupInfo) &#123; // 交由顶级打印日志信息 logStartupInfo(context.getParent() == null); // 打印配置文件信息 logStartupProfileInfo(context); &#125; // Add boot specific singleton beans context.getBeanFactory().registerSingleton("springApplicationArguments", applicationArguments); if (printedBanner != null) &#123; context.getBeanFactory().registerSingleton("springBootBanner", printedBanner); &#125; // Load the sources Set&lt;Object&gt; sources = getSources(); Assert.notEmpty(sources, "Sources must not be empty"); // 创建 Bean 的加载器, BeanDefinitionLoader // ---------------解析器--------------- // - 注解 AnnotatedBeanDefinitionReader // - xml XmlBeanDefinitionReader // - goovy GroovyBeanDefinitionReader // - 类路径 ClassPathBeanDefinitionScanner // ---------------自定义----------------- // - 加载自定义 beanNameGenerator，如果有的话。 // - 加载自定义 resourceLoader，如果有的话。 // - 加载自定义 environment，如果有的话。 load(context, sources.toArray(new Object[sources.size()])); // 通知环境加载结束 listeners.contextLoaded(context);&#125; 分析 AbstractApplicationContext.refreshContext(context);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // 设置为启动状态 // 校验必须字段, 使用 ConfigurablePropertyResolver#setRequiredProperties 进行设置。 // Prepare this context for refreshing. prepareRefresh(); // 刷新当前 beanFactory 的ID, 值得一提的是默认的 BeanFactory 是 org.springframework.beans.factory.support.DefaultListableBeanFactory。 // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // ----------BeanFactory重点初始化(AbstractApplicationContext.prepareBeanFactory#627)--------------- // - 设置 BeanClassLoader // - 设置 字符解析器(SpelExpressionParser) // - 设置 资源位置 // - 添加 处理器 // - 忽略 某些接口 // - 注册某些解析器解决依赖关系 // - 添加一个监听器 // - 注册 默认的 environment Bean(3个), 如果不存在的话。 // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // AnnotationConfigEmbeddedWebApplicationContext.postProcessBeanFactory#182 // - 加入 WebApplicationContextServletContextAwareProcessor 作为 BeanPostProcessor // - beanFactory.ignoreDependencyInterface(ServletContextAware.class); // 也会读取注册的注解类 和 配置要扫描的包位置。 // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry) // 通过 ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry#308 扫描所有应用文件。 // - 扫描预制的配置文件 // - 扫描应用的所有注解配置成 Bean 字典 // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // 使用 BeanPostProcessor.class 获取 Bean(所有 Bean 均在beanDefinitionMap 内含有), 排序后, 注册为 Bean 处理器。 // 加入 BeanPostProcessorChecker.class 用于监听Bean的创建周期。 // - priorityOrderedPostProcessors // - orderedPostProcessors // - nonOrderedPostProcessors // - internalPostProcessors // 加入 ApplicationListenerDetector 作为兜底 BeanPostProcessor // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // 初始化消息资源(MessageSource) // 一般是作为 i18 的资源文件。 // Initialize message source for this context. initMessageSource(); // 初始化应用广播器(ApplicationEventMulticaster) // 一般用于管理 ApplicationListener // Initialize event multicaster for this context. initApplicationEventMulticaster(); // EmbeddedWebApplicationContext.onRefresh#131 // 创建嵌入式 Servlet 容器 // Initialize other special beans in specific context subclasses. onRefresh(); // 注册 listener beans 到 ApplicationEventMulticaster。 // 广播 (Set&lt;ApplicationEvent&gt; earlyEventsToProcess).multicastEvent // Check for listener beans and register them. registerListeners(); // - 转化 BeanFactory 类型 // - 提供默认的嵌入值解析器，如果需要的话。 // - 装载 LoadTimeWeaverAware.class 类型的 Bean // - 停止临时的 ClassLoad // - 冻结配置 // - 预先装载所有单例 Bean。 // - 初始化@Controller @RequestMapping 之类的过程, 基本上我们使用的注解都是该阶段进行设置的。 // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // ----------发布事件通知---------------- // 注册 LifecycleProcessor，并发布 onRefresh() 事件。 // earlyApplicationEvents.add(new ContextRefreshedEvent(this)) 加入 Context 刷新事件 // 注册 LiveBean，如果有的话。..DevTool Debug 那个 // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 关于 Bean BeanDefinitionRegistry, Bean 定义注册表，类似 Bean 的仓库。 BeanDefinition 存储 Bean 的信息。 Bean 的 scope 种类, prototype, 每次获取时创建。 request, session, global session, singleton(默认), 单例。 BeanFactory, Bean 工厂。 用于 注册 Bean, 获得 Bean, 清除 Bean, 配置 Bean 的相关策略。 DefaultListableBeanFactory 是 Spring 默认的 BeanFactory。 registeredSingletons 已注册的 Bean 列表, 存储 BeanName。 singletonObjects 存储 Bean 对象, 使用 Map 结构。 earlySingletonObjects 存储由 ObjectFactory 创建的 Bean 对象。 singletonFactories 存储之前创建的 ObjectFactory 其本质是 Bean 对象。 beanDefinitionMap 扫描存储的记录，可以理解为 Bean 的总名单。 mergedBeanDefinitions 获取 Bean getBean(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169// AbstractBeanFactory.class @Override public Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false); &#125; @SuppressWarnings("unchecked") protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 解析 BeanName final String beanName = transformedBeanName(name); Object bean; // 检查缓存中是否存在该 Bean, 如果存在则实例化。 // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug("Returning eagerly cached instance of singleton bean '" + beanName + "' that is not fully initialized yet - a consequence of a circular reference"); &#125; else &#123; logger.debug("Returning cached instance of singleton bean '" + beanName + "'"); &#125; &#125; bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // Bean 不在缓存 // 当正在创建的 Bean 的 Scope 为 Prototype 时，抛出异常。 // 因为 Prototype 模式无法解决依赖问题。 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // 如果当前 BeanFactory 不包括该 BeanName 并且该 BeanFactory 有父 BeanFactory 时，尝试从父 BeanFactory 获取该 Bean。 // Check if bean definition exists in this factory. BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. String nameToLookup = originalBeanName(name); if (args != null) &#123; // Delegation to parent with explicit args. return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; // 如果不只依靠类型进行获取, 进行标记。 if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; // 将解析转化为 Bean 的信息，注册并获取其依赖的 Bean。 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Circular depends-on relationship between '" + beanName + "' and '" + dep + "'"); &#125; registerDependentBean(dep, beanName); getBean(dep); &#125; &#125; // 当 Bean 的 Scope 为 Singleton 时 // Create bean instance. if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 当 Bean 的 Scope 为 Prototype 时 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 当 Bean 的 Scope 为 其他 时 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException("No Scope registered for scope name '" + scopeName + "'"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, "Scope '" + scopeName + "' is not active for the current thread; consider " + "defining a scoped proxy for this bean if you intend to refer to it from a singleton", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 检查获得的 Bean 类型是否符合预期结果。 // Check if required type matches the type of the actual bean instance. if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Failed to convert bean '" + name + "' to required type '" + ClassUtils.getQualifiedName(requiredType) + "'", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean; &#125; 创建 Bean createBean(..)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163// AbstractAutowireCapableBeanFactory.class @Override protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Creating instance of bean '" + beanName + "'"); &#125; RootBeanDefinition mbdToUse = mbd; // 根据信息(mbd, beanName)获取 Bean 的类型 // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // 校验重载函数 // Prepare method overrides. try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, "Validation of method overrides failed", ex); &#125; try &#123; // Spring 提供的，由 BeanPostProcessor 进行处理接入点。 // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, "BeanPostProcessor before instantiation of bean failed", ex); &#125; // 默认的创建 Bean 方式 Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug("Finished creating instance of bean '" + beanName + "'"); &#125; return beanInstance; &#125;// AbstractAutowireCapableBeanFactory.class protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // 根据 Bean 信息实例化 Bean // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 使用 MergedBeanDefinitionPostProcessor 进行处理 // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, "Post-processing of merged bean definition failed", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 单例 &amp; 允许循环引用 &amp; 正在创建 if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Eagerly caching bean '" + beanName + "' to allow for resolving potential circular references"); &#125; // 使用 ObjectFactory 来管理 Bean 防止循环依赖。 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 对 Bean 的属性进行填充 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; // 初始化 Bean 实例 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex); &#125; &#125; if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); // 存在已创建的单例, 一般情况为解决依赖的时候。 if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; // 允许循环依赖不一致 &amp; Bean 含有依赖。 // 此时如果存在依赖，将会发生异常。 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, "Bean with name '" + beanName + "' has been injected into other beans [" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + "] in its raw version as part of a circular reference, but has eventually been " + "wrapped. This means that said other beans do not use the final version of the " + "bean. This is often the result of over-eager type matching - consider using " + "'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."); &#125; &#125; &#125; &#125; // 注册一次性 Bean // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex); &#125; return exposedObject; &#125;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 交叉编译 OpenWrt 上运行的 Golang 程序]]></title>
    <url>%2F2017%2F11%2F23%2F%E4%BD%BF%E7%94%A8%20Docker%20%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%20OpenWrt%20%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%9A%84%20Golang%20%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[>.&lt; 前言 使用 https://github.com/gomini/go-mips32 对 Go 程序进行交叉编译. 使用 Docker 交叉编译 Go 程序 拉取镜像 1docker pull conoro/go-mips32:v1 启动镜像并挂载本地目录 123456docker run -it -v 程序目录:/go/src conoro/go-mips32:v1 /bin/shcd src# 编译# export GOOS=linux# export GOARCH=mips32lego build main.go]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>Docker</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自编译 OpenWrt 系统]]></title>
    <url>%2F2017%2F11%2F22%2F%E8%87%AA%E7%BC%96%E8%AF%91%20OpenWrt%20%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[😌 整理、记录一下步骤.. 前置更改源123sed -i.bak 's/\/us.archive.ubuntu.com\//\/cn.archive.ubuntu.com\//g' /etc/apt/sources.listsudo apt update 关闭IPv6echo 1 &gt; /proc/sys/net/ipv6/conf//disable_ipv6 前置安装 git subversion make automake autoconf gcc g++ binutils make, 缺省安装 libncurses5-dev libssl-dev gawk 前置 GitHub(git clone https://github.com/openwrt/openwrt) 获取 OpenWrt, 更改 openWrt 目录为当前用户所有权12# 例如:chown -R hocgin:hocgin openwrt 编译(openwrt/)编译过程 make ./script/feeds update -a ./script/feeds install -a 14. make deconfig # 使用默认的配置 15. make menuconfig # 基于终端的一种配置方式，提供了文本模式的图形用户界面，用户可以通过光标移动来浏览所支持的各种特性。 固件配置, 可以选择编译的软件包 ## 部分选项 - 架构(AR7xxx) - FLASH(Generic) - 路由器型号(WNDR3800) - 文件系统(squashfs) - 通用设置 - [-] Crytographically signed package lists - [-] Compile with support for patented functionallty - [-] Enable shadow password support - [-] Crash logging - [-] Compile the kernel with debug information - [-] Compile the kernel SysRq support - [-] Enable process core dump support - [-] Enable printk timestamps - [-] Enable Ipv6 support in packages - [-] Compile certain packages parallelized - [-] Enable gcc format-security - [-] Build the OpenWrt Image Builder - [-] In - [-] Build the OpenWrt SDK - [-] Package the OpenWrt-based Toolchain 其余默认。 make kernel_config 内核配置[开启浮点数模拟(FPU)] make V=s -j&lt;处理器数量&gt; 编译完成后，移出bin/ar71xx/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64.tar.bz2 文件, 并解压(tar xvf). 进入(OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64/) 编译成镜像 12345# 检查基础镜像parallels@ubuntu:~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64$ make image PROFILE=WNDR3700# 包含必备包`预装软件`的镜像parallels@ubuntu:~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64$ make image PROFILE=WNDR3700 PACKAGES="-dnsmasq dnsmasq-full ipset openssh-keygen openssh-server openssh-sftp-server kmod-fs-ext4 kmod-fs-ntfs kmod-fs-vfat kmod-usb2 kmod-usb-core kmod-usb-storage kmod-usb-storage-extras luci-app-firewall luci-app-samba luci-app-upnp luci luci-theme-material curl kmod-ipt-nat-extra libpcre" 生成镜像(~/OpenWrt/OpenWrt-ImageBuilder-ar71xx-generic.Linux-x86_64/bin/) openwrt-ar71xx-generic-wndr3800-squashfs-sysupgrade.bin openwrt-ar71xx-generic-wndr3800-squashfs-factory.img]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[制作.ipk安装文件]]></title>
    <url>%2F2017%2F11%2F19%2F%E5%88%B6%E4%BD%9C.ipk%2F</url>
    <content type="text"><![CDATA[.ipk 本质是tar.gz格式的压缩包, 按照某种规范格式(类似.deb包)进行 … 前言 .ipk 本质是tar.gz格式的压缩包, 按照某种规范格式(类似.deb包)进行压缩而成的。 当我们对它的内容进行操作时候所使用的用户即是它安装后所拥有的用户和权限(sudo chown root:root -R .)。 已经存在的文件并不能进行替换, 切记。 文件介绍1234.├── control.tar.gz # 安装/卸载 脚本├── data.tar.gz # 二进制/配置文件..└── debian-binary # 固有文件 control.tar.gz 内容1234.├── control # 文件介绍[包括: 依赖/版本/架构/作者..]├── postinst # 安装脚本└── postrm # 卸载脚本 control 此处举个栗子1234567Package: IPKName # .ipk NAMEVersion: 1Section: netPriority: optionalArchitecture: ar71xx # 系统架构Maintainer: hocgin &lt;hocgin@gmail.com&gt;Description: my first ipk postinst 安装脚本 因为前言的3原因, 当我们需要对已存在文件进行修改时, 只能使用写入的方式进行修改。 例如:12#!/bin/shecho "installed done" &gt; /tmp/ipk.log postinst 卸载脚本 自己约的X🤣。。 例如:12#!/bin/shrm -rf /tmp/ipk.log 打包~1sudo tar -czf control.tar.gz * data.tar.gz 此处完全是根据你要增加的脚本按根目录进行存放的。 例如:1234567891011121314151617181920.├── bin│ ├── ss-redir│ └── ss-tunnel├── data.tar.gz├── etc│ ├── dnsmasq.d│ │ ├── address.conf│ │ ├── dns.conf│ │ ├── ipset.conf│ │ ├── option.conf│ │ └── server.conf│ ├── pdnsd.conf│ └── shadowsock.json├── root│ ├── addDnsmasq.sh│ └── changeService.sh└── usr └── sbin └── pdnsd 打包~1sudo tar -czf data.tar.gz * 最后 将三个文件放在一起进行打包 1sudo tar -czf mIPK.ipk *]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>OpenWrt</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA 中的 Spring Boot 开发模式]]></title>
    <url>%2F2017%2F10%2F20%2FIDEA-%E4%B8%AD%E7%9A%84-Spring-Boot-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[🤑 完全热部署, 配置完成瞬间舒爽无比。 .java 文件和配置文件更改后进行自动重启 更改IDEA中的如下设置Build project automatically。 打开IDEA的Action window, 快捷键如下: Linux : CTRL+SHIFT+A Mac OSX : SHIFT+COMMAND+A Windows : CTRL+ALT+SHIFT+/输入(选择) Registry..., 选择如下: 此时进行.java 文件和配置文件修改时, 会进行 Spring Boot 重启。 当更改静态HTML进行实时刷新 加入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 安装浏览器插件 Chrome 插件 Firefox 插件 Safari 插件 更改文件和静态页面(HTML)都可以进行热部署类。 实时刷新thymeleaf模版文件配置文件设置取消缓存: 123spring: thymeleaf: cache: false Chrome 设置取消缓存: 此时几乎所有的东西(.java/`/SpringBoot 配置文件`)都可以进行热部署了。包括: 修改 .java 文件。 修改页面(thymeleaf html ..) 文件。 修改 SpringBoot 配置文件。 增删静态文件(css js 图片)。 关于定制化热部署 可查询spring-boot-devtools的使用, 使用以下子项进行配置。 12spring: devtools: IDEA 扩展 pom.xml 添加以下依赖可查看更多的信息。该依赖是可查看监控信息的, 更多使用移步 Google.com。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; IDEA 显示如下:]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery.pjax 无法再次初始化当前页面的JS]]></title>
    <url>%2F2017%2F10%2F19%2FJQuery.pjax%E6%97%A0%E6%B3%95%E5%86%8D%E6%AC%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84JS%2F</url>
    <content type="text"><![CDATA[Pjax 很久之前用过一次, 这一次在整合后台模版，发现网上对这个坑竟然是改源码…在这详细记录一下。 问题当 JQuery.pjax 加载页面后, 再次加载该页面时，其内部的初始化 JS 或 script inline 并不能被再次执行。例如:123456789101112131415161718192021222324252627&lt;div id="pjax-container"&gt; &lt;!-- .. --&gt;&lt;/div&gt;&lt;!-- jQuery 3 --&gt;&lt;script th:src="jquery.min.js"&gt;&lt;/script&gt;&lt;!-- jQuery Pjax --&gt;&lt;script th:src="jquery.pjax.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(document).ready(function () &#123; if ($.support.pjax) &#123; $(document).pjax('a[data-pjax]', '#pjax-container', &#123; maxCacheLength: 0, push: false, replace: true, fragment: '#pjax-container', timeout: 8000 &#125;); &#125; &#125;);&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function()&#123; console.log("不能被再次执行"); &#125;);&lt;/script&gt;&lt;!-- 不能被再次执行 --&gt;&lt;script type="text/javascript" src="init.js"&gt;&lt;/script&gt; 解决办法 其原因是JQuery.pjax对js进行了缓存, 可以使用JQuery进行加载, 当然其代价是牺牲了这部分都缓存, 不过因为是特定页面的脚本, 牺牲的缓存几乎可以忽略。例子如下:123456789101112131415161718192021222324252627282930&lt;div id="pjax-container"&gt; &lt;!-- .. --&gt; &lt;!-- 能被再次执行 --&gt; &lt;script th:inline="javascript"&gt; $.getScript('/admin-lte/dist/js/pages/dashboard2.js'); &lt;/script&gt; &lt;script type="text/javascript" src="init.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(function()&#123; console.log("能被再次执行"); &#125;); &lt;/script&gt;&lt;/div&gt;&lt;!-- jQuery 3 --&gt;&lt;script th:src="jquery.min.js"&gt;&lt;/script&gt;&lt;!-- jQuery Pjax --&gt;&lt;script th:src="jquery.pjax.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(document).ready(function () &#123; if ($.support.pjax) &#123; $(document).pjax('a[data-pjax]', '#pjax-container', &#123; maxCacheLength: 0, push: false, replace: true, fragment: '#pjax-container', timeout: 8000 &#125;); &#125; &#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Pjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf 3.0 手册]]></title>
    <url>%2F2017%2F10%2F18%2FThymeleaf-3.0-%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Spring 官方推崇的模版引擎，遵循 HTML5规范。 HTML5若要完全遵循HTML5规范，可使用 data-th-* 代替 th:*。 标签th:each foreach 循环语法: th:each=”obj, index:list”12345678&lt;th:block th:each="permission, i:$&#123;role.permissions&#125;"&gt; &lt;tr th:attr="data-tt-id=$&#123;permission.id&#125;, data-tt-parent-id=$&#123;permission.parent&#125;, data-tt-branch=$&#123;permission.hasChildren&#125;"&gt; &lt;td th:text="$&#123;permission.name&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;permission.url&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;permission.type&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;permission.permission&#125;"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/th:block&gt; th:inline 解析内嵌语法, 一般是混合javascript语法: th:inline=”javascript|text|none”123456&lt;script th:inline="javascript"&gt;/*&lt;![CDATA[*/var welcome = [[$&#123;welcome&#125;]] '这是一个 Thymeleaf 变量';var default_value = [[$&#123;maxCount?:0&#125;]]/*]]&gt;*/&lt;/script&gt; th:fragment 定义模版，语法: th:fragment=”模块名(变量)”变量部分为可选, 配合 th:with 使用。123456&lt;!-- 不保留本身的标签, 保留 th:fragment 的标签 --&gt;&lt;div th:replace="/admin/fragments/header::header"&gt;&lt;/div&gt;&lt;!-- 保留本身的标签, 保留 th:fragment 的标签 --&gt;&lt;div th:insert="/admin/fragments/header::header"&gt;&lt;/div&gt;&lt;!-- @过期, 保留本身的标签, 不保留 th:fragment 的标签 --&gt;&lt;div th:include="/admin/fragments/header::header"&gt;&lt;/div&gt; th:with 定义变量。语法: th:with=”字段1=值, 字段2=值2”1&lt;div th:with="id='UploadImage',var='image',height=1,maxCount=1"&gt;&lt;/div&gt; th:if 就是 if ..1234567&lt;div th:if="$&#123;true&#125;"&gt;&lt;/div&gt;&lt;!-- 布尔值. 0 = false "false"/"off"/"no" = false null = false --&gt; th:switch/th:case1234&lt;ul th:switch="$&#123;val&#125;"&gt; &lt;li th:case="1"&gt;1&lt;/li&gt; &lt;li th:case="2"&gt;2&lt;/li&gt;&lt;/ul&gt; th:selected 可用于 标签1234&lt;select class="form-control" id="type" name="type"&gt; &lt;option value="0" th:selected="$&#123;permission?.type==0&#125;"&gt;菜单&lt;/option&gt; &lt;option value="1" th:selected="$&#123;permission?.type==1&#125;"&gt;数据&lt;/option&gt;&lt;/select&gt; 注释语法123456789&lt;!--/* 这里是 编译器显示为注释, 浏览器不可见 */--&gt;&lt;!--/*--&gt;&lt;div&gt;这里是 编译器显示不注释，浏览器不可见 &lt;/div&gt;&lt;!--*/--&gt;&lt;!--/*/&lt;div th:text="$&#123;'这里是 编辑器显示为注释, 浏览器可见'&#125;"&gt;...&lt;/div&gt;/*/--&gt; 表达式URL 表达式123456&lt;img th:src="@&#123;/img/tup.png&#125;" alt="绝对路径"&gt;&lt;!-- &lt;img alt="绝对路径" src="/img/tup.png"&gt; --&gt;&lt;img th:src="@&#123;../img/tup.png&#125;" alt="相对路径"&gt;&lt;!-- &lt;img alt="相对路径" src="../img/tup.png"&gt; --&gt;&lt;img th:src="@&#123;../img/tup.png(size=$&#123;100&#125;)&#125;" alt="带参数的路径"&gt;&lt;!-- &lt;img alt="带参数的路径" src="../img/tup.png?size=100"&gt; --&gt; 国际化表达式 创建 resources/messages_zh_CN.properties, 其内容: 1message.error=错误 配置 application.yml (使用 xml 的执行转换) 123spring: messages: basename: messages_zh_CN 使用 1&lt;div th:text="#&#123;message.error&#125;"&gt;Error&lt;/div&gt; 变量表达式 最基本的表达式, 类似于 EL 表达式。 合 org.springframework.ui.Model 使用。 可以使用众多内置对象。 @访问 Spring 容器内对象 1&lt;span th:text="$&#123;author.name&#125;"&gt; 变量表达式 - 扩展 11234567891011121314&lt;ul th:object="$&#123;author&#125;"&gt; &lt;li th:text="*&#123;name&#125;"&gt;&lt;/li&gt; &lt;li th:text="*&#123;mail&#125;"&gt;&lt;/li&gt; &lt;li th:text="*&#123;address&#125;"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 等价于 &lt;ul&gt; &lt;li th:text="$&#123;author.name&#125;"&gt;&lt;/li&gt; &lt;li th:text="$&#123;author.mail&#125;"&gt;&lt;/li&gt; &lt;li th:text="$&#123;author.address&#125;"&gt;&lt;/li&gt; &lt;/ul&gt;--&gt; 变量表达式 - 扩展 21&lt;div th:text="$&#123;@demoService.getStr('hocgin')&#125;"&gt;&lt;/div&gt; 预处理表达式 前置设置, Controller 12345678@GetMapping(&#123;"/test.html"&#125;)public String index(Model model, @PathVariable String page) &#123; model.addAttribute("key", "error"); HashMap&lt;String, String&gt; vm = new HashMap&lt;&gt;(); vm.put("error", "来自 $&#123;&#125; 表达式"); model.addAttribute("obj", vm); return String.format("test.html", page);&#125; 前置设置, messages_zh_CN.properties 参考国际化表达式 1message.error=错误 test.html 编写 123456&lt;a th:href="@&#123;/img/__$&#123;1+1&#125;__&#125;"&gt;连接&lt;/a&gt;&lt;!-- &lt;a href="/img/2"&gt;连接&lt;/a&gt; --&gt;&lt;div th:text="#&#123;message.__$&#123;key&#125;__&#125;"&gt;&lt;/div&gt;&lt;!-- &lt;div&gt;错误&lt;/div&gt; --&gt;&lt;div th:text="$&#123;obj.__$&#123;key&#125;__&#125;"&gt;&lt;/div&gt;&lt;!-- &lt;div&gt;来自 $&#123;&#125; 表达式&lt;/div&gt; --&gt; Fragment 表达式 ~{…} 表达式语法字符串拼接使用 + 或者 |..| 1234&lt;span th:text="'1+1=' + $&#123;1+1&#125;"&gt;&lt;/span&gt;&lt;!-- 1+1=2 --&gt;&lt;span th:text="|1+1=$&#123;1+1&#125;|"&gt;&lt;/span&gt;&lt;!-- 1+1=2 --&gt; 运算符号使用 +, -, *, /, %。 12&lt;span th:text="-((1+1-1)*2/2)%9"&gt;&lt;/span&gt;&lt;!-- -1 --&gt; 与 或 非使用 and , or 和 ! , not。 123456789101112&lt;span th:text="1==1 and true"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text="true and false"&gt;&lt;/span&gt;&lt;!-- false --&gt;&lt;span th:text="true or false"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text="not true"&gt;&lt;/span&gt;&lt;!-- false --&gt;&lt;span th:text="! false"&gt;&lt;/span&gt;&lt;!-- true --&gt; 关系表达式使用 &gt;, &lt;, &gt;=, &lt;=, ==, !=。或者 gt, lt, ge, le, eq, ne。 1234&lt;span th:text="((1 &gt; 2 and 2 &lt; 3) or (2 &gt;= 2 and 2 &lt;= 5)) and (1 == 1 and 1 != 2)"&gt;&lt;/span&gt;&lt;!-- true --&gt;&lt;span th:text="((1 gt 2 and 2 lt 3) or (2 ge 2 and 2 le 5)) and (1 eq 1 and 1 ne 2)"&gt;&lt;/span&gt;&lt;!-- true --&gt; 简单条件表达式使用:if-then (if) ? (then)if-then-else (if) ? (then) : (else)default (value) ?: (defaultValue) 123456&lt;span th:text="true ? 'hocgin'"&gt;&lt;/span&gt;&lt;!-- hocgin --&gt;&lt;span th:text="false ? 'hocgin' : 'hocg.in'"&gt;&lt;/span&gt;&lt;!-- hocg.in --&gt;&lt;span th:text="$&#123;iname&#125; ?: 'hocgin'"&gt;&lt;/span&gt;&lt;!-- hocgin --&gt; 解析优先级 级别 描述 th属性 1 (Fragment inclusion)代码片段导入 th:insert,th:replace 2 (Fragment iteration)迭代 th:each 3 (Conditional evaluation)条件 th:if,th:unless,th:switch,th:case 4 (Local variable definition)局部变量 th:object,th:with 5 (General attribute modification)通用属性修改 th:attr,th:attrprepend,th:attrappend 6 (Specific attribute modification)具体属性修改 th:value,th:href,th:src … 7 (Text tag body modification) 文本节点修改 th:text,th:utext 8 (Fragment specification) 代码段定义 th:fragment 9 (Fragment removal) 代码段删除 th:remove 基础对象#ctx (org.thymeleaf.spring4.context.SpringWebContext)123456789101112131415161718192021/** * org.thymeleaf.context.IContext **/// 当前语言环境(eg. en_US)。 等价于 &#123;#locale&#125;$&#123;#ctx.locale&#125;// org.thymeleaf.context.VariablesMap 对象, 内部存储的是可用于当前上下文(Context)的对象。等价于 &#123;#vars&#125;$&#123;#ctx.variables&#125;/** * org.thymeleaf.context.IWebContext **/$&#123;#ctx.applicationAttributes&#125;// 等价于 &#123;#httpServletRequest&#125;$&#123;#ctx.httpServletRequest&#125;$&#123;#ctx.httpServletResponse&#125;// 等价于 &#123;#httpSession&#125;$&#123;#ctx.httpSession&#125;$&#123;#ctx.requestAttributes&#125;$&#123;#ctx.requestParameters&#125;$&#123;#ctx.servletContext&#125;$&#123;#ctx.sessionAttributes&#125; param (org.apache.catalina.util.ParameterMap)包含当前页面的请求的参数(eg. http://localhost:8080/admin/test.html?name=hocgin)。 1234567// 返回对象$&#123;param.name&#125; // 获得值: hocgin$&#123;param.name[0]&#125; $&#123;param.size()&#125;$&#123;param.isEmpty()&#125;$&#123;param.containsKey('name')&#125; session (org.thymeleaf.context.WebSessionVariablesMap)从 Session 获取内容。 12345// 获得值: hocgin$&#123;session.name&#125;$&#123;session.size()&#125;$&#123;session.isEmpty()&#125;$&#123;session.containsKey('name')&#125; #httpServletRequest (org.apache.catalina.connector.RequestFacade)#themes (org.thymeleaf.spring4.expression.Themes)application#dates (org.thymeleaf.expression.Dates)#calendars (org.thymeleaf.expression.Calendars)#numbers (org.thymeleaf.expression.Numbers)#strings (org.thymeleaf.expression.Strings)#objects (org.thymeleaf.expression.Objects)#bools (org.thymeleaf.expression.Bools)#arrays (org.thymeleaf.expression.Arrays)#lists (org.thymeleaf.expression.Lists)#sets (org.thymeleaf.expression.Sets)#maps (org.thymeleaf.expression.Maps)#aggregates (org.thymeleaf.expression.Aggregates)#messages (org.thymeleaf.expression.Messages)#ids (org.thymeleaf.expression.Ids)代码示例 123456789101112131415161718192021222324### `#locale` (&lt;span th:text="$&#123;#locale&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#ctx` (&lt;span th:text="$&#123;#ctx&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#vars` (&lt;span th:text="$&#123;#vars&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `param` (&lt;span th:text="$&#123;param&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `application` (&lt;span th:text="$&#123;application&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `session` (&lt;span th:text="$&#123;session&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#httpSession` (&lt;span th:text="$&#123;#httpSession&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#httpServletRequest` (&lt;span th:text="$&#123;#httpServletRequest&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#themes` (&lt;span th:text="$&#123;#themes&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#dates` (&lt;span th:text="$&#123;#dates&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#calendars` (&lt;span th:text="$&#123;#calendars&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#numbers` (&lt;span th:text="$&#123;#numbers&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#strings` (&lt;span th:text="$&#123;#strings&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#objects` (&lt;span th:text="$&#123;#objects&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#bools` (&lt;span th:text="$&#123;#bools&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#arrays` (&lt;span th:text="$&#123;#arrays&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#lists` (&lt;span th:text="$&#123;#lists&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#sets` (&lt;span th:text="$&#123;#sets&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#maps` (&lt;span th:text="$&#123;#maps&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#aggregates` (&lt;span th:text="$&#123;#aggregates&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#messages` (&lt;span th:text="$&#123;#messages&#125;"&gt;&lt;/span&gt;)&lt;br&gt;### `#ids` (&lt;span th:text="$&#123;#ids&#125;"&gt;&lt;/span&gt;)&lt;br&gt; 重点 在 thymeleaf 中使用 Spring 容器内的单例. 1&lt;div th:text="$&#123;@demoService.getStr('hocgin')&#125;"&gt;&lt;/div&gt; 引入模版片段 XPath 表达式 1&lt;div th:include="mytemplate :: [//div[@class='content']]"&gt;&lt;/div&gt; CSS 表达式 1&lt;div th:include="mytemplate :: [div.content]"&gt;&lt;/div&gt; 引入公有片段(JS 或 CSS) 123&lt;css th:replace="mytemplate :: common-css"&gt;&lt;/css&gt;&lt;js th:replace="@&#123;mytemplate&#125; :: common-css"&gt;&lt;/js&gt;&lt;!-- 可结合 路径表达式 --&gt; 扩展thymeleaf-layout-dialect 一般情况网站都有一个外部框架, 如 header 或者 footer, 这个扩展便是用于抽离那些重复的部分的。 layout:decorator指定需使用的父级模版123456&lt;html lang="en" xmlns:th="http://www.thymeleaf.org" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorator="/admin/_layouts/default"&gt; ...&lt;/html&gt; layout:fragment 在父模版中使用定义一个标记，在子模版中使用覆盖到父模版位置。123456789101112&lt;!-- 父 --&gt;&lt;div layout:fragment="content"&gt; &lt;p&gt;父模版内容&lt;/p&gt;&lt;/div&gt;&lt;!-- 子 --&gt;&lt;div layout:fragment="content"&gt; &lt;p&gt;子模版内容&lt;/p&gt;&lt;/div&gt;&lt;!-- 生成 --&gt;&lt;div&gt; &lt;p&gt;子模版内容&lt;/p&gt;&lt;/div&gt; layout:title-pattern 用与 标签, 指定 title 的值。12&lt;!-- 后台 - 子标题 --&gt;&lt;title layout:title-pattern="$DECORATOR_TITLE - $CONTENT_TITLE"&gt;后台&lt;/title&gt; 黑科技 当我们想取一个对象里面的一个属性, 但这个对象可能为空时(😋)。1&lt;td th:text="$&#123;user?.address?.city&#125;"&gt;&lt;/td&gt;]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK8 新特性的使用]]></title>
    <url>%2F2017%2F10%2F10%2FJDK8%20%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JDK8 新特性的使用 JDK8 新特性Lambda 表达式 &amp;&amp; @FunctionalInterfaceJava8 支持了 Lambda 表达式，语法如下:12345678910// 标准式(形参) -&gt; &#123; ..代码&#125;// 简化式() -&gt; System.out.print("简化式")// 案例：new Thread(() -&gt; System.out.print("run")).run(); 由于 Lambda 表达式是对单个函数的接口(interface)进行简化处理，即要保证接口不能存在后续新增函数声明，这时就需要引入 @FunctionalInterface 进行注解。以下是 Java8 下 Runable 接口的声明：123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 注: @FunctionalInterface 接口内允许有静态函数实现和默认函数实现。 即如下123456789101112interface R2 extends Runnable &#123; // 默认函数实现 default String to() &#123; return getClass().toString(); &#125; // 静态函数实现 static String in() &#123; return "in()"; &#125;&#125; 这也是 Java8 interface 中的新特性。关于 :: 函数的引用 (静态函数引用、构造函数引用、特定对象函数引用) 12345678910111213141516171819202122232425262728293031public class Main &#123; public static void main(String[] args) &#123; // 对构造函数进行引用，简单工厂实现 Supplier&lt;Car&gt; aNew = Car::new; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(aNew.get()); &#125; // 静态函数引用 Function&lt;Supplier&lt;Car&gt;, Car&gt; create = Car::create; Car car = create.apply(Car::new); // 特定对象的函数引用 // 补充:在 Car 函数中使用 this::to 也是一种 Function&lt;String, String&gt; to = car::to; System.out.println(to.apply("Shanghai")); &#125; &#125;class Car &#123; public static Car create(Supplier&lt;Car&gt; carSupplier) &#123; return carSupplier.get(); &#125; public String to(String address) &#123; return String.format("to %s ", address); &#125;&#125; 注: Function&lt;参数, 返回值&gt; create = Car::create;测试后发现只支持最多2个参数的函数对应 Function, BiFunction。 即, :: 是对函数进行引用。使用 @Repeatable 支持重复注解在 Java8 中, 不再限制相同的注解在同一位置只能声明一次。简单示例:123456789101112131415161718192021222324public class RepeatableMain &#123; @Filter("filter-1") @Filter("filter-2") public static void main(String[] args) &#123; for (Method method : RepeatableMain.class.getDeclaredMethods()) &#123; System.out.println(Arrays.asList(method.getAnnotations()).toString()); &#125; &#125; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @interface Filters &#123; Filter[] value(); &#125; @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Repeatable(Filters.class) // 指定多注解的注解类 @interface Filter &#123; String value(); &#125;&#125; 新增注解支持类型 ElementType.TYPE_PARAMETERElementType.TYPE_USE12345678910111213141516171819202122232425262728public class Annotations &#123; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE_USE, ElementType.TYPE_PARAMETER&#125;) public @interface Both &#123; &#125; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE_PARAMETER&#125;) public @interface Parameter &#123; &#125; @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE_USE&#125;) public @interface Use &#123; &#125; public static class Holder&lt;@Both @Use @Parameter T&gt; extends @Both @Use Object &#123; public void method() throws @Both @Use Exception &#123; &#125; &#125; @SuppressWarnings("unused") public static void main(String[] args) &#123; final Holder&lt;String&gt; holder = new @Both @Use Holder&lt;&gt;(); @Both @Use Collection&lt;@Both @Use String&gt; strings = new ArrayList&lt;&gt;(); &#125;&#125; ElementType.TYPE_PARAMETER 表示注解可以在泛型声明前使用。 ElementType.TYPE_USE 表示注解可以在全部类型位置使用。 Java 编译器新特性在 java8 中, 可以在编译时使用–parameters参数保存函数形参的原变量命名，然后在代码中可通过反射获得函数的变量命名。示例如下:123456789public class JVMs &#123; public static void main(String[] args) throws NoSuchMethodException &#123; Method method = JVMs.class.getMethod("main", String[].class); for (final Parameter parameter : method.getParameters()) &#123; System.out.println(String.format("%s 检测到原变量名", parameter.isNamePresent() ? "可以": "不可以")); System.out.println(String.format("参数: %s", parameter.getName())); &#125; &#125;&#125; Java 新增类库Optional 用于解决 NullPointerException123456789101112public class OptionalMain &#123; public static void main(String[] args) &#123; // Null 值 Optional&lt;String&gt; optional = Optional.empty(); System.out.println(String.format("是否为null: %s", !optional.isPresent() ? "是" : "否")); System.out.println(optional.orElseGet(() -&gt; "无值回调该函数()")); // 非 Null 值 optional = Optional.of("hocgin"); System.out.println(optional.map(s -&gt; String.format("值: %s", s)).orElse("默认值: 10086")); &#125;&#125; Stream API 函数式编程，简化了之前繁琐的代码编写方式。12345678910111213141516171819202122232425262728public class SteamMain &#123; public static void main(String[] args) &#123; // 集合中使用 Stream API Collection&lt;String&gt; collections = Arrays.asList( "1", "2", "3", "4", "5", "6", "7" ); collections.stream() .filter(i -&gt; Integer.valueOf(i) &gt; 3) .limit(3) .forEach(System.out::println); // 文件流中使用 Stream API final Path path = new File("filePath").toPath(); try (Stream&lt;String&gt; lines = Files.lines(path, StandardCharsets.UTF_8)) &#123; lines.onClose(() -&gt; System.out.println("读取完成")).forEach(System.out::println); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注: 此处 try 中可在文件流读取完进行自动关闭流的处理。 Date/Time API 加强了对时间与日期的处理。12345678910111213141516171819202122232425public class DateAndTimeMain &#123; public static void main(String[] args) &#123; // 日期相关 LocalDate nowDate = LocalDate.now(); // 时间相关 LocalTime nowTime = LocalTime.now(); // 日期&amp;时间相关 LocalDateTime now = LocalDateTime.now(); // 获取指定时区的当前时刻 Clock clock = Clock.systemUTC(); // 获取某时区的当前时间 ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("Asia/Shanghai")); System.out.println(String.format("当前日期: %s", nowDate)); System.out.println(String.format("当前时间: %s", nowTime)); System.out.println(String.format("当前日期&amp;时间: %s", now)); System.out.println(String.format("当前时间戳: %s", clock.millis())); // === System.currentTimeMillis() System.out.println(String.format("上海时间: %s", zonedDateTime)); // 用于计算两个日期间的间隔 ZonedDateTime zonedDateTime2 = ZonedDateTime.now(ZoneId.of("Asia/Shanghai")); Duration duration = Duration.between(zonedDateTime, zonedDateTime2); System.out.println(duration.abs().getNano()); &#125;&#125; JavaScript引擎(Nashorn) 允许 Java 与 JavaScript 相互调用。 12345678public class NashornMain &#123; public static void main(String[] args) throws ScriptException &#123; ScriptEngineManager manager = new ScriptEngineManager(); ScriptEngine engine = manager.getEngineByName("JavaScript"); System.out.println(engine.getClass().getName()); System.out.println("Result:" + engine.eval("function f() &#123; return 1; &#125;; f() + 1;")); &#125;&#125; Base64在 java8 中, 加入了，Base64编码。1234567891011121314public class Base64Main &#123; public static void main(String[] args) &#123; final String text = "Base64 finally in Java 8!"; final String encoded = Base64 .getEncoder() .encodeToString(text.getBytes(StandardCharsets.UTF_8)); System.out.println(encoded); final String decoded = new String( Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8); System.out.println(decoded); &#125;&#125; 并行数组在 java8 中, 对数组进行并行处理, 极大提高在多核机子上的处理速度。123456789101112131415161718192021222324public class ParallelMain &#123; public static void main(String[] args) &#123; long[] arrayOfLong = new long[20000]; // 进行赋值操作 Arrays.parallelSetAll(arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt(1000000)); Arrays.stream(arrayOfLong).limit(10).forEach( i -&gt; System.out.print(i + " ")); System.out.println(); // 进行数组排序 Arrays.parallelSort(arrayOfLong); Arrays.stream(arrayOfLong).limit(10).forEach( i -&gt; System.out.print(i + " ")); System.out.println(); // 进行数组操作, 结果: [a1, a1+a2, a1+a2+a3,..] Arrays.parallelPrefix(arrayOfLong, (x, y) -&gt; x + y); Arrays.stream(arrayOfLong).limit(10).forEach( i -&gt; System.out.print(i + " ")); System.out.println(); &#125;&#125; 并发 线程池ExecutorService/ScheduledExecutorService支持使用Stream API. 新增 StampedLock 用于替代 ReadWriteLock 1234567StampedLock lock = new StampedLock();lock.writeLock();try &#123; // 代码..&#125; finally &#123; lock.unlockWrite(stamp);&#125; 原子操作(java.concurrent.atomic) ConcurrentMap 继承自Map接口 ForkJoinPool 预置并行机制 新增的 Java 工具 Nashorn引擎命令行工具 jjs 12jjs # 回车(function()&#123;return 1+1&#125;)() 类依赖分析器命令行工具 jdeps 123456# .class 文件jdeps Base64Main.class# .jar 文件jdeps demo.jar# 文件夹jdeps jdk8 JVM 新特性 PermGen 被移除 JVM选项-XX:PermSize与-XX:MaxPermSize分别被-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替 相关Java 8]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池和锁-小记]]></title>
    <url>%2F2017%2F10%2F07%2FJava%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%20%E5%92%8C%20%E9%94%81%20%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[提取想要的apk， 例如CM ROM包中的含天气的时钟不错！ 并发线程池 ExecutorService 123456789101112131415161718192021public class ConcurrencyMain &#123; public static void main(String[] args) throws InterruptedException &#123;ExecutorService executor = Executors.newWorkStealingPool(); List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList( () -&gt; "task1", () -&gt; "task2", () -&gt; "task3"); executor.invokeAll(callables) .stream() .map(future -&gt; &#123; try &#123; return future.get(); &#125; catch (Exception e) &#123; throw new IllegalStateException(e); &#125; &#125;) .forEach(System.out::println); &#125;&#125; ScheduledExecutorService 12345678910111213public class ConcurrencyMain &#123; public static void main(String[] args) throws InterruptedException &#123; ScheduledExecutorService executor = Executors.newScheduledThreadPool(3); ScheduledFuture&lt;?&gt; future = executor.schedule(() -&gt; System.out.println("执行延迟任务"), 2, TimeUnit.SECONDS); TimeUnit.MILLISECONDS.sleep(1000); long remainingDelay = future.getDelay(TimeUnit.MILLISECONDS); System.out.println(String.format("剩余延迟时间: %sms", remainingDelay)); &#125;&#125; 区别 两者的区别是ScheduledExecutorService是可延迟执行。 同步(Synchronized) 对象锁语法: 1234567891011121314151617181920212223242526272829303132333435363738public class SynchronizedMain &#123; public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec()); Thread runnable2 = new Thread(() -&gt; t1.exec()); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 0 1 2 3 4 5 6 7 1 2 3 4 5 6 7 8 9 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec()); Thread runnable4 = new Thread(() -&gt; t2.exec()); runnable3.start(); runnable4.start(); &#125;&#125;// 以下两种方式等价，仅作用范围不一样。class Test &#123; public synchronized void exec() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + " "); &#125; &#125; public void exec() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + " "); &#125; &#125; &#125;&#125; 结论: 同一对象调用该方法是锁定的，不同对象不会进行锁定。 类锁12345678910111213141516171819202122232425262728293031323334353637383940public class SynchronizedMain &#123; public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec()); Thread runnable2 = new Thread(() -&gt; t1.exec()); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec()); Thread runnable4 = new Thread(() -&gt; t2.exec()); runnable3.start(); runnable4.start(); &#125;&#125;// 以下两种方式等价class Test &#123; private static Object lock = new Object(); public void exec() &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + " "); &#125; &#125; &#125; public void exec() &#123; synchronized (Test.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + " "); &#125; &#125; &#125;&#125; 结论: 该方式锁的作用范围是整个类。 指定锁语法: 1234567891011121314151617181920212223242526272829303132public class SynchronizedMain &#123; private static Object lock = new Object(); public static void main(String[] args) &#123; // ==[测试一:同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t1 = new Test(); Thread runnable1 = new Thread(() -&gt; t1.exec(lock)); Thread runnable2 = new Thread(() -&gt; t1.exec(lock)); runnable1.start(); runnable2.start(); // ==[测试二:不同一对象]== // 结果: 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 Test t2 = new Test(); Thread runnable3 = new Thread(() -&gt; t1.exec(lock)); Thread runnable4 = new Thread(() -&gt; t2.exec(lock)); runnable3.start(); runnable4.start(); &#125;&#125;class Test &#123; public void exec(Object lock) &#123; synchronized (lock) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf(i + " "); &#125; &#125; &#125;&#125; 结论: 该方式取决于传入的锁。当对象属性发生改变时，锁就失去了作用。 对于 Java8 中，ReentrantLock 可实现锁的作用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 WebView 点击时网页不断闪耀]]></title>
    <url>%2F2017%2F09%2F28%2F%E8%A7%A3%E5%86%B3WebView%E7%82%B9%E5%87%BB%E6%97%B6%E7%BD%91%E9%A1%B5%E4%B8%8D%E6%96%AD%E9%97%AA%E8%80%80%2F</url>
    <content type="text"><![CDATA[解决高版本 WebView 点击时网页不断闪耀的问题 🤗 原因网页渲染开启了硬件加速，如果你也出现了该问题，可以尝试关闭硬件加速。 方案方案一: 在xml中使用android:layerType=&quot;software&quot;进行关闭。推荐方案二: 通过 java 代码webView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);进行关闭。 参考BroswerKit进行标记的这段代码解决了我的闪耀问题]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 WebView 点击时网页不断闪耀]]></title>
    <url>%2F2017%2F09%2F28%2FTextView%20%E6%BB%9A%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决高版本 WebView 点击时网页不断闪耀的问题 🤗 设置 TextView 自动水平滚动1234567891011121314&lt;TextView android:id="@+id/tx" android:layout_width="40dp" android:layout_height="wrap_content" android:background="#fdf" android:text="1234567890123456789012345678901234567890" android:focusable="true" android:focusableInTouchMode="true" android:singleLine="true" android:scrollHorizontally="true" android:ellipsize="marquee" android:marqueeRepeatLimit ="marquee_forever" /&gt; 高版本测试中android:singleLine=&quot;true&quot;虽然过期了，但仍不能使用android:maxLines=&quot;1&quot;进行替换，如果实在强迫症患者可以使用tx.setSingleLine(true);替换。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 ProgressBar 上下出现空白现象]]></title>
    <url>%2F2017%2F09%2F27%2F%E8%A7%A3%E5%86%B3ProgressBar%E9%A1%B6%E9%83%A8%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E7%8E%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[解决 ProgressBar 上下出现空白现象 🤠 出现问题一般情况我们使用如下代码来创建ProgressBar12345678&lt;ProgressBar android:id="@+id/progressBar" style="?android:attr/progressBarStyleHorizontal" android:background="#fff" android:max="100" android:indeterminate="true" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 那么将会出现如下情况: 解决方案通过变更android:layout_marginBottom和android:layout_marginTop在结合android:background设置为透明来处理这个问题:12345678910&lt;ProgressBar android:id="@+id/progressBar" style="?android:attr/progressBarStyleHorizontal" android:layout_marginBottom="-7dp" android:layout_marginTop="-7dp" android:background="#00ffffff" android:max="100" android:indeterminate="true" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt; 以下是处理后的结果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 OpenWrt 部署 Shadowsocks]]></title>
    <url>%2F2017%2F09%2F18%2FOpenWrt-Shadowsocks%2F</url>
    <content type="text"><![CDATA[前言关于 OpenWrt 请看 OpenWrt 入门篇关于 Shadowsocks 请看 什么是 Shadowsocks已有 Shadowsocks 账号, 后续可能会记录。重要: 本文前提为读者已观看过以上2篇文章，如阅读引起任何不适请立即停止。 关于 Shadowsocks-libev 模块 Shadowsocks-libev 官网Shadowsocks-libev 下载地址 (推荐下载非spec版本) ss-server：服务器端，部署于服务器，提供 shadowsocks 服务。ss-local：客户端，提供 SOCKS 代理ss-redir：客户端，提供透明代理, 从 v2.2.0 开始支持 UDPss-tunnel: 客户端，提供端口转发, 可用于 DNS 查询 Note: 下载的时候请根据 CPU 类型, 查看方式请参照 安装 Shadowsocks-libev 将下载的Shadowsocks-libev移至路由器/tmp目录 1scp shadowsocks-libev-polarssl_2.4.8-2_ar71xx.ipk root@192.168.1.1:/tmp 安装依赖 12opkg updateopkg install iptables-mod-nat-extra ipset libopenssl 安装Shadowsocks-libev 1opkg install /tmp/shadowsocks-libev-polarssl_2.4.8-2_ar71xx.ipk 配置 shadowsocks 修改/etc/shadowsocks.json为实际参数。格式如下 12345678&#123; "server": "127.0.0.1", "server_port": 443, "local_port": 7654, "password": "password", "timeout": 60, "method": "rc4-md5"&#125; 此处, “local_port”: 7654 为重点。不理解的, 请不要进行修改此项，后续会解释。 注: /etc/shadowsocks.json 为配置文件, 存储 shadowsocks 的账号、 密码及设置。 查看/etc/init.d/shadowsocks。内容如下 123456789101112131415161718192021#!/bin/sh /etc/rc.commonSTART=95SERVICE_USE_PID=1SERVICE_WRITE_PID=1SERVICE_DAEMONIZE=1CONFIG=/etc/shadowsocks.jsonstart() &#123; service_start /usr/bin/ss-local -c $CONFIG -b 0.0.0.0 #service_start /usr/bin/ss-redir -c $CONFIG -b 0.0.0.0 #service_start /usr/bin/ss-tunnel -c $CONFIG -b 0.0.0.0 -l 5353 -L 8.8.8.8:53 -u&#125;stop() &#123; service_stop /usr/bin/ss-local #service_stop /usr/bin/ss-redir #service_stop /usr/bin/ss-tunnel&#125; 注: /etc/init.d/shadowsocks 为运行文件, shadowsocks 的启动、停止、重启。 运行检查配置是否正确 1/etc/init.d/shadowsocks restart 使用代理进行检查, Chrome 浏览器下载 ExtensionProxy SwitchyOmega，墙内地址后续补上..。对插件进行如下配置: 在 Chrome 浏览器使用 ExtensionProxy SwitchyOmega 切换到该协议并访问 YouTuBe，验证其配置的正确性。 关闭 shadowsocks 1/etc/init.d/shadowsocks stop 自动化安装 dnsmasq &amp; ipset 查看是否支持 ipset 123456789opkg updateopkg list-installed dnsmasq -v# 如果不支持，卸载掉安装full版opkg remove dnsmasqopkg install dnsmasq-fullopkg install ipset iptables-mod-nat-extraopkg install /tmp/pdnsd_1.2.9a-par-a8e46ccba7b0fa2230d6c42ab6dcd92926f6c21d_ar71xx.ipk 附件: pdnsd_1.2.9a-par-a8e46ccba7b0fa2230d6c42ab6dcd92926f6c21d_ar71xx.ipk 下载 配置 dnsmasq 和 ipset 12vim /etc/dnsmasq.confmkdir /etc/dnsmasq.d 在末尾加入 123conf-dir=/etc/dnsmasq.dcache-size=1500 #修改dnsmasq缓存大小，默认为150。min-cache-ttl=720 #修改DNS缓存最小有效期（秒）。仅适用于aa65535的dnsmasq-full版本。 下载国内重要网站名单，用国内域名服务器查询iP地址 12345cd /etc/dnsmasq.dopkg install wgetwget -4 --no-check-certificate -O /etc/dnsmasq.d/accelerated-domains.china.conf https://github.com/felixonmars/dnsmasq-china-list/raw/master/accelerated-domains.china.confwget -4 --no-check-certificate -O /etc/dnsmasq.d/bogus-nxdomain.china.conf https://github.com/felixonmars/dnsmasq-china-list/raw/master/bogus-nxdomain.china.confecho "server=/#/127.0.0.1#3210" &gt; gfwlist.conf 修改/etc/init.d/shadowsocks启动文件, 内容如下 1234567891011121314151617181920212223242526272829#!/bin/sh /etc/rc.commonSTART=95SERVICE_USE_PID=1SERVICE_WRITE_PID=1SERVICE_DAEMONIZE=1CONFIG=/etc/shadowsocks.jsonstart() &#123; sed -i 's/114.114.114.114/127.0.0.1#3210/' /etc/dnsmasq.d/gfwlist.conf /etc/init.d/dnsmasq restart service_start /usr/bin/ss-redir -b 0.0.0.0 -c $CONFIG -f /var/run/shadowsocks.pid -u service_start /usr/bin/ss-tunnel -b 0.0.0.0 -c $CONFIG -l 3210 -L 8.8.8.8:53 -u /usr/bin/shadowsocks-firewall&#125;stop() &#123; sed -i 's/127.0.0.1#3210/114.114.114.114/' /etc/dnsmasq.d/gfwlist.conf /etc/init.d/dnsmasq restart service_stop /usr/bin/ss-redir service_stop /usr/bin/ss-tunnel killall ss-redir killall ss-tunnel /etc/init.d/firewall restart&#125; 配置 iptables 防火墙转发IP和端口创建执行文件 /usr/bin/shadowsocks-firewall 12touch /usr/bin/shadowsocks-firewallchmod +x /usr/bin/shadowsocks-firewall /usr/bin/shadowsocks-firewall 其内容如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#!/bin/sh#create a new chain named SHADOWSOCKSiptables -t nat -N SHADOWSOCKSiptables -t nat -N SHADOWSOCKS_WHITELIST# Ignore your shadowsocks server's addresses# It's very IMPORTANT, just be careful.iptables -t nat -A SHADOWSOCKS -d 此处为服务器IP -j RETURN# Ignore LANs IP addressiptables -t nat -A SHADOWSOCKS -d 0.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 10.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 127.0.0.0/8 -j RETURNiptables -t nat -A SHADOWSOCKS -d 169.254.0.0/16 -j RETURNiptables -t nat -A SHADOWSOCKS -d 172.16.0.0/12 -j RETURNiptables -t nat -A SHADOWSOCKS -d 192.168.0.0/16 -j RETURNiptables -t nat -A SHADOWSOCKS -d 224.0.0.0/4 -j RETURNiptables -t nat -A SHADOWSOCKS -d 240.0.0.0/4 -j RETURN# Check whitelistiptables -t nat -A SHADOWSOCKS -j SHADOWSOCKS_WHITELISTiptables -t nat -A SHADOWSOCKS -m mark --mark 1 -j RETURN#for hulu.comiptables -t nat -A SHADOWSOCKS -p tcp --dport 1935 -j REDIRECT --to-ports 7654iptables -t nat -A SHADOWSOCKS -p udp --dport 1935 -j REDIRECT --to-ports 7654# for Chrome browser and youtube.comiptables -t nat -A SHADOWSOCKS -p udp --dport 443 -j REDIRECT --to-ports 7654# Anything else should be redirected to shadowsocks's local portiptables -t nat -A SHADOWSOCKS -p tcp -j REDIRECT --to-ports 7654# Apply the rulesiptables -t nat -A PREROUTING -p tcp -j SHADOWSOCKS# Ignore China IP address# for white_ip in `cat /etc/chinadns_chnroute.txt`;# do# iptables -t nat -A SHADOWSOCKS_WHITELIST -d "$&#123;white_ip&#125;" -j MARK --set-mark 1# done# Ignore Asia IP addressiptables -t nat -A SHADOWSOCKS_WHITELIST -d 1.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 14.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 27.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 36.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 39.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 42.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 49.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 58.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 59.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 60.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 61.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 101.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 103.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 106.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 110.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 111.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 112.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 113.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 114.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 115.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 116.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 117.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 118.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 119.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 120.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 121.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 122.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 123.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 124.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 125.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 126.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 169.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 175.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 180.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 182.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 183.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 202.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 203.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 210.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 211.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 218.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 219.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 220.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 221.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 222.0.0.0/8 -j MARK --set-mark 1iptables -t nat -A SHADOWSOCKS_WHITELIST -d 223.0.0.0/8 -j MARK --set-mark 1 重要: 此处为服务器IP更换为实际IP。 Ignore Asia IP address为亚洲IP地址段。如果路由器内存够大的话，可开启Ignore China IP address。chinadns_chnroute.txt 文件下载 --to-ports 7654即/etc/shadowsocks.json中的 “local_port”: 7654shadowsocks 控制1234/etc/init.d/shadowsocks stop/etc/init.d/shadowsocks start/etc/init.d/shadowsocks enable/etc/init.d/shadowsocks disable]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt 入门篇]]></title>
    <url>%2F2017%2F09%2F18%2FOpenWrt-%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[今天刚好重刷 OpenWrt 固件，整理整理 介绍什么是 OpenWrt? 关于支持 OpenWrt 的路由器可以去 支持 OpenWrt 的路由器列表 查看支持的路由器, 了解其 CPU型号(既芯片型号) RAM容量 Flash容量 关于 OpenWrt 固件的下载OpenWrt 官方下载固件地址关于下载地址格式: 关于固件类型 后缀为factory是用于从原厂固件刷为 OpenWrt。 后缀为sysupgrade是用于从 OpenWrt 更新 OpenWrt。 原厂刷 OpenWrt 固件 待补充 网页界面 OpenWrt 备份 &amp; 升级固件 OpenWrt 安全模式 当我们无法进入网页界面，可以使用安全模式管理恢复固件必须使用有线电缆进行连接。环境: Linux or macOS 进入OpenWrt安全模式的方法： 使用网线连接电脑和路由器 设置电脑网卡IP 地址:192.168.1.x(x为2至255)子网掩码:255.255.255.0 打开终端运行命令 12# 注, 此处 eth0 为网卡. 可使用 ifconfig 进行查看sudo tcpdump -Ani eth0 port 4919 and udp 断电重启 打开终端运行命令 1telnet 192.168.1.1 执行指令, 例如 1234# 重置系统firstboot# 重置密码passwd 重启路由器 不死 U-Boot 待补充 网页界面 OpenWrt 宽带拨号设置 进入接口设置界面 进行 WAN 口编辑 填写宽带账号 &amp; 密码 此时电脑连接 LAN 口的话，即可进行上网。 WiFi 设置 进入 WiFi 设置界面，此处为双网卡 开启WiFi 设置WiFi 基础知识什么是WAN口？什么是LAN口？ 路由器通常有多个LAN口，一个WAN口 WAN 广域网（WAN、公网、外网） 设置拨号上网连接互联网 LAN 局域网（LAN、私网、内网) 连接本地计算机 PPPoE 以太网上的点对点协议中的一种, 宽带接入方式ADSL 就使用了PPPoE协议 关于 WiFi 2.4G 和 5G802.11n/b/g 主要工作频段为2.4GHz802.11a/ac 主要工作频段为5GHz]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Android Studio 启动 Android 模拟器失败问题]]></title>
    <url>%2F2017%2F07%2F02%2F%E5%85%B3%E4%BA%8EAndroid%20Studio%20%E5%90%AF%E5%8A%A8Android%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[起因Android Studio 启动虚拟机一直闪退，不显示任何报错信息 排查问题 尝试用命令启动模拟器, 方便查看其错误日志1234567891011121314# 查看你创建的设备emulator -list-avds# 启动命令emulator -netdelay none -netspeed full -avd New_Device_API_2# 以下为报错日志Hax is enabledHax ram_size 0x60000000HAX is working and emulator runs in fast virt mode.Failed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync vcpu regFailed to sync HAX vcpu contextInternal error: Initial hax sync failed vcpu无法进行同步?? What??尝试进行了 Google，How do I fix “Failed to sync vcpu reg” error? 好吧, docker 之类的虚拟机引起了冲突 解决办法关掉用不着的虚拟机如 docker ..]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google 使用技巧]]></title>
    <url>%2F2017%2F06%2F18%2FGoogle-%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[摩擦 Google 利器。 前提使用 https://www.google.com/ncr 模式并且是英文版。 技巧双引号 完全匹配搜索 减号 使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除特定的词。 星号 号代表任何文字，即*模糊搜索 ～ 匹配 该关键词 或 该关键词的同义词 OR 匹配关键词hocgin或者hocg.in + 匹配关键词hocgin与hocg.in同时存在 inurl 匹配url连接中包含该词汇，例如上方匹配 https://hocg.in/hocgin allinurl 等价于: inurl: hocgin inurl: hocg.in匹配url连接中既包含hocgin也包含hocg.in, 例如: https://hocg.in/hocgin inanchor 匹配a标签中的文字, 例如上方匹配 \hocgin\ intitle 匹配title标签中的文字, \hocgin\ allintitle 等价于: intitle: hocgin intitle: hocg.in匹配标题中既包含hocgin也包含hocg.in,例如: \hocgin 的博客地址 hocg.in\ filetype 匹配包含关键词hocgin的所有pdf文件 site 某个域名的搜索 ralated 返回 Google 人为相关的页面 混合使用示例图片来源 工具查询字词的释义 数学运算 天气查询 当前时间 日出 日落 音乐人搜索 省会 汇率 200美元换多少人民币，可以进行数学运算 设置计时器 Set timer XX seconds/minutes/hours，XX表示具体的数字。 两地点距离计算 当前位置 显示当前电脑IP 显示国家 GDP 绘制多元方程以及复杂的方程式 graph + 方程式 搜索某个单词的由来]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt 入门篇]]></title>
    <url>%2F2017%2F05%2F31%2FOpenWrt-%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Tips查看路由器支持架构1opkg print-architecture | awk '&#123;print $2&#125;' 如何更改时区?12345678910111213141516171819# 查看当前的时区date -R# Wed, 31 May 2017 07:07:28 +0000# 修改时区vi /etc/config/system# 进行修改# config system# option hostname 'Openwrt'# option timezone 'CST-8'# option zonename 'Asia/Shanghai'# 重启reboot# 查看是否成功date -R# Wed, 31 May 2017 15:08:01 +0800# 同步系统时间ntpd -n -q -p 0.asia.pool.ntp.org 如何在 OpenWrt 上搭建 PHP 环境?12345678# 更新索引opkg update# 安装必须的环境opkg install php5 php5-mod-gd php5-mod-curl php5-mod-session php5-mod-pdo php5-mod-mcrypt php5-mod-mbstring php5-fastcgi php5-cgi php5-mod-ctype php5-mod-exif php5-mod-iconv php5-mod-json php5-mod-sockets php5-mod-sqlite3 php5-mod-tokenizer php5-mod-zip# 配置文件目录# /etc/httpd.conf# 重启http服务/etc/init.d/uhttpd restart]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串编码篇]]></title>
    <url>%2F2017%2F05%2F12%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[字符编码的来历.. ASCII 最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号 占位: 1个字节 GB2312 中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突 Unicode \u[16进制] Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 占位: 通常是2个字节 UTF-8 本着节约的精神，又出现了把Unicode编码转化为“可变长编码”Note: UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark 的使用]]></title>
    <url>%2F2017%2F04%2F20%2FWireshark%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[抽空整理一下, 虽然Charles很好用, 但是某些情况下该软件也是不可替代的. 关于Wireshark适合研究 TCP,UDP 等协议. 因为限制并不能改包或模拟发包，只能分析协议若, 研究HTTP,HTTPS推荐使用Charles or Fiddler 关于抓包五颜六色的意义 更多详情查看 View - Coloring Rules 绿色背景（黑字）HTTP包 灰色背景（黑字）TCP包 蓝色背景 (黑字) DNS包 黑色背景 (红字) TCP错误包或者校验错误包 Wireshark主窗口 从上至下 菜单栏: 用于开始操作。 主工具栏: 提供快速访问菜单中经常用到的项目的功能。 过滤工具栏: 提供处理当前显示过滤得方法。 拦截的数据包列表(Packet list): 显示打开文件的每个包的摘要。点击面板中的单独条目，包的其他情况将会显示在另外两个面板中。 选中的数据包信息(Packet details): 显示您在Packet list面板中选择的包的更多详情。 选中的数据包字节码: 显示您在Packet list面板选择的包的数据，以及在Packet details面板高亮显示的字段。 状态栏: 显示当前程序状态以及捕捉数据的更多详情。 选中的数据包信息 Frame: 物理层的数据帧概况 Ethernet II: 数据链路层以太网帧头部信息 Internet Protocol Version 4: 互联网层IP包头部信息 Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议 过滤表达式 协议过滤 tcp upd .. ip 过滤 来源 ip.src == 192.168.1.1目的地 ip.dst == 192.168.1.1 端口 tcp.port == 8080仅显示来源为8080的 tcp.srcport == 8080 Http模式 http.request.method==”GET” 逻辑运算符为 and or]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL的重新梳理]]></title>
    <url>%2F2017%2F04%2F07%2FSQL%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[持续积累.. 关于 SQL 执行顺序资料参考 例句123456select * from t_1 join t_2on t_1.id = t_2.fidwhere 1=1group by t_1.classNamehaving t_1.className = '1班'order by id desc; 这是一条简单/规范的基本SQL。 注意 SQL三个很重要的位置on/where/having它们分别对应着 join/from/group 形成后的虚表进行筛选。 select部分并不是一开始就执行的，而是表数据确认完毕，只差排序的时候执行的。并且select中的函数/DISTINCT/TOP也是在select执行阶段执行的 聚合函数需Group后才可执行, 普通函数随执行步骤执行(正常执行) 具体顺序 FROM FROM后面的表标识了这条语句要查询的数据源。和一些子句如，（1-J1）笛卡尔积，（1-J2）ON过滤，（1-J3）添加外部列，所要应用的对象。FROM过程之后会生成一个虚拟表VT1。(1-J1)笛卡尔积 这个步骤会计算两个相关联表的笛卡尔积(CROSS JOIN) ，生成虚拟表VT1-J1。(1-J2)ON过滤 这个步骤基于虚拟表VT1-J1这一个虚拟表进行过滤，过滤出所有满足ON 谓词条件的列，生成虚拟表VT1-J2。(1-J3)添加外部行 如果使用了外连接(外连接才会加入字段/数据)，保留表中的不符合ON条件的列也会被加入到VT1-J2中，作为外部行，生成虚拟表VT1-J3。此时 不符合ON的会被加入回来 WHERE 对VT1过程中生成的临时表进行过滤，满足where子句的列被插入到VT2表中。 数据现在还没有被分组，因此现在你不能使用聚合运算- GROUP BY 这个子句会把VT2中生成的表按照GROUP BY中的列进行分组。生成VT3表。每一个分组必须只能返回一行(除非被过滤掉)，即每一行整体都无重复，对于没有出现GROUP BY后面的列必须使用聚合函数(如 MAX ,MIN,COUNT,AVG等)，保证每一个GROUP只返回一行 HAVING 这个子句对VT3表中的不同的组进行过滤，满足HAVING条件的子句被加入到VT4表中。 SELECT 这个子句对SELECT子句中的元素进行处理，生成VT5表。(5-1)计算表达式 计算SELECT 子句中的表达式，生成VT5-1 如果这个sql语句是一个聚合查询，在GROUP BY之后，你只能使用GROUP BY中的列，对不属于GROUP集合中的列必须使用聚合运算(5-2)DISTINCT 寻找VT5-1中的重复列，并删掉，生成VT5-2(5-3)TOP 从ORDER BY子句定义的结果中，筛选出符合条件的列。生成VT5-3表 ORDER BY 从VT5-3中的表中，根据ORDER BY 子句的条件对结果进行排序，生成VC6表。唯一一个可以使用SELECT子句创建的别名的地方 聚合函数是对一组值执行计算并返回单一的值的函数 1234567SELECT C.customerid, COUNT(O.orderid) AS numordersFROM dbo.Customers AS C LEFT OUTER JOIN dbo.Orders AS O ON C.customerid = O.customeridWHERE C.city = 'Madrid'GROUP BY C.customeridHAVING COUNT(O.orderid) 关于 表 Joins Joins 子句用于结合两个或多个数据库中表的记录, 也就是说是通过某种联系建立表之间的关联, 并形成一张新表 SQL 定义了三种主要类型的连接 交叉连接 ( CROSS JOIN ), 又称 笛卡尔积 会形成庞大的表, 因此慎用。假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 cross join t2结果: 数据数量为20行数据(5 4), 5列 内连接 ( INNER JOIN ), 通常可省略 inner 通过 on 或 where 建立表之间的联系或者说表形成的条件假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 inner join t2 on t1.sid = t2.sid*结果: 查询操作列出与连接条件匹配的数据行, 5列 外连接 ( OUTER JOIN ) 外连接为内连接的扩展, 主要区别在于哪边为基准, 使用 on 进行数据关联外连接分为: 左外连接、右外连接、全外连接部分SQL语言并不包含全部种类, 例如SQLite 之包含 左外连接 左外连接 ( LEFT JOIN )假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 left join t2 on t1.sid = t2.sid*结果: 以左表为基准, 将数据按条件进行连接, 左表行全部显示, 若右表没有满足条件的行则显示为NULL, 5列 右外连接 ( RIGHT JOIN ) 假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 right join t2 on t1.sid = t2.sid*结果: 以右表为基准, 将数据按条件进行连接, 右表行全部显示, 若左表没有满足条件的行则显示为NULL, 5列 全外连接 ( FULL JOIN ) 假设: 表t1(5行数据, 3列), 表t2(4行数据, 2列)SQL: select from t1 full join t2 on t1.sid = t2.sid*结果: 完整的显示两表的数据, 将数据按条件进行连接, 当没有被关联的表中没有存在满足条件的行时, 则显示为NULL, 5列]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js项目 部件简介 (未完待续)]]></title>
    <url>%2F2017%2F03%2F31%2FVue.js%E9%A1%B9%E7%9B%AE-%E9%83%A8%E4%BB%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[🦋 目前国内前端MVVM最火的框架.. 前段时间写了一个About页面, 这几天顺带整理一下知识点. Vue.js Vue.js是当下很火的一个JavaScript MVVM库，它是以数据驱动和组件化的思想构建的.类似的有Angular.js. 可以建立DOM和数据之间的绑定 可以按功能/组件抽离HTML代码 相关Vue 项目实践 - 持续更新 功能部分基础 数值默认双向绑定 支持 条件语法特性/功能函数/生命周期 动态设定style/class 捆绑event 渲染生命周期高级 单页面组件 自定义指令 单元测试 插件 单文件组件.vue定义:12345678&lt;template&gt; &lt;h1&gt;This is title&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: 'Title' &#125;&lt;/script&gt; 使用:123456789101112131415&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;Title&gt;&lt;/Title&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Title from './components/Title' export default &#123; name: 'app', components: &#123; Title &#125; &#125;&lt;/script&gt; Vue Router 扩展 Vue按字面意思来看为Vue 路由其实质也就是用于单页应用管理页面跳转, 负责路径解析. 123456789101112131415import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]&#125;) Vuex 扩展 Vue当开发大型项目时, 为防止 Vue 太过臃肿, 使用 Vuex 管理数据状态. webpack 一款模块加载器兼打包工具使用模块的理念来处理 JS/CSS/图片等资源文件 指令123456789# 安装npm install webpack --save-dev# 执行webpack --display-error-details # 输出详细错误 --watch # 实时监听并自动打包 --config &lt;file&gt; # 指定配置文件打包 -p # 压缩打包 -d # 生成map映射文件 配置(webpack.config.js)12345678910111213141516171819module.exports = &#123; // 插件 plugins: [], // 页面入口 entry: &#123;&#125;, // 入口文件输出位置, 即处理后的文件存放位置 output: &#123;&#125;, module: &#123; // 文件处理加载器 rules: [] &#125;, // 额外处理 resolve: &#123; // 自动扩展文件后缀, require时可以进行省略 extensions: [], // 模块定义别名, require时可以进行路径省略, 直接使用别名 alias: &#123;&#125; &#125;&#125; 入口文件(main.js)1234567891011121314151617181920import Vue from 'vue'import App from './App'import router from './router'import store from './store/index'// 引入js, 加载器会自动进行处理import holderjs from 'holderjs'// 引入 css/scss, 加载器会自动进行处理import appScss from './assets/app.scss'import fontAwesomeCss from './assets/font-awesome-4.7.0/css/font-awesome.css'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) 未完待续ing]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML5</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 项目实践 - 持续更新]]></title>
    <url>%2F2017%2F03%2F26%2FVue.js-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[🐌 目前国内前端MVVM最火的框架.. 项目实践记录一些流程 相关 vue vue-router 给vue使用的路由 vuex 一个专为 Vue.js 应用程序开发的状态管理模式 webpack 快速搭建项目12345678910111213141516171819# 构建项目npm install -g vue-clivue init webpack &lt;project-name&gt;# 试行cd iPagenpm installnpm run dev# 安装 vuexnpm install vuex -S# 安装 sass 开发支持npm install --save-dev sass-loadernpm install --save-dev node-sassnpm install --save-dev css-loadernpm install --save-dev style-loader# 编译生成静态文件npm run build 目录结构12345678910111213141516. ├── README.md ├── build ├── config ├── index.html ├── node_modules ├── package.json ├── src // 源码| ├── App.vue // 父组件 | ├── assets // 静态文件 | ├── components // 公共组件 | ├── main.js // webpack打包入口文件 | └── router | └── index.js // 页面路由 ├── static └── test 遇到的问题]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML5</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Objective-C 的小笔记]]></title>
    <url>%2F2017%2F03%2F20%2F%E5%85%B3%E4%BA%8E%20Objective-C%20%E7%9A%84%E5%B0%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[之前学 swift3 顺带整理的小笔记 Objective-C介绍 文件后缀 文件类型 *.h 头文件。头文件包含类，类型，函数和常数的声明。 *.m 源代码文件。这是典型的源代码文件扩展名，可以包含 Objective-C 和 C 代码 *.mm 源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。 说明 关键词 说明 #import 引入文件, 并确保相同的文件只会被包含一次 NSString* say = @”Hello World” 创建NSString对象 @interface/@implementation objective-c 一个类是由:定义和实现来构成的, @interface 用于定义, @implementation用于实现细节. @property与@synthesize @property用于在@interface声明getter与setter函数, @synthesize用于在@implementation实现getter与setter函数, 二者是搭配口味高版本(Xcode4.5)可省略@synthesize 基础框架 它包括 NSArray，NSDictionary中的NSSet等扩展数据类型的列表。 它由一组丰富的操作文件的函数，字符串，等等。 URL处理它提供的功能，如日期格式，数据处理，错误处理等实用工具 语法语法速读123456789101112131415161718192021222324252627282930313233/* 预处理(导包) */#import &lt;Foundation/Foundation.h&gt;/* 定义接口(继承:NSObject) */@interface SampleClass:NSObject- (void)sampleMethod;@end/* 实现接口(SampleClass) */@implementation SampleClass- (void)sampleMethod&#123; NSLog(@&quot;Hello, World!&quot;);&#125;@end/* 主函数 */int main() &#123; /* my first program in Objective-C */ SampleClass *sampleClass = [[SampleClass alloc]init]; /* - 调用函数 C: sampleClass.sampleMethod(args); OC: [对象 函数名: 参数] */ [sampleClass sampleMethod: args]; return 0;&#125; 类的语法 类分为: 类的定义(.h) 和 类的实现(.m) 定义 ( *.h )123456789101112131415@interface MyObject : NSObject&#123; // 此处变量默认为受保护(protected) int memberVar1; // 实体变量 id memberVar2;&#125;+(return_type) class_method; // &quot;+&quot; 表示 类方法-(return_type) instance_method1; // &quot;-&quot; 表示 实例方法-(return_type) instance_method2: (int) p1;// 这里的调用方式为: [obj instance_method3: 1 andPar: 2];// andPar 相当于外部的另外一个别名-(return_type) instance_method3: (int) p1 andPar: (int) p2;@end 实现 ( *.m )12345678910111213141516171819@implementation MyObject&#123; // 此处变量为私有(private) int memberVar3; //私有实体变量&#125;+(return_type) class_method &#123; .... //method implementation&#125;-(return_type) instance_method1 &#123; ....&#125;-(return_type) instance_method2: (int) p1 &#123; ....&#125;-(return_type) instance_method3: (int) p1 andPar: (int) p2 &#123; ....&#125;@end 创建对象1234// 注: alloc 与 init 都属于 NSObject 里的函数MyObject * my = [[MyObject alloc] init];// 无参构建, 也可采用以下方式 (Objective-C 2.0)MyObject * my = [MyObject new]; Note: { } 需如文这样标识, 才可表达出准确的语义, 读者自行领悟. 函数语法 函数分为: 类函数 和 对象函数 12345678910111213// 如上// 定义语法: 范围标识 (返回值)函数名:外部形参别名:(参数类型) 形参名 外部形参别名:(参数类型) 形参名// 注: 第一个 外部形参别名 可省略- (void)insertObject:(id)anObject atIndex:(NSUInteger) index+ (void)insertObject:(id)anObject atIndex:(NSUInteger) index// 调用// 对象调用 [对象 函数名: 参数1 外部形参别名: 参数2][obj insertObject: arg1 atIndex: arg2]// 类调用 [类名 函数名: 参数1 外部形参别名: 参数2][Object insertObject: arg1 atIndex: arg2]// 注:) 类调用 和 对象调用 的形式是一样的 属性语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@interface Person : NSObject&#123;/*相当于 @public 至 @private 之间的属性被暴露出去可通过实例直接访问, 例如: obj-&gt;name*/@public NSString *name;@private int age;&#125;/* 参考: http://justcoding.iteye.com/blog/1444548 使用范围: @interface, @protocol, @category 可声明特性: 读写属性： （readwrite/readonly） setter语意：（assign/retain/copy） 原子性： （atomicity/nonatomic） 使用效果(声明一个setter与getter方法): - (NSString*)name; - (void)setName: (NSString*)newName; */@property(copy) NSString *name;@property(readonly) int age;-(id)initWithAge:(int)age;@end@implementation Person/* 使用范围: @implementation 使用效果(自动实现一个setter与getter方法): - (NSString*)name &#123; return name; &#125; - (void)setName: (NSString*)newName &#123; name = newName; &#125; */@synthesize name;/* @dynamic 仅仅是告诉编译器这两个方法在运行期会有的，无需产生警告 */@dynamic age;-(id)initWithAge:(int)initAge&#123; age = initAge; // 注意：直接赋给成员变量，而非属性 return self;&#125;-(int)age&#123; return 29; // 注意：并非返回真正的年龄&#125;@end 类或协议的属性可以被动态的读取 类似反射机制 , 略过.. 快速枚举 一种省内存的循环遍历 , 略过.. 协议语法 类似 Java 中的接口123456789101112131415161718192021/*定义协议*/@protocol Locking- (void)lock;- (void)unlock;@end/*类的@interface 宣称使用 协议*/@interface SomeClass : SomeSuperClass &lt;Locking&gt;@end/*类的@implementation 实现 协议 细节*/@implementation SomeClass- (void)lock &#123; // 实现lock方法...&#125;- (void)unlock &#123; // 实现unlock方法...&#125;@end 动态类型 id 相当于 Java 中的 Object, 即 任意对象 类别 (Category) 语法 分类不仅可以增加类的方法，也可以代替原有的函数, 并不能新增变量动态增加和替换函数, 强得一匹 123456789101112131415161718192021222324252627282930313233/* 说明: 定义扩展 Integer类 接口, 新增/覆盖 函数 showstars 与 showint 语法: #import &quot;待扩展类接口文件.h&quot; @interface 待扩展类(扩展类) // 函数定义 @end*/#import &quot;Integer.h&quot;@interface Integer(Display)- (id) showstars;- (id) showint;@end/* 说明: 实现扩展 Integer类 接口, 新增/覆盖 函数 showstars 与 showint 语法: #import &quot;扩展类接口文件.h&quot; @implementation 待扩展类(扩展类) // 函数实现 @end*/#import &quot;Display.h&quot;@implementation Integer(Display)- (id) showstars &#123; ..&#125;- (id) showint &#123; ..&#125;@end NOTE: 使用时需#import 待扩展类与扩展类的接口文件(.h) 划重点 NSString*/NSObject*等 表示对象 self 某种程度相当于 this nil 基本上等同于 NULL 调用属性 self-&gt;name 一般(.h 存放@interface文件, .m 存放@implementation文件). 进行#import时, 只需#import .h文件]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Laravel 快速入门]]></title>
    <url>%2F2017%2F03%2F01%2FPHP-laravel-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[PHP 框架 Laravel 搭建开始, 慢慢更新~ 😜😜😜😜 Quit Start一. 安装composer, 用于管理依赖 123456# 全局安装 macOSbrew updatebrew tap josegonzalez/homebrew-phpbrew tap homebrew/versionsbrew install php55-intlbrew install josegonzalez/php/composer 二. 下载laravel 1composer global require "laravel/installer" 三. 创建项目 1composer create-project laravel/laravel --prefer-dist 四. 关于如何使用PhpStorm 默认已经配置好PHP开发环境了! 4.0.1 相关插件 Laravel Plugin [Optional] PHP Annotations Plugin [Optional] Symfony2 Plugin 4.1 配置Composer 右键项目根节点 -&gt; Composer -&gt; init composer, 配置PHP解释器和Composer路径 右键项目根节点 -&gt; Composer -&gt; add dependency, 添加barryvdh/laravel-ide-helper 或者 1composer require barryvdh/laravel-ide-helper 4.2 编辑config/app.php文件, 在providers节点下面添加 4.3 扩展命令工具 Preferences -&gt; Tools -&gt; Command Line Tool Support 使用: Tools -&gt; Run Command(⌘ + ⇧ + X) 4.4 配置 php-xdebug12# 检查是否安装php-xdebugphp -m 安装后，修改下php.ini把xdebug.so前的注释’;’去掉 五. 配置启动 六. 配置Debug 并且在根目录加入debug.ini 123456789101112xdebug.remote_enable = Onxdebug.remote_autostart = Onupload_max_filesize = 1000Mpost_max_size = 1005Mmax_execution_time = 120;xdebug.profiler_enable = On;xdebug.profiler_enable_trigger = Off;xdebug.profiler_output_dir = ./xdebug;xdebug.profiler_aggregate = On;xdebug.profiler_append = On;xdebug.profiler_output_name = &quot;cachegrind.out.%R.%u.%p&quot; 资源Laravel Live Templates for PhpStormLaravel 插件视频 标签 继承@extends 存在替换@yield(&#39;content&#39;)@section@endsection 增加@stack(&quot;appendCSS&quot;)@push(&#39;appendCSS&#39;)@endpush 注入@inject(&quot;xx&quot;, &quot;xx[Name]&quot;)]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 部署]]></title>
    <url>%2F2017%2F02%2F24%2FNginx-%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[🎽 Nginx 是一个很强大的高性能Web和反向代理服务器 前言环境OS: Ubuntu-16 安装依赖 PCRE zlib nginx 目录结构/opt|– nginx-1.10.1|– pcre-8.38`– zlib-1.2.8 shell 以下操作均在/opt目录 123# tar -zxvf nginx-1.10.1.tar.gz# cd nginx-1.10.1# ./configure ERROR:12345checking for OS + Linux 2.6.32-042stab113.21 x86_64checking for C compiler ... not found./configure: error: C compiler cc is not found 缺失编译部件, 解决办法如下:12# apt-get install build-essential libtool# ./configure Error:1234./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre=&lt;path&gt; option. 缺失PCRE, 移步官网下载(顶部有链接), 我是在/opt目录中解压注: pcre 没有 2 以下操作均在/opt目录 123# tar -jxvf pcre-8.38.tar.bz2# cd pcre-8.38# ./configure &amp;&amp; make &amp;&amp; make install 回到/opt/nginx-1.10.1目录继续进行1# ./configure --with-pcre=/opt/pcre-8.38 Error:1234./configure: error: the HTTP gzip module requires the zlib library.You can either disable the module by using --without-http_gzip_moduleoption, or install the zlib library into the system, or build the zlib librarystatically from the source with nginx by using --with-zlib=&lt;path&gt; option. 原因是缺失zlib,移步官网下载(顶部有链接), 同样是在/opt目录中解压 以下操作均在/opt目录 123# tar -zxvf zlib-1.2.8.tar.gz# cd zlib-1.2.8# ./configure &amp;&amp; make &amp;&amp; make install 回到/opt/nginx-1.10.1目录继续进行 123# ./configure --with-pcre=/opt/pcre-8.38 --with-zlib=/opt/zlib-1.2.8# make# make install 至此，安装结束。可查看ls /usr/local/nginx/目录显示如下文件:/usr/local/nginx/ 基础命令 以下命令均在/usr/local/nginx目录下运行 12345678# 启动./sbin/nginx# 检查配置./sbin/nginx -t# 重新加载配置./sbin/nginx -s reload# 查看配置文件cat ./conf/nginx.conf 扩展nginx.conf配置字段详解 模块待续ing]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Chrome 插件开发的一些知识点]]></title>
    <url>%2F2017%2F02%2F04%2F%E5%85%B3%E4%BA%8EChrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[身为Chrome重度患者，生活和工作处处不离，这篇并不是入门教程，而是开发中的一些小Tip的记录. 我开发的Chrome 插件 天气预报 数据存储 HTML5 localStorage 存储在解析页面当前范围和网站共享localStorage Chrome API chrome.storage 存储在系统磁盘，适合少量数据 Web SQL Database 存储在系统磁盘，适合大量数据 脚本运行范围 background 浏览器打开后运行, 会一直存在于后台, 因此开发时更改后必须⌘+R重新加载 content_scripts 在网页加载后运行 html内导入的脚本 运行于该html页面, 例如: option页面和popup页面 Note: popup.js 于background.js 是可以进行共通的.使用var BG = chrome.extension.getBackgroundPage(); BG便是background.js的window对象 Action 入口 地址栏右侧图标外 browser_action 可显示badge 右键菜单 chrome.contextMenus 可在background中创建 地址栏右侧图标内外 page_action 新版的已更改显示在外围 PageAction API 多功能框 omnibox 对地址框进行监听 overrides 如, 管理书签/历史记录/新标签页等 (一个扩展只能替换一个页面) 桌面提醒 webkitNotifications.createNotification 权限 相当一部分Chrome API 使用需要在Manifest申明权限 页面间通信 popup 与 background 通信 使用上面提到的共通的特性。 使用 chrome.extension.onMessage.addListener进行通信监听 与 使用chrome.extension.sendMessage进行触发 option 与 (popup 或者 background) 通信 使用 chrome.extension.onMessage.addListener进行通信监听 与 使用chrome.extension.sendMessage进行触发 (popup 或者 background) 与 option 通信 使用 chrome.extension.onMessage.addListener进行通信监听, 触发方式比较麻烦, 查看以下例子:12345678chrome.tabs.query(&#123;active: true, currentWindow: true&#125;, function (tabs) &#123; if (!!tabs &amp;&amp; tabs.length &gt; 0) &#123; chrome.tabs.sendMessage(tabs[0].id, &#123; //message.. &#125;, callback); &#125; &#125;); i18 CSS __MSG_@@key JS chrome.i18n.getMessage(‘key’); 关于打包 &amp; 发布 扩展程序中进行打包，生成.crx(扩展程序) &amp; .pem(秘钥重要) 前往Chrome 开发者中心 认证需支付5美元用于认证 把.pem更名为key.pem并放入源码文件夹中，打包为.zip文件 上传 并编辑 (必填 (扩展描述、ICON(128x128)、扩展截图(1280x800 or 640x400)、类别、语言)) 如有遗漏或错误欢迎补充..]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于log4j报错]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%85%B3%E4%BA%8Elog4j%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[Java开发中经常遇到日志冲突或者异常, 彻底的来此追根究底. 日志历史 log4j JCL + log4j SLF4J slf4j-XXX-version.jar [XXX指代log4j12, jdk14, jcl, nop 等] slf4j-api v1 log4j 早期直接实现日志打印v2 JCL + log4j 动态绑定, 面向JCL 接口实现的log4jv3 slf4j-api 提供 SLF4J接口 面向对象编程slf4j-XXX-version.jar 对接口和指定XXX种类日志的具体实现 slf4j 举例jar log4j-over-slf4j.jar 把log4j转为slf4j slf4j-log4j12.jar 以slf4j标准实现的log4j12 XXX-over-slf4j.jar 把日志重定向到slf4j eg.jcl-over-slf4j.jar 总结即.Component | | log to Apache Commons Logging V jcl-over-slf4j.jar — (redirect) —&gt; SLF4j —&gt; slf4j-log4j12-version.jar —&gt; log4j.jar —&gt; 输出日志解释:JCL实现的重定向为SLF4J日志形式, 然后SLF4J转为Log4j12输出!]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 相关]]></title>
    <url>%2F2016%2F10%2F20%2FRedis-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Redis 的部署和部位设计的实践, 还有常见问题的梳理! 💪 前言官网 详情默认项 端口 6379 目录结构redis-3.2.4/|– redis.conf redis配置文件-- src编译后目录|-- redis-server启动bit文件`-- redis-cli终端bit文件` 安装 以下操作均在/opt1234567# 下载wget http://download.redis.io/releases/redis-3.2.4.tar.gz# 解压tar -zxvf redis-3.2.4.tar.gzcd redis-3.2.4# 编译， 生成`src`目录make 指令 以下操作均在/opt1234# 默认配置运行./redis-3.2.4/src/redis-server# 指定配置文件运行./redis-3.2.4/src/redis-server [config file] 疑问？ 如何使redis后台运行? 更改配置文件, 找到daemonize字段,更改no为yes, 重启redis 切记！要指定配置文件 如何更改redis默认6379端口? 更改配置文件, 找到port字段,更改为指定端口, 重启redis 切记！要指定配置文件 如何设置redis的验证密码? 更改配置文件, 找到requirepass字段, 设置相应的验证密码, 重启redis 切记！要指定配置文件由于增加了验证密码，因此客户端连接命令为redis-cli –a [upassword]]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 下的 Oh My ZSH!]]></title>
    <url>%2F2016%2F09%2F30%2FUbuntu%E4%B8%8B%E7%9A%84OhMyZSH!%2F</url>
    <content type="text"><![CDATA[号称终极shell :) 前言什么是zsh？shell的一种,cat /etc/shells查看当前系统支持的shell 相关Link为什么说 zsh 是 shell 中的极品？ 环境OS: Ubuntu 16.04 x86_64 目录结构 ~/.zshrc 文件zsh配置文件 可用来更改Theme 加载Plugin ~/.oh-my-zsh oh-my-zsh目录 安装12345678910# 安装zsh$ sudo apt-get install zsh# 安装oh-my-zsh$ sudo apt-get install wget git$ wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh# 替换zsh为系统shell$ chsh -s /bin/zsh# 退出&amp;重新登入$ exit# 查看是否成功 配置文件zsh.config 注意 需更改.oh-my-zsh的目录 插件介绍 git;处于git项目下出现提示 autojump; 目录自动提示, 需要Linux 额外安装 12# ~/.bashrc 追加[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh git;处于git项目下出现提示 zsh-syntax-highlighting;高亮可用命令 12$ git clone git://github.com/jimmijj/zsh-syntax-highlighting ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlightingplugins=(zsh-syntax-highlighting) colored-man-pages; 帮助文档高亮 colorize;更多代码高亮 copydir; 整个目录拷贝 command-not-found;命令行智能提示 history;查看输入历史 z; autojump同类 主题 ys 小技巧 转换路径时可以省去cd命令，直接输入路径即可 d 可以查看访问过的路径，然后输入数字就可以直接切换 输入不完整的路径/文件/命令，按下tab键可以出现提示，再按tab则可以实现路径补全 普通命令使用两次tab可进入选择模式， ctrl+f/b/n/p 可以向前后左右切换 kill + tab 强强强 alias -s xx=’xxx’ 快捷配置 相关设置 cat 代码高亮123pip install Pygments# 增加以下alias# alias ccat='pygmentize -g' 后续Oh My ZSH!]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
        <tag>Oh My ZSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glup 自动化构建工具]]></title>
    <url>%2F2016%2F09%2F20%2FGlup-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Gulp.js 是一个自动化构建工具 😜 来源Glup 整合 Glup Glup用自动化构建工具增强你的工作流程！ 安装12$ npm install gulp -g$ npm install gulp --save-dev 插件 编译Sass (gulp-ruby-sass) Autoprefixer (gulp-autoprefixer) 缩小化(minify)CSS (gulp-minify-css) JSHint (gulp-jshint) 拼接 (gulp-concat) 丑化(Uglify) (gulp-uglify) 图片压缩 (gulp-imagemin) 即时重整(LiveReload) (gulp-livereload) 清理档案 (gulp-clean) 图片快取，只有更改过得图片会进行压缩 (gulp-cache) 更动通知 (gulp-notify)1$ npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-clean gulp-notify gulp-rename gulp-livereload gulp-cache --save-dev]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ngrok使用指南]]></title>
    <url>%2F2016%2F08%2F31%2FNgrok%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[Ngrok 是一款内部端口转发，对于微信类似的开发很有用的😆可参照墙内(花生壳 or nat123) 概述编译环境:Go 1.4.1 强烈建议根域名: web.hocg.in,即生成的域名为*.web.hocg.in文件结构:ngrok ├── bin │ └── ngrok.cfg ├── client.sh ├── code.sh └── server.sh部署环境:服务器OS: Ubuntu-15客户端OS: Ubuntu-16 安装环境依赖及源码下载 以下命令根目录统一在/opt 12345# 环境依赖sudo apt-get install build-essential golang mercurial git# 获取 ngrok 源码git clone https://github.com/tutumcloud/ngrok.git ngrokcd ngrok 生成证书 &amp;&amp; 编译 以下命令根目录统一在/opt/ngrok code.sh文件 生成证书 &amp;&amp; 编译服务端DOMAIN 为配置的根域名, 用于签名. 1234567891011121314151617181920212223#!/bin/bashecho "开始清除.."rm -rf assets/client/tls/ngrokroot.crtrm -rf assets/server/tls/snakeoil.crtrm -rf assets/server/tls/snakeoil.keyrm -rf device.*rm -rf rootCA.*DOMAIN=web.hocg.inecho "设置域名为[*.$DOMAIN]"echo "开始生成秘钥.."openssl genrsa -out rootCA.key 2048openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$DOMAIN" -days 5000 -out rootCA.pemopenssl genrsa -out device.key 2048openssl req -new -key device.key -subj "/CN=$DOMAIN" -out device.csropenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000echo "开始迁移秘钥.."cp -rf rootCA.pem assets/client/tls/ngrokroot.crtcp -rf device.crt assets/server/tls/snakeoil.crtcp -rf device.key assets/server/tls/snakeoil.keyecho "开始编译.."make release-server 客户端 前置条件: Go需先增加对这些平台交叉编译的支持 Windowsgo的src目录 1GOOS=windows GOARCH=amd64 ./make.bash nginx目录,编译1GOOS=windows GOARCH=amd64 make release-client macOSgo的src目录 1GOOS=darwin GOARCH=amd64 ./make.bash nginx目录,编译1GOOS=darwin GOARCH=amd64 make release-client Linuxnginx目录,编译1make release-client 配置文件ngrok.cfg文件 server_addr 为配置的根域名， 4443为默认端口 12server_addr: web.hocg.in:4443trust_host_root_certs: false 运行文件server.sh文件 服务器运行DOMAIN 为配置的根域名.注释的那一句用于后台运行 1234567#!/bin/bash# $1 HTTP# $2 HTTPSkillall ngrokdDOMAIN=web.hocg.in# nohup ./bin/ngrokd -domain="$DOMAIN" -httpAddr=":$1" -httpsAddr=":$2" &gt;/tmp/ngrok.log 2&gt;&amp;1 &amp;./bin/ngrokd -domain="$DOMAIN" -httpAddr=":$1" -httpsAddr=":$2" client.sh文件 客户端运行, default:linux具体环境修改具体内容 1234#!/bin/bash# $1 Port# $2 domain./bin/ngrok -subdomain $2 -proto=http -config=./bin/ngrok.cfg $1 使用 若需变更域名, 需修改code.sh的DOMAIN、server.sh的DOMAIN与./bin/ngrok.cfg的server_addr 编译1sh code.sh 成功 检查ngrok/bin文件夹是否存在ngrok and ngrokd 服务端1sh server.sh 8888 9999 客户端1sh client.sh 8080 dm 检验访问:http://dm.web.hocg.in:8888 重要关于域名解析eg. *.web.hocg.in路径解析需配置*.web and web 两个A记录 关于签名最好在同一环境进行服务端和客户端的编译 小技巧 如何让服务端的ngrok后台运行 正常的nohup或&amp;是无法使ngrok后台运行的需使用screen 123456789# 安装\# apt-get install screen# 使用screen -S [命名] [需放入后台的命令]# 使用 ctrl+A+D 让其运行在后台# 查看screen 后台进程screen -ls# 重新连接后台进程screen -r [进程id] 可能遇到的异常 Go-1.2.1语言版本不支持go version12345# github.com/gorilla/websocketsrc/github.com/gorilla/websocket/client.go:361: unknown tls.Config field 'GetCertificate' in struct literalsrc/github.com/gorilla/websocket/client.go:370: unknown tls.Config field 'ClientSessionCache' in struct literalsrc/github.com/gorilla/websocket/client.go:373: unknown tls.Config field 'CurvePreferences' in struct literalmake: *** [client] Error 2 官方Go-64的安装 Go编译器找不到go-bindata123GOOS="" GOARCH="" go get github.com/jteeuwen/go-bindata/go-bindata/bin/sh: 1: go: not foundmake: *** [bin/go-bindata] Error 127 请注意配置好GOROOT和GOPATH GOROOT为安装GO的目录GOPATH自定义一个GO插件下载目录 执行以下shell下载插件 1go get -u github.com/jteeuwen/go-bindata/... END:)]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Ngrok</tag>
        <tag>Tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nexus 入门]]></title>
    <url>%2F2016%2F08%2F24%2FNexus%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[适合nexus入门，不是手机，不是手机，不是手机 ．．ｏ（╯□╰）ｏ 环境 Ubuntu-14.04.1 jdk1.8.0_102 nexus-2.12.0-01|官网 域名:nexus.hocg.in 前置条件 安装完jdk并配置好环境变量 eg: java查看是否成功 安装温馨提示: 以下操作都是在/opt目录下 下载&amp;解压123456# 下载wget https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.12.0-01-bundle.tar.gz# 解压tar -zxvf nexus-2.12.0-01-bundle.tar.gz# 清理rm -rf *.gz 文件/目录详解 nexus-2.12.0-01 程序目录 sonatype-work 仓库目录(内包含仓库配置及jar包仓库) 基本操作1./nexus-2.12.0-01/bin/nexus &#123; console | start | stop | restart | status | dump &#125; 访问 http://nexus.hocg.in:8081/nexus 默认账号:admin 默认密码: admin123 如何使用Maven 中配置仓库1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Nexus&lt;/id&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://nexus.hocg.in:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; 问题如何修改默认8081端口12vim /opt/nexus-2.12.0-01/conf/nexus.properties# 修改application-port=8081项 如何创建用户登陆系统后，左侧Security &gt; Users中创建 如何使用构建账号修改Settings.xml文件 (Maven)1234567&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus.hocg.in&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;/server&gt;&lt;/servers&gt; 如何修改用户密码登陆系统后，顶部点击用户名 &gt; Profile中修改 如何建立与中央仓库的索引 Note: Nexus会自动建立任务计划,一般远程仓库都比较大，构建会比较多，因此索引文件会很大，请确保磁盘大小充足. 可能出现的报错 1 WARNING - NOT RECOMMENDED TO RUN AS ROOT , 原因是提醒你是否确认用root用户运行12345678\# ./nexus-2.12.0-01/bin/nexus restart****************************************WARNING - NOT RECOMMENDED TO RUN AS ROOT****************************************Stopping Nexus OSS...Nexus OSS was not running.Starting Nexus OSS...Started Nexus OSS. 解决:1234567891011vim ./nexus-2.12.0-01/bin/nexus# 加入系统变量vi /etc/profile# 加入export RUN_AS_USER=root# 修改RUN_AS_USER=root# 启动./nexus-2.12.0-01/bin/nexus start# 查看是否启动成功./nexus-2.12.0-01/bin/nexus status# 稍等几分钟再访问]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Nexus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android L 及以上版本Rom包中提取apk]]></title>
    <url>%2F2016%2F08%2F07%2FAndroid-L-%E5%8F%8A%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%ACRom%E5%8C%85%E4%B8%AD%E6%8F%90%E5%8F%96apk%2F</url>
    <content type="text"><![CDATA[提取想要的apk， 例如CM ROM包中的含天气的时钟不错！ 以往版本 Android Rom包只需解压后，取出system包即可取出内部apk Now 解压后可以发现，文件发生了改变并且system.new.dat此文件是不支持直接解压的。 环境系统: win10工具: 下载 环境自备 操作步骤 普通方式解压ROM 运行下载工具中.bat文件Extractor.bat 根据提示选择1，并复制system.new.dat, system.transfer.list，file_contexts三个文件到bat文件所在目录 按任意键继续 完成后可以得到一个system文件夹 嘿嘿嘿.. 问题! 有可能在你安装apk的时候出现应用未安装的情况 可以尝试重新对apk进行签名 检查是否已经安装过该apk End]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>手机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块设计之对接同步订单模块]]></title>
    <url>%2F2016%2F08%2F02%2F%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E4%B9%8B%E5%AF%B9%E6%8E%A5%E5%90%8C%E6%AD%A5%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[实习期间设计的对接同步订单的某块, 缅怀..设计日期(2016.6) 前言 #对接同步订单模块# 该部分是我入职后自主设计的一个模块，因为初期预计对接5家平台的订单，并考虑到后期可能对接更多平台和平台订单数量等，所以扩展性和性能方面是很值得深思的问题。 开发周期 (20day) 前期需求的多次变更，大大的浪费了开发周期. 库表设计 接口整理和整合设计(主要是对接平台的接口整合等) 代码编写 业务流程图表 商品表,存储商品信息, 主要配合方案匹配 授权表,存储用户授权信息，主要用于token管理 平台配置表,存储平台key信息 方案表,已存在，存储方案信息 v1版思路图 业务图 原先，该部分设计是不考虑对订单数据进行缓存处理的，但后期需求多次变更被迫进行数据缓存，因此再原先的基础上建立了线程池并对同步订单部分进行异步线程处理，因此增加了一张订单缓存表和事件队列表。 v2版思路图 业务图 后面又对缓存表进行了数据去重防止表数据爆炸性增长。 总结 把公共抽离出来，中间新增转化层可以很好的解决代码复用的问题.]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块设计之消息模块]]></title>
    <url>%2F2016%2F07%2F30%2F%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E4%B9%8B%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[新手上路，小心撞车.. 前言 #消息模块# 这是我刚入职时所接触的第一个模块，也算是比较大的模块了。这个模块的业务是负责整个项目所有的消息出入口，包含短信发送，APP推送，邮件发送以及前后端人员站内消息。当时设计的时候需求架构比较简单而且时间紧迫(π__π)，没有从根本理清业务和功能后期存在的扩展。因此，这篇文章是记录当时架构的思路和需要改善的地方。 开发周期 (10day) 库表设计 接口整理和整合设计(短信&amp;友盟&amp;邮件等) 代码编写 业务流程图表 消息记录表, 主要负责消息出入口记录 事件触发表, 主要对消息进行控制，例如: 触发订单变更推送到用户/运营人员 and so on 消息状态表, 主要负责消息发送的状态，包含定时发送，撤销发送 and so on 图 类流程图 如图，此模式主要是利用工厂模式, 提供多种消息通道实例，由不同的消息通道对自身通道消息进行处理，类似于把西瓜，牛肉，白菜等送入不同的工厂进行加工，但是又由食品质量控制中心对其进行记录和检验。 优点: 后期便于扩展更多的通道模式缺点: 各个模式是靠类型区别的，不便于进行细节化处理(例如，对某部分APP推送进行定制化，进入某个Activity等细节化定制) 进一步优化类流程图 使用Route进行更细节的定制化处理更多实战，推荐 图 囧，单看图可能细分不出两者的差别，附上一段代码实例 123456789101112131415// 路由规则初始化，用于定义匹配规则NoticeRouter router = new NoticeRouter();route.rule() .noticeType(Notice.SMS) // ... 更多细节规则匹配 .handler(smsHandler) .end() .rule() .noticeType(Notice.EMail) // ... 更多细节规则匹配 .handler(emailHandler) .end()// 将通知实体通知路由处理router.route(message) 总结 充分考虑后期业务需求 (就算非必须的业务需求) 不要妄想需求是恒久不变的，需求=小三，扩展=真爱]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac的使用]]></title>
    <url>%2F2016%2F07%2F02%2FMac-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[留坑，刚刚起步，梳理中ing。 小技巧 在Dock 隐藏 iTerm2隐藏:1/usr/libexec/PlistBuddy -c "Add :LSUIElement bool true" /Applications/iTerm.app/Contents/Info.plist 显示:1/usr/libexec/PlistBuddy -c "Delete :LSUIElement" /Applications/iTerm.app/Contents/Info.plist]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈JVM，各种过程]]></title>
    <url>%2F2016%2F06%2F12%2F%E8%B0%88JVM-%E5%90%84%E7%A7%8D%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[谈谈JVM 各种过程， XMind等我整理一下，稍后贴出 囧～欢迎指教..update: 2016-08-03 14:44:12 更新了图 总思路编译过程 -&gt; 运行过程[类加载器过程(类的装载过程) -&gt; 执行过程] 图 编译过程.java文件 -javac编译-&gt; .class文件 {-JIT编译(转化+优化)-&gt; 本地方法}[执行过程，当方法执行频率高] 图 运行过程类加载器 -&gt; (执行引擎 -&gt; 本地库接口)[Java 运行时数据区] -&gt; 本地方法库 图 类加载器过程[启动]类加载器(JNI) -&gt; [扩展]类加载器 -&gt; [系统]类加载器 -&gt; [自定义]类加载器 图 类装载过程加载文件到JVM内存 -&gt; (校验语言规范 -&gt; 分配结构存储类的信息 -&gt; 该类常量池中符号更改为直接引用)[Linking] -&gt; 类初始化 图 执行引擎执行过程(逐行读取指令)Thread启动 -生成-&gt; JVM栈 -执行方法-&gt; 压入栈帧(包含 局部变量数组&amp;操作数栈&amp;运行时常量池) -&gt; 逐行读取指令&amp;&amp;解释(JVM栈帧 程序计数器存放下一条指令) -&gt; {JIT(转化+优化)-&gt; 本地方法}[当方法执行频率高] -执行&amp;运算-&gt; 结果(存放 操作数栈中) -&gt; 推出栈帧 图 Java 运行时数据区(贯穿整个执行过程)共享型数据区：方法区(含运行时常量池[存放方法&amp;变量的实际地址])、堆(存放对象实例)隔离型数据区：JVM 栈、本地方法栈(JNI)、程序计数器 图]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈JVM，字节码]]></title>
    <url>%2F2016%2F06%2F12%2F%E8%B0%88JVM-%E5%AD%97%E8%8A%82%E7%A0%81%2F</url>
    <content type="text"><![CDATA[谈谈JVM，最近在研究破解jar，有这方面经验的麻烦指导一下思路.. 参考参考1指令整理 常用指令123# 反编译查看`类文件`所有信息javap -verbose [class] 局部变量类型 特殊字符表示 类型 描述 c char char类型 i int int类型 l long long类型 s short short类型 b byte byte类型 f float float类型 z boolean 布尔类型 a reference 引用 方法信息12345L1 LOCALVARIABLE this LMain; L0 L1 0 LOCALVARIABLE a I L0 L1 1 MAXSTACK = 0 MAXLOCALS = 2 局部变量参数 LOCALVARIABLE局部表大小 MAXLOCALS操作数栈大小 MAXSTACK 指令运算指令 算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。 加法指令:iadd,ladd,fadd,dadd 减法指令:isub,lsub,fsub,dsub 乘法指令:imul,lmul,fmul,dmul 除法指令:idiv,ldiv,fdiv,ddiv 求余指令:irem,lrem,frem,drem 取反指令:ineg,leng,fneg,dneg 位移指令:ishl,ishr,iushr,lshl,lshr,lushr 按位或指令:ior,lor 按位与指令:iand,land 按位异或指令:ixor,lxor 局部变量自增指令:iinc 比较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp 加载和存储指令 用于局部变量表和操作数栈之间来回传输 将一个局部变量加载到操作数栈的指令包括：iload,iload_&lt;n&gt;，lload、lload_&lt;n&gt;、float、fload_&lt;n&gt;、dload、dload_&lt;n&gt;，aload、aload_&lt;n&gt;。 将一个数值从操作数栈存储到局部变量标的指令：istore,istore_&lt;n&gt;,lstore,lstore_&lt;n&gt;,fstore,fstore_&lt;n&gt;,dstore,dstore_&lt;n&gt;,astore,astore_&lt;n&gt; 将常量加载到操作数栈的指令：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_&lt;i&gt;,lconst_&lt;l&gt;,fconst_&lt;f&gt;,dconst_&lt;d&gt; 局部变量表的访问索引指令:wide 一部分以尖括号结尾的指令代表了一组指令，如iload_&lt;i&gt;，代表了iload_0,iload_1等，这几组指令都是带有一个操作数的通用指令。 运算指令 对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶 加法指令:iadd,ladd,fadd,dadd 减法指令:isub,lsub,fsub,dsub 乘法指令:imul,lmul,fmul,dmul 除法指令:idiv,ldiv,fdiv,ddiv 求余指令:irem,lrem,frem,drem 取反指令:ineg,leng,fneg,dneg 位移指令:ishl,ishr,iushr,lshl,lshr,lushr 按位或指令:ior,lor 按位与指令:iand,land 按位异或指令:ixor,lxor 局部变量自增指令:iinc 比较指令:dcmpg,dcmpl,fcmpg,fcmpl,lcmp 类型转换指令 将两种Java虚拟机数值类型相互转换 JVM支持宽化类型转换(小范围类型向大范围类型转换)： int类型到long,float,double类型 long类型到float,double类型 float到double类型 对象创建与操作 虽然类实例和数组都是对象，Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。 创建实例的指令:new 创建数组的指令:newarray,anewarray,multianewarray 访问字段指令:getfield,putfield,getstatic,putstatic 把数组元素加载到操作数栈指令:baload,caload,saload,iaload,laload,faload,daload,aaload 将操作数栈的数值存储到数组元素中执行:bastore,castore,castore,sastore,iastore,fastore,dastore,aastore 取数组长度指令:arraylength 检查实例类型指令:instanceof,checkcast 操作数栈管理指令直接操作操作数栈的指令：pop,pop2,dup,dup2,dup_x1,dup2_x1,dup_x2,dup2_x2和swap NOTE: 压入栈顶(DUP)/弹出栈顶(POP) 控制转移指令 条件分支:ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnotnull,if_cmpeq,if_icmpne,if_icmlt,if_icmpgt等 复合条件分支:tableswitch,lookupswitch 无条件分支:goto,goto_w,jsr,jsr_w,ret 方法调用和返回指令 invokevirtual指令:调用对象的实例方法，根据对象的实际类型进行分派(虚拟机分派)。 invokeinterface指令:调用接口方法，在运行时搜索一个实现这个接口方法的对象，找出合适的方法进行调用。 invokespecial:调用需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法 invokestatic:调用类方法(static) 方法返回指令是根据返回值的类型区分的，包括ireturn(返回值是boolean,byte,char,short和int),lreturn,freturn,drturn和areturn，另外一个return供void方法，实例初始化方法，类和接口的类初始化i方法使用。 同步Eg:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// class version 52.0 (52)// access flags 0x21public class Main &#123; // compiled from: Main.java // access flags 0x11 public final I simpleField = 100 // access flags 0x0 &lt;init&gt;()V L0 LINENUMBER 12 L0 ALOAD 0 INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V L1 LINENUMBER 10 L1 ALOAD 0 BIPUSH 100 PUTFIELD Main.simpleField : I L2 LINENUMBER 13 L2 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; BIPUSH 100 INVOKEVIRTUAL java/io/PrintStream.print (I)V L3 LINENUMBER 14 L3 RETURN L4 LOCALVARIABLE this LMain; L0 L4 0 MAXSTACK = 2 MAXLOCALS = 1 // access flags 0x9 public static main([Ljava/lang/String;)V L0 LINENUMBER 16 L0 NEW Main DUP INVOKESPECIAL Main.&lt;init&gt; ()V ASTORE 1 L1 LINENUMBER 17 L1 GETSTATIC java/lang/System.out : Ljava/io/PrintStream; LDC &quot;--&gt;&quot; INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V L2 LINENUMBER 19 L2 RETURN L3 LOCALVARIABLE args [Ljava/lang/String; L0 L3 0 LOCALVARIABLE main LMain; L1 L3 1 MAXSTACK = 2 MAXLOCALS = 2 // access flags 0x21 public synchronized a(I)V throws java/lang/Exception L0 LINENUMBER 23 L0 RETURN L1 LOCALVARIABLE this LMain; L0 L1 0 LOCALVARIABLE a I L0 L1 1 MAXSTACK = 0 MAXLOCALS = 2&#125;]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于HTTPS]]></title>
    <url>%2F2016%2F06%2F02%2FHttps-%E7%AD%BE%E8%AF%81%2F</url>
    <content type="text"><![CDATA[这是一篇关于HTTPS的日常使用记录，例如:博客HTTPS化~来吧!年轻人!装逼HTTPS时代到了 关于https什么是HTTPS ? 通俗的讲：隐私安全 GitHub page 使用https主要是使用 Kloudsec 申请账号，填入待解析的域名 把DNS解析转到该网站提供的地址 验证邮箱并填入GitHub page IP 开启相关服务 PROTECTION -&gt; SSL Encryption PLUGIN STORE成品NOTE: 2016年09月04日 发现Kloudsec已经倒闭了现在使用的是Cloudflare具体使用注册时有引导教程(需把域名解析服务器改为cloudflare的). 自己搭建的blog免费的使用 Startssl成品 TOMCAT 配置https环境 keytool 教程外网回调可尝试使用nat123 自己VPS使用HTTPSLet’s Encrypt :)]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 新特性]]></title>
    <url>%2F2016%2F05%2F10%2FES6-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[NodeJS 的构建工具层出不穷，因此了解一下陈旧事物的进展。 简介es6: ecmscript6 新特性 let 块级作用域, 注: es5中var声明的上全局范围的 const 常量 class 类 extends 继承 super 指代父类的实例 arrow functions 语法糖 12345/** * 语法: (参数) =&gt; &#123;执行代码&#125; **/function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; &#123; i + 1 &#125; //ES6 template string 模版字符 1234567/** * 语法: `$&#123;变量&#125;` **/ const name = 'hocgin'; console.log(`this is template strnig &lt;b&gt;$&#123;name&#125;&lt;/b&gt; `); destructuring 12345678let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125;let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default 默认值 12345678910/** * 语法: * function &lt;method name&gt;(param = &lt;default value&gt;) &#123; * ... * &#125; **/ function animal(type = 'cat')&#123; console.log(type) &#125; animal(); rest 可变参数 12345678910/** * 语法: * function &lt;method name&gt;(...params) &#123; * ... * &#125; **/ function animals(...types)&#123; console.log(types) &#125; animals('cat', 'dog', 'fish'); import export 模块设计 es6 把一个文件当作一个模块, 一个模块可export多个变量, 因此不同的export可对应不同的import 12345678910111213141516171819// 导出模块export animal// 导入模块 - 变量为 animalimport animal from './content'//--------------------// 导出模块export &#123;dog, cat&#125;// 导入模块 - 变量为 [dog, cat]import &#123;dog, cat&#125; from './content'//--------------------export &#123;dog, cat&#125;// 全部导入import * as animal from './content'// ormodule animal form './content'//--------------------// 默认导出, 一个模块只能使用 export default 一次export default 'dog dog'import animal from './content']]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Maven下载jar包 linux版]]></title>
    <url>%2F2016%2F04%2F25%2F%E4%BD%BF%E7%94%A8Maven%E4%B8%8B%E8%BD%BDjar%E5%8C%85-linux%E7%89%88%2F</url>
    <content type="text"><![CDATA[这只是学习Shell的小脚本, 练手工具罢了.. 折腾!折腾啊 目录结构123Green4nodeJS├── down.sh // 下载shell，o(╯□╰)o其实就是一条shell└── pom.xml // 正常maven配置 文件内容down.sh 内容：1234567891011#!/bin/sh# Author: hocgin@gmail.com# -------------Use--------------# sh down.sh# ------------------------------# 运行pom.xml 下载jarNOW_PATH=$(cd "$(dirname "$0")"; pwd)POM_XML=$NOW_PATH"/pom.xml"TARGET_DIR=$NOW_PATH"/target"mvn -f $POM_XML dependency:copy-dependenciessudo chmod -R 777 $TARGET_DIR pom.xml 内容： 正常maven的pom.xml内容 1234567891011121314151617181920&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 项目的名称 start --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;temp.download&lt;/groupId&gt; &lt;artifactId&gt;temp-download&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 项目的名称 end --&gt; &lt;dependencies&gt; &lt;!-- 要下载的jar start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20160212&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 要下载的jar end --&gt; &lt;/dependencies&gt;&lt;/project&gt; 完成 使用方法123456source init.sh# Or. init.shcd hocgin.github.io# 尽情hexo吧 End]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>Tips</tag>
        <tag>Maven</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绿化NodeJS for linux版]]></title>
    <url>%2F2016%2F04%2F25%2F%E7%BB%BF%E5%8C%96nodejs-for-linux%E7%89%88%2F</url>
    <content type="text"><![CDATA[起因，为了方便hexo发布博客，所以想把NodeJS绿化在U盘上..谁叫网上只有win版的呢！自己码起来～绿化 o(╯□╰)o 目录结构12345678Green4nodeJS├── hocgin.github.io // github博客目录├── node // nodejs基本目录│ ├── node-linux // nodejs源文件│ ├── cache // 创建一个空文件夹，即可│ ├── init-module // 创建一个空文件夹，即可│ └── userconfig // 创建一个空文件夹，即可└── init.sh // 初始化shell文件 *重要 初始化文件 主要是加载配置环境，初始化变量 init.sh 内容123456789101112131415161718#!/bin/bash# Author: hocgin@gmail.com# -------------Use--------------# source init.sh or . init.sh# ------------------------------NOW_PATH=$(cd "$(dirname "$0")"; pwd)NODE_NAME="node-linux"NODE_HOME=$NOW_PATH"/node/"$NODE_NAMENODE_PATH=$NODE_HOME"/bin"NPM_PATH=$NODE_HOME"/lib/node_modules/npm/bin"sudo chmod +x -R $NPM_PATH"/."export PATH=$PATH:$NODE_PATH:$NPM_PATH# "/home/hocgin/.npmrc"npm set userconfig $NOW_PATH"/node/userconfig"# "/home/hocgin/.npm-init.js"npm set init-module $NOW_PATH"/node/init-module"# "/home/hocgin/.npm"npm set cache $NOW_PATH"/node/cache" 修改 /node/node-linux/lib/node_modules/npm/bin/npm 文件12# NPM_CLI_JS="$basedir/node_modules/npm/bin/npm-cli.js"NPM_CLI_JS="$basedir/npm-cli.js" 完成 使用方法123456source init.sh# Or. init.shcd hocgin.github.io# 尽情hexo吧 注: 安装module时请加上 -g End]]></content>
      <categories>
        <category>Coder</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 功能扩展]]></title>
    <url>%2F2016%2F03%2F26%2Fhexo-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[这是自己参照hexo进行私人订制的教程，也是实战的记录，感觉还不错，成品可参照本博客.. （如果我以后没换的话😶） 须知站点目录: /主题目录: /themes/[主题名]主题配置文件: /themes/[主题名]/_config.yml站点配置文件: /_config.yml 添加微信公众号二维码首先，打开主题目录下的 layout/_macro/post.swig然后，找到节点footer加入以下代码1234567891011121314&lt;! -- 添加微信图标 start --&gt; &#123;% if theme.wechat_subscriber.enable %&#125; &#123;% if !is_home() %&#125; &lt;div class="hocgin-container"&gt; &lt;div class="folder"&gt; &lt;div class="paper"&gt; &lt;img width="100%" src="&#123;&#123; theme.wechat_subscriber.qcode &#125;&#125;"/&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="hocgin-description"&gt;&#123;&#123; theme.wechat_subscriber.description &#125;&#125;&lt;/div&gt; &#123;% endif %&#125; &#123;% endif %&#125;&lt;! -- 添加微信图标 end --&gt; 其次，到主题目录下的source/css创建文件夹_hocgin并在它之下创建css文件customize-hocgin.css以下是文件内容：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849.hocgin-container *, *:before, *:after &#123; box-sizing: border-box;&#125;.hocgin-container &#123; position: relative; width: 100%; height: 100%;&#125;.hocgin-container &gt; .folder &#123; width: 220px; height: 180px; left: calc(50% - 110px); top: calc(70% - 90px); position: relative;&#125;.hocgin-container &gt; .folder &gt; .paper &#123; opacity: 1; position: absolute; overflow: hidden; width: 200px; height: 200px; top: calc(50% - 111px); left: calc(50% - 100px); transition: top 0.5s, opacity 0.4s; font-family: Verdana, Tahoma, sans-serif; font-size: 0.1em; padding: 1em; color: #644812; background-color: #fde1ab; -moz-box-shadow: 10px 10px rgba(0, 0, 0, 0.2); -webkit-box-shadow: 10px 10px rgba(0, 0, 0, 0.2); box-shadow: 10px 10px rgba(0, 0, 0, 0.2); -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125;.hocgin-container &gt; .folder:hover &gt; .paper &#123; top: calc(50% - 150px);&#125;.hocgin-container &gt; .folder.opened &gt; .paper &#123; top: calc(-250px); opacity: .9;&#125;.hocgin-description &#123; text-align: center; margin-top: 4px;&#125; 保存后，找到主题目录下source/css/main.styl(注：别的主题可能不一样) 追加12// --------------------------------------------------@import "_hocgin/customize-hocgin.css"; 最后，修改主题配置文件 追加12345# Customize args -- Hocginwechat_subscriber: enable: true qcode: [url] description: 欢迎您扫一扫上面的微信公众号，订阅我的博客！ 效果http://hocg.in 底部加入打赏功能首先，打开主题目录下的 layout/_macro/post.swig然后，找到节点footer加入以下代码12345678910111213141516171819 &lt;! -- 添加打赏图标 start --&gt; &#123;% if theme.pay_money.enable %&#125; &#123;% if !is_home() %&#125; &lt;div class="hocgin-money"&gt;&lt;div class="money-reward"&gt; 赏 &lt;div class="money-pay"&gt; &lt;img width="100%" src="&#123;&#123; theme.pay_money.weixin_qcode &#125;&#125;"/&gt; &lt;/div&gt; &lt;div class="money-pay"&gt; &lt;img width="100%" src="&#123;&#123; theme.pay_money.alipay_qcode &#125;&#125;"/&gt; &lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;br/&gt; &lt;br/&gt; &#123;% endif %&#125; &#123;% endif %&#125; &lt;! -- 添加打赏图标 end --&gt; 其次，到主题目录下的source/css创建文件夹_hocgin并在它之下创建css文件money-customize-hocgin.css以下是文件内容：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.hocgin-money *, *:before, *:after &#123; box-sizing: border-box;&#125;.hocgin-money &gt; .money-reward &#123; font-size: 2.4rem; line-height: 4.6rem; display: block; width: 4.6rem; height: 4.6rem; margin: 0 auto; padding: 0; -webkit-user-select: none; text-align: center; vertical-align: middle; color: #fff; border: 1px solid #f1b60e; border-radius: 50%; background: #fccd60; background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #fccd60), color-stop(100%, #fbae12), color-stop(100%, #2989d8), color-stop(100%, #207cca)); background: -webkit-linear-gradient(top, #fccd60 0, #fbae12 100%, #2989d8 100%, #207cca 100%); background: linear-gradient(to bottom, #fccd60 0, #fbae12 100%, #2989d8 100%, #207cca 100%); position: relative;&#125;.hocgin-money &gt; .money-reward &gt; .money-pay &#123; position: absolute; overflow: hidden; width: 200px; height: 200px; visibility: hidden; top: calc(50% - 100px); left: calc(50% - 100px); opacity: 0; transition: top 0.5s, opacity 0.4s; font-family: Verdana, Tahoma, sans-serif; font-size: 0.1em; padding: 1em; color: #644812; background-color: #fff; -moz-box-shadow: 0 1px 1px 1px #efefef; -webkit-box-shadow: 0 1px 1px 1px #efefef; box-shadow: 0 1px 1px 1px #efefef; border: 1px solid #e6e6e6;&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay &#123; visibility: visible; opacity: 1; z-index: 10;&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay:nth-child(1) &#123; top: calc(50% - 250px);&#125;.hocgin-money &gt; .money-reward:hover &gt; .money-pay:nth-child(2) &#123; top: calc(50% + 50px);&#125; 保存后，找到主题目录下source/css/main.styl(注：别的主题可能不一样) 追加12// --------------------------------------------------@import "_hocgin/money-customize-hocgin.css"; 最后，修改主题配置文件 追加12345# Customize args -- Hocginpay_money: enable: true weixin_qcode: http://cdn.hocgin.top/img/un/ali.pay.500.png alipay_qcode: http://cdn.hocgin.top/img/un/ali.pay.500.png 已知bug 因为没使用js(也不想使用)，安卓设备需要长按才能出现效果，而苹果设备无法显示效果，欢迎大家修复。┌|*´∀｀|┘ 效果http://hocg.in 防止百度转码主题目录下 \layout\_partials\head.swig12&lt;meta http-equiv=”Cache-Control” content=”no-transform” /&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt; 添加搜索功能 2016年06月04日 安装hexo数据生成插件 Json格式的，有利于自主编写(暂时只介绍原生支持的，如果想自己编写下面的可以不用看) hexo-generator-json-content1$ npm i -S hexo-generator-json-content NexT 原生支持，不想折腾的可以使用 hexo-generator-search1$ npm install hexo-generator-search --save 站点配置文件 新增1234# Searchsearch: path: search.xml field: post OK！ 待续ing 结合服务器，实现自动部署 多说css美化]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>Hexo</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装完Ubuntu后,我该做什么]]></title>
    <url>%2F2016%2F03%2F20%2F%E5%AE%89%E8%A3%85%E5%AE%8CUbuntu%E5%90%8E-%E6%88%91%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[这是一篇我对Ubuntu日常使用和优化的整理，也是一篇借鉴前人的文章，还有一些可能会遇到的疑难杂病的“偏方”，希望对你有帮助:)update: 新增undistract-me终端命令完成提醒插件 yuan获取官方列表： http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8网易163： http://mirrors.163.com/.help/ubuntu.html 移除 删除libreoffice 1sudo apt-get remove libreoffice-common 删除Amazon的链接s 1sudo apt-get remove unity-webapps-common 删掉基本不用的自带软件 12sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-installsudo apt-get remove onboard deja-dup shang xia zuoyou 12sudo apt-get remove vim-commonsudo apt-get install vim 字体monaco苹果字体https://github.com/cstrap/monaco-font1curl -kL https://raw.github.com/cstrap/monaco-font/master/install-font-ubuntu.sh | bash consolas微软字体 Gnome3安装1.安装Gnome3桌面12345678910# 安装sudo add-apt-repository ppa:gnome3-team/gnome3sudo apt-get updatesudo apt-get install ppa-purgesudo ppa-purge ppa:gnome3-team/gnome3sudo apt-get dist-upgradesudo apt-get install gnome-themes-standard ubuntu-desktop gnome-shell# 删除sudo apt-get install ppa-purgesudo ppa-purge ppa:gnome3-team/gnome3 2.Gnome3系统下载 主题主题文件位置：~/.themes 或 /usr/share/themes 1.Paper1234# 下拉gitgit clone https://github.com/snwh/paper-gtk-theme.git# 运行安装脚本sh ./install-gtk-theme.sh 2.Numix-Circle 很赞 1234# 安装sudo apt-add-repository ppa:numix/ppasudo apt-get updatesudo apt-get install numix-icon-theme-circle 插件支持 gnome-tweak-tool Gnome3的调节软件可直接管理插件 1sudo apt-get install gnome-tweak-tool 插件下载网站: https://extensions.gnome.org/ 使用Chrome 插件 系统安装chrome-gnome-shell 1234sudo add-apt-repository ppa:ne0sight/chrome-gnome-shell# trustysudo apt-get updatesudo apt-get install chrome-gnome-shell 插件列表 名称 描述 推荐 Autohide battery 可以在电池充满的情况下隐藏电池图标 推荐 Battery status 可以显示当前电池电量以及可以使用的时间 推荐 Dash to dock 在屏幕左边显示一个快速启动条 推荐 Freon 显示当前磁盘，显卡，CPU等等温度 不推荐，推荐SysPeek Lock Keys 显示当前的 Num Lock, Caps Lock 的状态 推荐 Refesh wifi connections 在 wifi 列表上显示一个刷新图标 推荐 status title bar 讲状态条上的标题改为当前窗口的标题 推荐 Coverflow Alt-Tab 类似WIN 7切换特效 太显眼，不推荐 OpenWeather 天气预报 推荐 NetSpeed 显示网速 不推荐，推荐SysPeek system-monitor 显示当前系统信息 太显眼，不推荐 Dynamic Top Bar 在当前没有最大化窗口时使顶栏透明 推荐 Impatience Gnome Shell 动画提速 推荐 Better Volume Indicator 透过鼠标滚轮操作更便捷地调整音量 推荐 Media player indicator 显示音乐播放器的状态 推荐 Workspaces-to-dock 将工作区转变为一个可自动隐藏的停靠栏 推荐 Panel OSD 修改通知显示位置 推荐 Clipboard Indicator 剪贴板指示器 推荐 Caffeine 禁止自动挂起或锁屏 推荐 Transmission Daemon Indicator Transmission面板指示器 推荐，需要Transmission Daemon Icon Hider 显示/隐藏顶栏图标 推荐 Top Panel Workspace Scroll 在顶栏上滚动鼠标中键来快速切换工作区。在topbar按住shift+滚轮 推荐 Drop Down Terminal 终端快捷方式 推荐 Windows Blur Effects 给未激活的窗口添加模糊效果 不推荐 Modern Calc 功能齐全的计算器扩展 没找到 EasyScreenCast 录屏工具 推荐 Place status indicator 快速访问一些文件夹 推荐，没装上 Removable drive menu 显示连接到电脑的usb设备 推荐 User themes 用来启用自定义的shell主题 推荐，没装上 Workspace indicator 在顶栏显示当前示工作区的序号 推荐 touchpad-indicator 插入鼠标时自动使触摸板失效 推荐 壁纸1234567# 1.安装archiboldcurl -L -O http://archibold.io/sh/archiboldchmod +x archiboldsudo mv archibold /usr/bin# 2.执行archibold login-background [壁纸的位置] 此外还可以让桌面和锁屏界面使用动态壁纸，动态壁纸由一个xml文件构成，就像这样：12345678910111213141516171819202122232425262728293031323334&lt;background&gt; &lt;starttime&gt; &lt;year&gt;2011&lt;/year&gt; &lt;month&gt;11&lt;/month&gt; &lt;day&gt;24&lt;/day&gt; &lt;hour&gt;7&lt;/hour&gt; &lt;minute&gt;00&lt;/minute&gt; &lt;second&gt;00&lt;/second&gt; &lt;/starttime&gt; &lt;static&gt; &lt;duration&gt;3600.0&lt;/duration&gt; &lt;file&gt;picture1.jpg&lt;/file&gt; &lt;/static&gt; &lt;transition type="overlay"&gt; &lt;duration&gt;18000.0&lt;/duration&gt; &lt;from&gt;picture1.jpg&lt;/from&gt; &lt;to&gt;/picture2.jpg&lt;/to&gt; &lt;/transition&gt; &lt;static&gt; &lt;duration&gt;18000.0&lt;/duration&gt; &lt;file&gt;picture2.jpg&lt;/file&gt; &lt;/static&gt; &lt;transition type="overlay"&gt; &lt;duration&gt;21600.0&lt;/duration&gt; &lt;from&gt;picture2.jpg&lt;/from&gt; &lt;to&gt;picture1.jpg&lt;/to&gt; &lt;/transition&gt;&lt;/background&gt; 简单解释以下这个xml文件的含义： starttime：这个部分规定了壁纸切换起始时间，设置成过去的某个时间即可(设置成2020年就要等到2020年才会有效果)static：这个部分表示在duration规定的时间(以秒为单位)中壁纸都是file中给定的那张图片transition：这个部分表示在duration规定的时间内壁纸从from中的图片切换到to中的图片你可以添加任意多个static+transition的组合，只需要最后一个transition切换回最初的static那张图片就可以循环更换壁纸了。 那么如何启用这样的xml文件呢，单凭系统设置无法办到，我们需要使用dconf系统配置编辑器。首先打开dconf编辑器，展开org–gnome–desktop–background这一项，可以看到其中的picture-uri修这一项的默认值是file:///usr/share/backgrounds/gnome/adwaita-timed.xml，这个就是你刚装好桌面是的默认壁纸啦，将其改成你的xml文件就可以了。锁屏界面的壁纸更换方法也一样，只不过把org–gnome–desktop–background改成org–gnome–desktop–screensaver而已 软件安装指令安装 命令面板小提示 1234# 安装sudo apt updatesudo apt install python3-dev python3-pipsudo -H pip3 install thefuck 科学上网 Client-SS 123456789# 安装sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5# 安装 pipsudo pip install genpac# 下载自动翻墙列表genpac -p "SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" --output="~/Documents/autoproxy.pac" --gfwlist-url="https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt" --user-rule-from="user-rules.txt" 添加开机启动command：/usr/bin/ss-qt5 屏幕截图 Shutter 12345# 安装sudo apt-get install Shutter# 打开# 搜索 Shutter 音视频解码 ubuntu-restricted extras 12# 安装sudo apt-get install ubuntu-restricted-extras 终端命令执行完成提醒 1234567891011# 安装sudo apt-get install undistract-me# 配置vim ~/.bashrc# 新增如下两行# . /usr/share/undistract-me/long-running.bash# notify_when_long_running_commands_finish_install# 生效source ~/.bashrc# 测试sleep 11 GNOME MPV 代替VLC播放器 1234# 安装sudo add-apt-repository ppa:xuzhen666/gnome-mpvsudo apt-get updatesudo apt-get install gnome-mpv 视频播放 VLC播放器 123456# 安装sudo add-apt-repository ppa:videolan/master-dailysudo apt-get updatesudo apt-get install vlc# 使用# 搜索 vlc Grub引导 Grub Customizer可配置启动界面，启动项等 123456# 安装sudo add-apt-repository ppa:danielrichter2007/grub-customizersudo apt-get updatesudo apt-get install grub-customizer# 使用# 搜索 Grub Customizer Office WPS 12# 安装sudo apt-get install wps-office [小插件]指示器性能 SysPeek 1234# 安装sudo add-apt-repository ppa:nilarimogard/webupd8 sudo apt-get updatesudo apt-get install syspeeka Synapse 快速启动器 123sudo add-apt-repository ppa:synapse-core/testingsudo apt-get updatesudo apt-get install synapse Uget一款下载工具，配合 aria2 插件使用效果出色curl + area2 + axel 地址：参考 1234# 安装sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt-get updatesudo apt-get install uget redshift类似 f.lux 的屏幕色温调整工具 12# 安装sudo apt-get install redshift-gtk 添加开机启动command：redshift-gtk -l 39.92:116.46 -t 5500:4500 Go For It 一款整合了待办事项与计时器的生产力应用。 1234# 安装sudo add-apt-repository ppa:mank319/go-for-itsudo apt-get updatesudo apt-get install go-for-it Catfish 一款优雅迅捷的文件搜索工具12# 安装sudo apt-get install catfish 神级命令行软件 Tmux 说明1sudo apt-get install tmux cat代码高亮12# 安装pip install pygments 配置～/.bashrc加入alias cat=&#39;pygmentize -O style=monokai -f console256 -g&#39; 软件包安装系统管理 UbuntuTweak打开：搜索 Ubuntu Tweak同步软件 坚果云打开：搜索 Nutstore百度网盘桌面客户端 BCloud便签MarkDown编辑软件 HarooPad密码管理器 keepass2搜狗输入法有道词典VMware WorkstationChrome网易音乐数据库设计软件 DBdesigner4 - 问题1 听起来不错 Deluge Bittorrent 客户端 Nutty网络监测工具。 Synaptic 新立得软件包管理器 UNetbootin启动盘制作工具 Gpick拾色器。 gpaint 微软画图 ddm 驱动管理器 Navicat o(╯□╰)o 竟然是wine的 XMind 小技巧关闭系统检测报告12sudo gedit /etc/default/apport# 修改enabled=0 开机自动开启数字键1234567sudo apt-get install numlockxsudo vim /etc/gdm/Init/Default# -----------# 在文件最后exit 0的前面添加： if [ -x /usr/bin/numlockx ]; then numlockx on fi 重启即可 插入鼠标时自动使触摸板失效安装Touchpad Indicator (触摸板开关）123sudo add-apt-repository ppa:atareao/atareao sudo apt-get update sudo apt-get install touchpad-indicator 搜索 touchpad indicator 遇到显示俩个输入法图标情况有一定原因是自启项启动了一个 黑屏95% 是和显卡驱动有关 Chrome 每次打开都要求输入密码一、删除现在的密钥环 视图-&gt;根据密码环 在密码区会有一个“登录”为名字的密钥环，右击将其删除。二、添加新的密钥环 终端输入seahorse打开管理密钥环的软件，文件-&gt;新建-&gt;密码和密钥-&gt;输入名字(这里是以”chrome”为例)。密码设置为空 添加源安装后，not fount XX一、 试着访问该链接二、如果可以手动找到该路径，那便可以修改/etc/apt/source.list.d/目录下你添加的安装源文件例如1234vim /etc/apt/sources.list.d/sogoupinyin.list# 显示内容# deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main# 可修改链接部分。 网卡驱动 Realtek RTL8723AE 无线网卡驱动第一种(闭源驱动)： 1sudo apt-get install linux-firmware-nonfree 第二种(第三方驱动，PPA安装)： 123sudo add-apt-repository ppa:hanipouspilot/rtlwifisudo apt-get updatesudo apt-get install rtlwifi-new-dkms 当遇到产品无法输入中文的时候先尝试卸载ibus，如果还是不可以试试在xxx.sh的启动脚本中添加如下： 12XMODIFIERS="@im=fcitx"export XMODIFIERS 到 123# ---------------------------------------------------------------------# Run the IDE.# --------------------------------------------------------------------- 之前。通用1sudo mv /usr/bin/ibus-daemon /usr/bin/ibus-daemon.fix 解决LC_CTYPE: cannot change locale (en_US.UTF-8) 错误12# 增加en_US.UTF-8locale-gen en_US.UTF-8 修复VMware故障，闪退 下载Uefi.priv、fix.sh、Uefi.der至于同一目录. 执行 1sh fix.sh]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Tips</tag>
        <tag>Gnome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 使用小记]]></title>
    <url>%2F2016%2F03%2F15%2Fhexo-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这是一篇关于如何使用hexo的收集Box &gt; 不定期更新吧！ update 2017年01月12日10:33:55 参照 hexo 官方文档参照 next 主题参照 next 主题 for github参照 更多扩展使用 md文档头部 参数 描述 默认值 layout 布局 有哪些layout呢，请到 scaffolds 目录下查看，这些文件名称就是layout名称 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 description 添加本页描述 默认所有 photos 添加图片 hexo 基础命令1234567891011121314# 清除$ hexo clean# 上传 GitHub$ hexo deploy# 新建文章$ hexo new "postName"# 新建页面hexo new page "pageName"# 生成静态页面至public目录hexo generate# 开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo server# 将.deploy目录部署到GitHubhexo deploy .md 扩展 扩大图片宽度 1&#123;% fi image-url, alt, title %&#125; 显示 更多按钮 123以上是摘要&lt;!--more--&gt;以下是余下全文 使用标签别名 1&#123;% cq %&#125; 标签别名 &#123;% endcq %&#125; 可能遇到的问题 当你发布的.md文件中携带逗号,(已知)，在多说评论插件中将无法识别评论条数(就是文章顶部那个) 借鉴办法：替换文件命名，将逗号已_或 分隔 换电脑后, 如何迁移？123456// 为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git --save// 为了建立RSS订阅，需要安装npm install hexo-generator-feed --save// 为了建立站点地图，需要安装npm install hexo-generator-sitemap --save 可能会遇到 ‘./build/Release/DTraceProviderBindings’] code: ‘MODULE_NOT_FOUND’ 1npm install hexo --no-optional End]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
